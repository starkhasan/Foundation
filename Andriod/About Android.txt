						=#=#=#=#=#=#=#=  Android  =#=#=#=#=#=#=#=#=
Android is a mobile operating system based on a modified version of the Linux kernal software designed primarily for touchscreen mobile devices such as smartphones and tablets.

Android operating system written in Java,C++,C,XML,Assembly language, Python, Shell script, Go was developed by Linus Trovalds

=> The first beta version of the Android Software Development Kit (SDK) was released by Google in 2007 where as the first commercial version Android 1.0 was released in September 2008.

=> Buzzword of Android
Open Source
Larger Developer and Cummunity Reach
Increase Marketing
Higher Success Ratio
Rich Developement Environment


Android application can be sold out wither through a store such as Google Play Store, SlideME, Opera Mobile Store, Mobango, F-driod and Amzon Appstore.


=> API Level
API level is an integer value that uniquely identifies the framework API revision offered by a verion of the Android platform.



=> Android SDK
The Android SDK is a set of development tools used to develop applications for the Android platform.
A software development kit that enables developers to create application for the Android platform.



=> Android Layout
A layout defines the structure for a user interface in your app, such as in an activity.
All elements in the layout are build using a hierarchy of View and ViewGroup object.

A View usually draws something the user can see and interact with.
Whereas a ViewGroup is an invisible container that defines the layout structure for View and other ViewGroup objects.

=> The View object are usually called "widgets" and can be one of many subclasses such as Button or TextView.
=> The ViewGroup objects are usually called "layout" can be one of many types that provides a different layout structure such as LinearLayout or ConstraintLayout


=> Declare a Layout in two ways
1. Declare UI element in XML . Android provides a straightforword XML vocabulary that corresponds to the View classes and subclasses such as those for widget and layouts.
2. Instantiate layout elements at runtime. Your app can create View and ViewGroup object  programatically.


=> What is the benefit for declaring xml based layout.
Declaring your UI in XML allows you to separate the presentation of your app from the code that controls its behavior.
Using XML files also makes it easy to provides different layouts for different screen sizes and orientation.

=> How we load the XML resource
we can load the View resource by calling setContentView() in our Activity.onCreate() method.

	android:id="@+id/my_button"
The at-symbol (@) at the begining of the string indicates that the XML parser should parse and expand the rest of the ID string and identify it as an ID resource.
The plus-symbol (+) means that this is a new resource name that must be created and added to our resource (in the R.java file)



Constraintlayout => It allows you to create large complex layouts with a flat view hierarchy . It is similar to RelativeLayout in that all views are laid out accordingly to relationship between 
sibling views and the parent layout, but it's more flexible than RelativeLayout and easier to use with Android Studio's Layout Editor.


=> Building Layouts with an Adapter
When the content for your layout is dynamic or not pre-determined, you can use a layout that subclasses AdapterView to populate the layout with views at runtime.
A subclasses of the AdaterView classes used an Adater to bind data to its layout.
Adapter behaves as a middleman between the data source and the AdaterView layout.
The Adapter reterives the data (from a source such as an array or a database query) and convert each entry into a view can be added into the AdapterView layout.





					``=#=#=#=#=#=#=#= Android Emulator  =#=#=#=#=#=#=#=#=
The Android Emulator simulates Android devices on  your computer so that you can test your application on a variety of device and Android API levels without needing to have each 
physical device.
The emulator provides almost all of the capabilities of a real Android device. You can simulate incoming phone calls and test messages specify the location of the device simulate different
network speeds, simulate rotation and other hardware sensors, access the Google Play Store and much more.
Testing your app on the emulator is in some ways faster and easier than doing so on physical device.




					=#=#=#=#=#=#=#=  Android Architecture  =#=#=#=#=#=#=#=#=
Android operating system is a stack of software components which is roughly divided into five sections and four main layers.

1. Linux Kernal
2. Libraries => Runtime
3. Application Framework
4. Applications

1. Linux Kernal
This provides a level of abstraction between the device hardware and it contain all the essential hardware drivers like camera, keypad, display etc.

2. Libraries
On top of Linus Kernal there is a set of libraries including , SQLite database which is a useful repository for storage and sharing of application data, libraries to play and records audio and video
, SSL libraries reponsible for Internet security.


=> Android Runtime 
Dalvik Virtual Machine which is a kind of Java Virtual Machine specially designed and optimized for Android.


3. Application Framework
The Application Framework layer provides many higher-level services to applications in the form of Java classes.
Some services are , Activity Manager/Content Provides / Resource Manager /  Notifications Manager /  View System

4. Application 
All Android application found at the top layer. The application to be installed on this layer only.



					=#=#=#=#=#=#=#=  AAPT (Android Asset Packaging Tools)  =#=#=#=#=#=#=#=#=

AAPT stands for Android Asset packaging tools.
The AAPT takes your application resoruce files, such as the AndroidManifest.xml file and the XML files for your Activities and compiler them.
It compile resources into binary assests.
AAPT2 parses indexs and compiles the resource into binary format that optimized for the Android platform.




							=#=#=#=#=#=#=#= ANRs  =#=#=#=#=#=#=#=#=

When the UI thread of an application app isblocked for too long, an "Application Not Responding" (ANR) error is triggered.
If the app is in the foreground the system display a dialog to the user.
The ANR dialog gives the user the opportunity to force quite the App.

ANRs are problem because the app's main thread,which is responsible for updating the UI, can't process user input events or draw, causing frustration to the user.


=#=#=#=#=#=#=#=  Broadcast Overview  =#=#=#=#=#=#=#=#=
Generally speaking , broadcast can be used as messaging system across apps and outside of the normal user flow.

Android apps can send or receive broadcast message from the Android system and other Android apps. These broadcast are sent when an event of interest occurs.
The Android system send broadcast when various system events occurs such as when the system boots up or the device starts charging.
App can also send custom broadcast for example to notify other apps of something that they might be interested in (for example some new data has been downloaded)

(Broadcast receiver is an android component which allow you to send or receive Android system or application event occured. All registetred application are notified by the Andoid runtime
 once event happens.)


System Boradcast :-
The system broadcast automatically sends-broadcasts when various systems events occur, such as when system switched in and out of airplane mode.

The boradcast message itseld is wrapped in an Intent object whose action string identifies the event that occured (for example android.intent.action.AIRPLANE_MODE). The intent may also 
include additional information bundled into its extra field. For example the airplane mode intent includes a boolean extra that indicates whether or not Airplane Mode is ON.


Changes to system broadcasts :-----------------
Beginning with Android 8.0 (API level 26), the system impose additional restriction on manifest-declared receivers. If your app targets Android 8.0 or higher you cannot use the manifest to 
declare a receiver for most implicit broadcasts. you can still use a content-registered receiver when the user is actively using your app.


Registered broadcasts :----------------------------
Apps can receive broadcast in two ways : through manifest-declared receivers and context-registered receivers.

1) Manifest-deslared receivers (Statically)
If you declare a broadcast receiver in your manifest the system launches your app (if the app is not already running when the broadcast is sent)
NOTE :- If your app targets API level 26 or higher you cannot use the manifest to declare a receiver for implicit broadcasts.

=> To declare a broadcast receiver in the manifest perform the following steps:
<receiver android:name=".MyBroadcastReceiver"  android:exported="true">
    <intent-filter>
        <action android:name="android.intent.action.BOOT_COMPLETED"/>
        <action android:name="android.intent.action.INPUT_METHOD_CHANGED" />
    </intent-filter>
</receiver>


=> Subclass BroadcasrReceiver and implementation onReceive(Context,Intent). The broadcast receiver in the following example logs and diaply the content of broadcast:
private const val TAG = "MyBroadcastReceiver"

class MyBroadcastReceiver : BroadcastReceiver() {

    override fun onReceive(context: Context, intent: Intent) {
        StringBuilder().apply {
            append("Action: ${intent.action}\n")
            append("URI: ${intent.toUri(Intent.URI_INTENT_SCHEME)}\n")
            toString().also { log ->
                Log.d(TAG, log)
                Toast.makeText(context, log, Toast.LENGTH_LONG).show()
            }
        }
    }
}

The system package manager register the receiver when the app is installed. The receiver then become a separate entry point in your app which means that the system can start the app and deliver 
the broadcast if the app is not currently running.


2) Context-registered recevier (Dynamically)
To register a receiver with a content perform the following steps:

1) Create an instance of BroadcastReceiver
val br : BroadcastReceiver = MyBroadcastReceiver()

2) Create an IntentFilter and register the receiver by calling registerReceiver(BroadcastReceiver,IntentFilter)
val filter = IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION).apply {
    addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED)
}
registerReceiver(br, filter)


or

IntentFilter filter = new IntentFilter();
intentFilter.addAction(getPackageName() + "android.net.conn.CONNECTIVITY_CHANGE");
 
MyReceiver myReceiver = new MyReceiver();
registerReceiver(myReceiver, filter);



Context-registered receiver receive broadcast as logn as their registering content is valid. (If you register with an activity content you receive brodcast as long as the activity is not detroyed. 
If you register with the applciationContext you receive broadcast as long as the app is running)

=> To stop receiving broadcast call unregisteredReceiver(android.content.BroadcasatReceiver) Be sure to unregister the receiver when you no longer need it or the content is no longer valid.


NOTE =>
If you register a receiver in onCreate(Bundle) using the activity's context. you should unregistered it in onDestroy() to prevent leaking the receiver out of the activity's context
If you register a receiver in onResume(), you should unregistere it in onPause() to prevent registering it multiple times.

(Don't unregisterd in onSaveInstanceState(Bundle), because this isn't called if the user moves back in the history stack).


Pending Intent =>
A Pending intent is a token that you give to another application . For example the nootification manager, alarm manager or other 3rd party application) This allows the other application to 
restore the permission of your application to execute a predefined piece of code.


=> If the communication is limited to your application then it is not good to use the global broadcast (In this case use localbroadcast manager)
	(LocalBroadcast Manager is performed efficinetly )








 =#=#=#=#=#=#=#=  Intent and Intent Filter  =#=#=#=#=#=#=#=#=

An Intent is a messaging object you can use to request an action from one app component to another app component. 
Intent established communication between components in several ways

* Starting an activity
An Activity represents a single screen in an app. You can start a new instance of an Activity by passing an Intent to startActivity(). The Intent describes the activity to start and carries any necessary
data.

If you want to receive a result from an activity when it finishes call startActivityForResult(). Your Activity receive the result as a separate Intent object in your activity's onActivityResult()
callback.


* Starting a service
A service is component that perform operation in the background without a user interface. With Android 5.0 and later , you can start a service with JobScheduler.

For version earlier than Android 5.0 (API level 21), you can start a service by using method of the service class. You can start a service to perform  a one-time operation (such as downloading a file)
by passing an Intent to startService(). The Intent describes the service to start and carries any necessary data.

If the service is designed with a client-server interface, you can bind to the service from another component by passing an Intent to bindService().


* Delivering a broadcast
A broadcast is a message that any app can receive. The system deliver various broadcast for system events, such as when the system boots up or the device charging. you can deliver a 
broadcast to other apps by passing an Intent or sendBroadcast() or sendOrderedBroadcast().



=> Two Types of intent
1) Explicit Intent 2) Implicit Intent

Explicit Intent =>
specify which application will satisfy the  intent , by supplying ther target app's package name or fully-qualified component class name. You will typically use an expiclity intent to start a 
component in your own app because you know the class name of the activity or service you want to start 

Implicit Intent =>
do not name a specific component but instead declare a general action to perform which allows a component from another app to handle it.

(When  you use an implicit intent the Android system finds the appropriate component to start be comparing the content of the intent to the intent filters declared in the manifest file of the
other app on the device, If the intent matches an intent filter the system start that component and delivers it the Intent object. If multiple intent filters are compatiable the system display a 
dialog from which the user can pick which app to use.)

Building an intent =>
An Intent object carries information that the Android system uses to determine which component to start (such as the exact component name or component category that should receive the 
intent) plus information that the recipient component uses in order to properly perform the action (such as the action to take and the data to act upon).

The parimary information contained in an Intent is the following
=> Component name
The name of the component to start , This is optional but it is critical piece of information that makes an intent explicit meaning that the intent should be delivered only to the app component 
defined by the component name. (With out the component name the intent is implicit and the system decides which component should receive the intent based on the other intent information
 such as the action , data, and category)

you can set component name with setComponent(), setClass(), setClassName() or with Intent constructor.

Action => 
A string that specifies the generic action to perform (such as  view or pick)
We can specify our own actions for use by intents within our app.
Common actions for starting an activity:

ACTION_VIEW
Use this action in an intent with startActivity() when you have some information that an activity can show to the user such as photo to view in gallery or an address to view in a map app.
ACTION_SEND
Also known as the share intent you should use this intent with startActivity() when you have some data the user share through another app, such as an email app or social sharing app.

You can specify the action for an intent with setAction() or with in Intent constructor.

Data =>
The URI (a Uri object) that references the data to be acted on and/or the MIME type of the data. The type of the data supplies is generally dictated by the intent's action. For example if the
action is ACTION_EDIT the data should contain the URI of the document to edit.
A content URI indicates the data is located on the device and controlled by a ContentProvider which makes the data MIME type visible to the system.
To set only the data URI call setData() to set only the MIME type call setType(). If neccessary you can set both explicity with setDataAndType().



Extras :-
Key-value pair that carry additional information required to accomplish the request action. Just as some actions use particular kind of the data URIs some actions also use particular extras.
You can add extra data various putExtra() method each accepting two parameter: the key name and the value. you can also create Bundle object with all the extra data then insert the Bundle in 
the Intent with purExtras() .


Flags :-
Flags are defined in the Intent class that function as metadata for the intent. The flag may instruct the Android system how to launch an activity (for example which task the activity should 
belong to ) how to treat it after it's launched.


Example of Implicit Intent =>

// Create the text message with a string
val sendIntent = Intent().apply {
    action = Intent.ACTION_SEND
    putExtra(Intent.EXTRA_TEXT, textMessage)
    type = "text/plain"
}

// Verify that the intent will resolve to an activity
if (sendIntent.resolveActivity(packageManager) != null) {
    startActivity(sendIntent)
}




Forcing an app chooser =>
When there is more than one app that responds to your implicit intent the user can select which app to use and make that app the default choice for the action.
To show the chooser create an Intent using createChhoser() and pass it to startActivity()

Example =>
val sendIntent = Intent(Intent.ACTION_SEND)
// Always use string resources for UI text.
// This says something like "Share this photo with"
val title: String = resources.getString(R.string.chooser_title)
// Create intent to show the chooser dialog
val chooser: Intent = Intent.createChooser(sendIntent, title)

// Verify the original intent will resolve to at least one activity
if (sendIntent.resolveActivity(packageManager) != null) {
    startActivity(chooser)
} 


Intent-Filter =>
An Intent-Filter is an expression in an app's manifest file that specifies the type of intent that the component would like to receive. For instance by declaring an intent filter for an activity
you make it possible for other apps to directly start your activity with a certain kind of intent.
When you create an implicit intent. the Android system finds the appropriate components to start by comparing the contents of the intent to the filters declared in the manifest file of other
apps on the device. If the intent matches an intent-filter the system start that component and delivers it the intent object.

Inside the <intent-filter> you can specify the type of intent to accept using one or more of these three elements:

<action>
Declares the intent action accepted in the name attributes. The value must be the literal string value of an action not the class constant.

<data> 
Declares the type of data accepted using one or more attributes that specify various aspect of the data URI (schema, host, port, path) and MIME type.

<category.
Declares the intent category accepted in the name attributes. The value must be the string value of an action not the constant.


For example here's an activity declaration with an intent filter to receive an ACTION_SEND intent when the data type is text:
<activity android:name="ShareActivity">
    <intent-filter>
        <action android:name="android.intent.action.SEND"/>
        <category android:name="android.intent.category.DEFAULT"/>
        <data android:mimeType="text/plain"/>
    </intent-filter>
</activity>





=#=#=#=#=#=#=#=  Services  =#=#=#=#=#=#=#=#= 
A Services is an application component that can perform logn-running operation in the background. It does not provide a user interface. Once started a service might continue running for some 
time even after the user switches to another application.

Additonally a component can bind to a service to interact with it and even perform interprocess communication.

Types of Services :-
1) Foreground Service
2) Background Service
3) Bound Service


Forground Service :-
A forground service perform some operation that is noticeable to ther user
Forgroundservice must diaply Notification
Forground service continue running even the user isn't interacting with the app.
( When you use a forground service you must display a notification so that user are actively aware that the service is running. This notification cannot be dismissed unless the service is either 
stopped or removed from the foreground. )



Background :-
A background service perform an operation that isn't directly noticed by the user. For example if an app used a service to compact its storage that would usually be a background service.


Bound :-
A Service is bound when an application component binds to it by calling bindService(). A bound service offers a client-server interface that allow component to interact with the service, send 
request , receive result and even do so across process with interprocess communication.







Creating a started service :-
A started service is one that another component start by calling startService(). which result in  a call to the service's onStartCommand() method.
When a service is started it has a lifecycle that's independent of the component that started it. The service can run in the background indefinitely even if the component that started it is destroyed.
As such the service should stopitself when its job is complete by calling stopSelf(), or another component can stop it by calling stopService().


Th service class is the base class for all services. When you extends this class it's important to create a new thread in  which the service can complete all of its work; the service uses your application
main thread by default which can slow the performance of any activity that your applciation is running.

(Android framework also provides the IntentService subclass of Service that uses a worker thread to handle all of the start requests one at a time. Using this class is not recommended for new
apps as it will not work well starting with Android 8.0   you can use JobIntentService as replacement for intentService)


 
onStartComment() handles all incoming calls
onStartCommend() method must return an integer, The integer is a value that describes how the system should continue the service in the event that the system kills it.


Starting a service :-
you can start a service from an activity or other applciation component by passing an Intent to startService() or startForegroundService().The Android system calls the service onStartCommand()
methods and passes it the Intent which specifies which service to start.

If the service isnot already running the system first calls onCreate() and then it calls onStartCommend().

=> If the service doesn't also providing binding, the intent that is delivered with startService() is the only mode of the communication between the application component and the service.
if you want the service to send a result back the client that starts the service can create a Pendingitent for broadcast (with getBroadcast()) and deliver itto the service in the intent start the
service.







						=#=#=#=#=#=#=#=  Firebase  =#=#=#=#=#=#=#=#=
What is Firebase?
Firebase is a Backend-as-a-Service (Baas). 
It provides developers with a variety of tools and services to help them develop quality apps, grow their user base Application. It is built on Google's infrastructure.
It is Google's mobile platform that helps you quickly develop high quality app.


Key Features of Firebase =>
1. Authentication
2. Realtime Database
3. Hosting
4. Test Lab
5. Notification
6. ML Kit






