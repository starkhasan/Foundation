22:47 05-01-2020   Using Lambda Expression in Android :--------------------------------------------

Lambda expression are one of the most important java 8 feature which helps us to write compact and clear functional interface (ie interfaces with only one abstract method ) be removing boilerplate code.

In Android we usually use functionally interfaces while implementing anonymous inner classes as event listeners a typical use of a functional interfaces is implementing a button;s View.OnClickListener in an activity or Fragment where we pass functionality as an argument to a method (eg buttonSend.setOnClickListener(...)).


which Android version supports Lambda expression?
Android Naught (version 7.0 API level 24) supports lambda expression so if you are planning to use lambda expression then your app should target 
API level 24 or above


How to enable Lambda expression in the APP?
In order to use the lambda expression and other support Java 8 feature in your app. you have to use the Jack toolchain (Jack toolchain cimpiles)
java source into Android radable DEX bytecode.


What is the syntax of the Lambda Expression.
A Lambda expression consist of the following:
A comma separated list of formal parameters enclose in the paranthsis can be omitted if there is only one parameter
 the arrow token ->








10:30 23-11-2019  Context in Android :-------------------------------------------------------------

A context is handle to the system. It provides services like resolving resources obtaining access to  database and preferences and so on. An Android app has activities Context is like a handle to the environment your application is running in.

getApplicationContext() => Return the context of the process of all activitie running inside it.If you need a context that bind lifecycle of application you can use this.You should use it in across the activity.

getBaseContext() => if you want to access context from another context within application you can access.

getContext() Returns the context view inly running activity.




=>   ViewPager  :----------------------------------

Layout manager  that allows the user to flip left and right page of data.You  supply an implementation of a PageAdapter to generates the pages that the view shows.
The view's position can be controlled via its android:layout_gravity attribute.


00:47 25-09-2019     Android Libraries :------------------------------------------------------------
In Programming a libraries is a collection of precompiled routines that a program can use.
The routines sometimes called module are stored in object format.
Libraries are particularly useful for storing frequently used routine because you don't need to explicitly link them to every program that uses them.

1) Html Recycler
This ia an interesting libraries which converts a simple HTML page into a RecyclerView of native Android widget powered by Jsoup libraries and inspired by Medium TextView.


2) LayoutMangerGroup
This is a library which offers set of LayoutManager for RecyclerView to achieve feature and effect like in the gif below.


These LayoutManagers mainly extend RecyclerView.LayoutManager or just LinearLayoutManager and add more functionality on the top of that.



3) Checkable ChipView
This is a checkable widget for Android based on the EventFilterView from the Google I/O 2018 app. It requires Android minSdkVersion 21 to work.

4) ONboxRecyclerView
This is a libraray for build

















	Application Fundamentals :-------------------------

Android apps can be written using Kotlin,Java and C++ languages . The Android SDK tools compiles your code along with any data and recources files into an APK, an Android package
which is an archive file with an .apk suffix.
One APK file contains all the content of an Android app and is the file that Android-powered device use to install the app.


The Android system implements the principle of least privilage .That is each app by default has access only to the components that it requires to do its work and no more. This creates a very secure environment only to the components that it requires to do
 its work and  no more. This creates a very secure environment in which an app can't access parts of the system for which it is not given permisson.




	Application Component :----------------------------

App components are essentially building blocks of an Android app. Each component is an entry point through which the system or a user can enter your app. Some component depends on others.
 
There are four different types of app components :-
1) Activities
2) Services
3) Broadcast Receiver
4) Content Provides

Each type serves a distinct purpose and has a distinct lifecycle that defines how the component is created and destroyed

1) Activity
An Activity is the entry point for interacting with the user.
It represent a single screen with a user interface.
Example :- An email app might have one activity that shows a list of new emails, another activity to compose an email, and another activity for reading emails.


2) Services

A Serivces is an application component that can perform long-running operations in the background, and it doesn't provide a user interface. Another application component can start a service and it continues to run in the background even if the user switches to another application.
A services is a general-purpose entry point for keeping an app running background for all kinds of reasons.
It is a component that runs in the background to perform long-running operations or to perform work for remote processes.
A services does not provide a user interface.
Example : A service might play music in the background while the user is in a different app, or it might fetch data over the network without blocking user interaction with an activity.


Bound services run because some other app (or the system) has said that it wants to make use of the service. This is basically the service providing an API to another process.










3) Broadcast Receiver
A broadcast receiver is a component that enables the system to deliver events to the app outside of a regular user flow, allowing the app to respond to system-wide broadcast 
announcements. Because broadcast receivers are another well-defined entry into the app, the system can deliver broadcasts even to apps that aren't currently running.


4) Content Providers
A content provider manages a shared set of app data that you can store in the file system, in a SQLite database, on the web, or on any other persistent storage location that your app can 
access. Through the content provider, other apps can query or modify the data if the content provider allows it. 
For example, the Android system provides a content provider that manages the user's contact information.


An  activity is a single focused thing that the user can do. Almost all activities interact with the user so the Activity class take care of creating a window for you can place UI with setContentView(View) while activities are often presented to the user as full-screen windows, they can also be used in other ways as floating windows (via a theme with R.attr.windowIsFloating set), Multi-Window mode or embedded into other windows. 
There are two methods almost all subclasses of Activity will implement:

=> onCreate(Bundle) is where you initialize your activity. Most importantly, here you will usually call setContentView(int) with a layout resource defining your UI, and using findViewById(int) to retrieve the widgets in that UI that you need to interact with programmatically.

=>onPause() is where you deal with the user pausing active interaction with the activity. Any changes made by the user should at this point be committed (usually to the ContentProvider holding the data). In this state the activity is still visible on screen.



	Activating Components :----------------

Three of the four component types --activities , services, and broadcast receivers -- are activated by an asynchronous message called an Intent.
Intent bind individual component to each other at runtime. An intent is created with an Intent object, which defines a message to activate either a specific component (explicit intent ) or a 
specific type of component (impicit intent).

For activities and services an intent defines the action to be perform (for example to view  or send something) 




---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Android Toast
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
A toast provides simple feedback about an operation in a small popup.It only fills the amount of space required for the message and the current 
and current activity remains visible and interactive. Toasts automatically disapper after a timeout.


The Basics :----
First instantiate a Toast object with one  of the makeText() methods. This method take three parameter the application context, the text message and the duration for the toast. It returns a properly initialized Toast object. You can display the toast notification with show() as shown in the following example.

Context context = getApplicationContext();
CharSequence text = "Hello toast!";
int duration = Toast.LENGTH_SHORT;

Toast toast = Toast.makeText(context, text, duration);
toast.show();

we can also chain our methods and avoid holding on to the Toast object like this:

	Toast.makeText(context,text,duration).show();


=> Positioning the Toast Notification

A standard toast notification appears near the buttom of the screen cetered horiontally.You can change this position with the setGravity(int,int,int) methods. This accepts three parameter a Gravity constant an x-position offset and a y-position offset.

	toast.setGravity(Gravity.TOP|Gravity.LEFT, 0, 0);



=> Creating Custom Toast View
If a simple text message isn't enough you can create a customized layout for your notification. To create a custom layout define a View layout in XML or in your application code and apss the root View object to the setView(View) method.

<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:id="@+id/custom_toast_container"
              android:orientation="horizontal"
              android:layout_width="fill_parent"
              android:layout_height="fill_parent"
              android:padding="8dp"
              android:background="#DAAA"
              >
    <ImageView android:src="@drawable/droid"
               android:layout_width="wrap_content"
               android:layout_height="wrap_content"
               android:layout_marginRight="8dp"
               />
    <TextView android:id="@+id/text"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:textColor="#FFF"
              />
</LinearLayout>

Notice that the ID of the LinearLayout element is "custom_toast_container".You must use this ID and the ID of the XML layout file "custom_toast" to inflate the layout as shown here


LayoutInflater inflater = getLayoutInflater();
View layout = inflater.inflate(R.layout.custom_toast,(ViewGroup) findViewById(R.id.custom_toast_container));

TextView text = (TextView) layout.findViewById(R.id.text);
text.setText("This is a custom toast");

Toast toast = new Toast(getApplicationContext());
toast.setGravity(Gravity.CENTER_VERTICAL, 0, 0);
toast.setDuration(Toast.LENGTH_LONG);
toast.setView(layout);
toast.show();






---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Layouts
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

A Layout defines the structure for a user interface in your app such as in an activity. All elements in the layout are built using a hierarchy of View and ViewGroup object.
A View usually draws something the user can see and interact with.
Whereas a ViewGroup is an invisible that defines the layout structure for View and other ViewGroup object,

The View objects are usually called "widgets" and can be one of many subclasses, such as Button or TextView.
The ViewGroup objects are usually called "layouts" can be one of many types that provide a different layout structure, such as LinearLayout or ConstraintLayout .

You can declare a layout in two ways:
1) Declare UI elements in XML
2) Instantiate layout elements at runtime


Declaring your UI in XML allows you to separate the presentation of your app from the code that controls its behavior. Using XML files also makes it easy to provide different layouts for different screen sizes and orientations .

Using Android's XML vocabulary, you can quickly design UI layouts and the screen elements they contain, in the same way you create web pages in HTML 


Load XML Resources :-------------------------------
When you compile your app, each XML layout file is compiled into a View resource. You should load the layout resource from your app code, in your Activity.onCreate() callback implementation.

Do so by calling setContentView(), passing it the reference to your layout resource in the form of: R.layout.layout_file_name. For example, if your XML layout is saved as main_layout.xml,


public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.main_layout);
}

The onCreate() callback method in your Activity is called by the Android framework when your Activity is launched



==> Attributes 
Every View and ViewGroup support their own variety of XML attribute.
Some attributtes are specified to a view object but these attributes are also inherited by any View object that may extend this class.
Some are common to all View object because they are inherited from root View class.


ID :
Any View object may have an integer ID associate with it to uniquely identify the View within the tree. When the app is compiled this ID referenced as an integer but the ID is typically assigned in the layout XML file as a string in the id attributes.

android:id="@+id/my_button"
@ at the beginning of the string indicates that the XML parser should parse and expand the rest of the ID string and identify it as an ID resource.
+ means that this is a new resources that are offered by the Android framework

android:id="@android:id/empty"
this referencing an ID from the android.R resource class rather than the local resource class.




Layout Paramters :----------------------
XML layout attributes named layout_something define layout parameters for the View are appropriate for the ViewGroup in which it reside.
Every ViewGroup
class implement a nested class that extends ViewGroup.LayoutParams. This sybclass contains property type that define the size and position for each child view, as appropriate for the view group.


All view group include a width and height (layout_width and layout_height), and each view is required to define them. many layoutParams also include optional margin and borders.


=> Layout Position
The geometry of a view is that of a rectangle. A view has a location expressed as a pair of left and top coordinates, and two dimensios, expresses as a width  and height.
It is possible to reterive the location of a view by invoking the method getLeft() and getTop().the for mer return the left orX coordinates of the rectangle representing the view.
				whenn getLeft() return 20 that means the view is located 20 pixels to the right of the left edge of its direct parent.


=> Common Layout
Each subclass of the ViewGroup class provides unique way to display the views you nest within it. Below are some of the more common layout types that are build into the Android platform.

{ Although you can nest one or more layout within another layout to achieve your UI design}


=> Building layouts with an Adapter :
When the content for your layout is dynamic or not pre-determined you can use a layout that subclasses AdapterView to populate the layout with views at runtime.
		A subclass of the AdapterView class uses an Adapter to bind data to its layout. The Adapter behaves as a middleman between the data resource and the AdapterView layout the Adapter reterives the data ( from a source such as an array or a database query) and converts each entry into a view that can be added into the AdapterView layout.

1) List View
2) Grid Layout

Filling an dapter view with data :-
you can populate an Adapterview such as ListView or GridView by  binding the AdapterView instance to an Adapter which reterives data from an external source and creates a View that represents each data entry.

using ArrayAdapter when your data source is an array . By default ArrayAdapter creates a view for each array item by calling toString() on each item and placing the contents in a TextView.

For example, if you have an array of strings you want to display in a ListView, initialize a new ArrayAdapter using a constructor to specify the layout for each string and the string array:

ArrayAdapter<String> adapter = new ArrayAdapter<String>(this,
        android.R.layout.simple_list_item_1, myStringArray);

The arguments for this constructor are:

Your app Context
The layout that contains a TextView for each string in the array
The string array


Then simply call setAdapter() on your ListView:

ListView listView = (ListView) findViewById(R.id.listview);
listView.setAdapter(adapter);



Handling Click Evernts :------------------------
You can  respond to click events on each iems in an AdatperView by implementing the AdapterView.OnClickListener interface.

// Create a message handling object as an anonymous class.
private OnItemClickListener messageClickedHandler = new OnItemClickListener() {
    public void onItemClick(AdapterView parent, View v, int position, long id) {
        // Do something in response to the click
    }
};

listView.setOnItemClickListener(messageClickedHandler);




-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
TextInputLayout
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
One of the basic UI widget in Android is an EditText. It is generally used to takes input from user while typing in EditText, it hides the hint which may create problems to identify EditText without label. Now a new concept of floating labels EditText cocept of floating labels was introduced.
This new Android floating label EditText concept initially showed a label as hint  when user enters a value in the Edittext that hint moves on to the top of the EditText as a floating label.

How to implement the new Android floating action EditText use the new Android TextInputLayout around the EditText.


What is the TextInputLayout ?

A TextInputlayout widget behaves exactly as a LinearLayout it's just a wrapper. TextInputLayout only accepts one child element similar to a ScrollView. The child element needs to be  an EditText Element.
When TextInputLayout is used around an EditText is automatically takes  the hint text defined in the EditText and shows it as a floating label.
Another feature we can also set an error message to Edittext by using setErrorEnable(boolean) and setError(Char Sequence) methods.


passord visibility toggling is also supportted via the setPasswordVisibilityToggleEnabled(boolean) API and related attribute.If enabled a button is displayed to toggle between the password being displayed as plain-text or distiguised when your Edittext is set to display a passord.


TextInputLayout takes the value of android:hint assigned to EditText and displays it as floating label. 

The TextInputEditText class is provided to be used as a child of this layout.Using TextInputEditText allows TextInputLayout greater control over the visual aspect of any text input. An example uasge is as so:

	 <android.support.design.widget.TextInputLayout
         		android:layout_width="match_parent"
         		android:layout_height="wrap_content">

     		<android.support.design.widget.TextInputEditText
             		android:layout_width="match_parent"
             		android:layout_height="wrap_content"
             		android:hint="@string/form_username"/>

 	</android.support.design.widget.TextInputLayout>



Summary XML Attributes :---------
TextInputLayout_android_hint
TextInputLayout_counterEnabled
TextInputLayout_counterMaxLength
TextInputLayout_errorEnabled
TextInputLayout_errorTextAppearence
TextInputLayout_hintAnimationEnabled
TextInputLayout_hintEnabled
TextInputLayout_hintTextAppearance
TextInputLayout_passwordToggleContentDescription
TextInputLayout_passwordToggleDrawable




-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Splash Screen
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Splash Screen ismost commonly the first startup screen which appears when App is opened words.
Splash screen is used to display logo, text in a simple constant screen for a fixed amount of time.

Normally it shows when app is first time launched on Android device or it may be some kind of process that is used to show screen to user just before the app loads completely.

We can implement the splash screen two different scenario
1) Splash screen using Handler
2) Splash screen creation using layout file.



1) For Splash Screen we will create a separate splash activity. Create a new class in your java package and name it as SplashActivity.java
In this Handler used to hold the screen for specific time and once the handler is out . our main activity will be launched. We are going to hold the screen for three second.

1 second=1000 milliseconds

Post Delayed method will delay the time for 3 second. After the delay time is completed then your main activity will be launched.

Exampl=>

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.os.Handler;

/**
 * Created by AbhiAndroid
 */

public class SplashActivity extends Activity {

    Handler handler;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.splashfile);

        handler=new Handler();
        handler.postDelayed(new Runnable() {
            @Override
            public void run() {
                Intent intent=new Intent(SplashActivity.this,MainActivity.class);
                startActivity(intent);
                finish();
            }
        },3000);

    }
}


Now we will have to change the AndroidManifest.xml for showing the splash screen as the application launched first.


<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
package="com.example.splashscreen">

<application
    android:allowBackup="true"
    android:icon="@drawable/abhiandroid"
    android:label="@string/app_name"
    android:supportsRtl="true"
    android:theme="@style/AppTheme">

    <activity android:name="com.example.splashscreen.SplashActivity">	//this gonna show the spalsh activity first
        <intent-filter>
            <action android:name="android.intent.action.MAIN" />

            <category android:name="android.intent.category.LAUNCHER" />
        </intent-filter>
    </activity>

    <activity android:name="abhiandroid.com.splashscreen.MainActivity"/>	//after the splash screen the mainactivty will show
</application>

</manifest>


	Android AlertDialogBox Example :----------------------------

Android Alert DialogBox can be used to display the Dialog message with OK and Cancel button. It can be used to interuppt and ask the user about his\her chioce to continue of discontinue.

Methods of AlterBox class :--------------------------

1) public AlertDialog.Builder setTitle(Char sequence)	this method is used to set the title of AlertDialogBox

2) public AlertDialog.Builder setMessage(Char Sequence)	this is used to set the message for AlertDialogBox

3) public AlertDialog.Builder setIcon(int)			this method is used to set the icon over AlertDialogBox




Android Spinner Example :-----------------------------------
Android Spinner is like the combo box of AWT or Swing .It can se used to display the multiple option to the user in which one item can be selected by the user.

Android spinner is like the drop down menu with multiple values from which the end user can select only one value.
Android spinner is associate with AdapterView . So you need to use one of the adapter classes with spinner.

Android spinner class is subclass of Asdspinner class.

	Andorid Spinner Example :-------------------------

In this example we are going to display the country list. you need to use ArrayAdapter class to store the country list.




 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  
						Android Fragment
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  

	Fragments :- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

A Fragment represents a behavior or a portion of user interface in a FragmentActivity. You can combine multiple fragments in a single activity to build a multi-pane UI and reuse a fragment in multiple activities.
				You can think of a fragment as a modular section of an activity, which has its own lifecycle, receives its own input events, and which you can add or remove while the activity is running.

A fragment must always be hosted in an activity and the fragment's lifecycle is directly affected by the host activity's lifecycle. 

A fragment must always be hosted in an activity and the fragment's lifecycle is directly affected by the host activity's lifecycle. For example, when the activity is paused, so are all fragments in it, and when the activity is destroyed, so are all fragments. 

When you add a fragment as a part of your activity layout, it lives in a ViewGroup inside the activity's view hiserarchy and the fragment defines its own view layout. You can insert a fragment into your activity layout by declaring the fragment in the activity's layout file, as a <fragment> element, or from your application code by adding it to an existing ViewGroup.


A Fragment is a piece of an activity which enable more modular activity design.It will not be wrong if we say a fragment is a kind of sub-activity.

Following are important points about Fragment :-

=> A fragment has its own layout and its own behaviour with its own life cycle callbacks.
=> you can add or remove fragment in an activty while the activity is running
=> you can combine multiple activity in a single activity to build a multi-pane UI
=> A fragment can be used in multiple activitties
=> Fragment life cycle is closely related to life cycle of its host activity which means when the activity is paused all the fragments available in the activity will also be stopped.

=> Fragment were added to the Android API in Honeycomb.



	Creating a Fragment :-----

To create a fragment you must create subclass of Fragment (or an eisting subclass of it).
The Fragment class has code that looks a lot like an activity.


It contains callback methods similar to an activity such as 

Here is the list of methods which you can to override in your fragment class -

onAttach()The fragment instance is associated with an activity instance.The fragment and the activity is not fully initialized. Typically you get in this method a reference to the activity which uses the fragment for further initialization work.

onCreate() The system calls this method when creating the fragment. You should initialize essential components of the fragment that you want to retain when the fragment is paused or stopped, then resumed.

onCreateView() The system calls this callback when it's time for the fragment to draw its user interface for the first time. To draw a UI for your fragment, you must return a View component from this method that is the root of your fragment's layout. You can return null if the fragment does not provide a UI.

onActivityCreated()The onActivityCreated() is called after the onCreateView() method when the host activity is created. Activity and fragment instance have been created as well as the view hierarchy of the activity. At this point, view can be accessed with the findViewById() method. example. In this method you can instantiate objects which require a Context object

onStart()The onStart() method is called once the fragment gets visible.

onResume()Fragment becomes active.

onPause() The system calls this method as the first indication that the user is leaving the fragment. This is usually where you should commit any changes that should be persisted beyond the current user session.

onStop()Fragment going to be stopped by calling onStop()

onDestroyView()Fragment view will destroy after call this method

onDestroy()onDestroy() called to do final clean up of the fragment's state but Not guaranteed to be called by the Android platform.




=> How to use Fragments?

This involves number of simple steps to create Fragments.

First of all decide how many fragments you want to use in an activity. For example let's we want to use two fragments to handle landscape and portrait modes of the device.

Next based on number of fragments, create classes which will extend the Fragment class. The Fragment class has above mentioned callback functions. You can override any of the functions based on your requirements.

Corresponding to each fragment, you will need to create layout files in XML file. These files will have layout for the defined fragments.

Finally modify activity file to define the actual logic of replacing fragments based on your requirement.


=> Types of Fragments

Basically fragments are divided as three stages as shown below.

1) Single frame fragments - Single frame fragments are using for hand hold devices like mobiles, here we can show only one fragment as a view.

2) List fragments - fragments having special list view is called as list fragment

3) Fragments transaction - Using with fragment transaction. we can move one fragment to another fragment.





A Fragment is a piece of an activity which enable more modular activity design.
It will not be wrong if we say a fragment is a kind of sub-activity.
A fragment represent a behavior or a portion if user interface in a FragmentActivity.


Important Points of Fragment :-----------------------------------------

=> you can combine multiple fragments in a single activity to build a multi-pane UI.
=> Fragment has its own life-cycle
=> Fragment has its own input events and which you can add or remove while the activity is running.
=> Fragment must always be hosted in an activity
=> Fragment's life-cycle is directly affected by the host activity's lifecycle.
	When an activity is paused so are all fragments in it and when the activity is destroyed so are all fragments.
=> While activity is running you can manipulate each fragment independently such as add or remove them.When you perform such a fragment transaction
	you can also add it to a back stack that's managed by the activity--each back stack entry in the activity is a record of the fragment transaction that occured.


=> When you add a fragment as a part of your activity layout, it lives in a ViewGroup inside the activity's view hierarchy and the fragment defines its own view layout. You can insert a fragment into your activity layout by declaring the fragment in the activity's layout file, as a <fragment> element, or from your application code by adding it to an existing ViewGroup.

=> Design Philosophy
Android introduced fragments in Android 3.0 (API level 11), primarily to support more dynamic and flexible UI designs on large screens, such as tablets. Because a tablet's screen is much larger than that of a handset, there's more room to combine and interchange UI components. 



=>Creating a Fragment Life cycle of Fragment :-

To create a fragment you must create a subclass of Fragment (or an existing subclass of it ). The Fragment class has code that looks a lot like an 
activity.

Here is the list of methods which you can to overide in your fragment class --

1) onAttach()
The fragment instance is associate with an activity instance.The fragment and the activity is not fully initialized.

2) onCreate() 
The system calls this method when creating the fragment. you should initialize essential component of the fragment that you want to retain when the fragment is paused or stopped then resumed.

3) onCreateview()
The system calls this callback when it's time for the fragment to draw the user interface for the frist time.
To draw a UI for your fragment you must return a View component from this method that is the root of your fragment's layout.

4) onActivityCreated()
The onActivityCreated() is called after onCreateView() method when the host activity is created

5) onStart()
The onStart() method is called once the fragment gets visible

6) onResume()
The fragment become active

7) onpause()
the system calls this method as the first indication that the user is leabing the fragment

8) onStop() 
Fragment going to be stopped by calling onStop()

9)onDestroyView()
Fragment view will destroy after call this method

10) onDestroy()
onDestroy() called to do final clean up of the fragment's state but Not guaranteed to be called by the Android platform.


It contains callback methods similar to an activity such as onCreate(), onStart(), onPause() and onStop().


=> Adding a user Interface :---------------------------------------
A fragment is usually used as part of an activity's user interface and contributes its layout to the activity.
To provide a layout for a fragment you must implement the onCreateview() callback method which the Android system calls when it's time for the fragment to draw its layout. Your implementation of this method must return a View that is the root of your fragment's layout.


=> to return a layout from onCreateview() you can inflate it from a layout resource defined in XML.to help you do so onCreateView() provides a layoutInflater object.


public static class ExampleFragment extends Fragment
{
	@Override
	public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle saveInstanceState)
	{
		return inflater.inflate(R.layout.exaple_fragment,container,false)
	}
}

container parameter passed to onCreateView() is the parent ViewGroup in which your fragment layout is inserted.
saveInstanceState parameter is a Bundle that provide data about the previous instance of the fragment.

=> infalte() method (means it read the XML file which describe a layout and to create the some objects of it).
Here it takes three arguments:
1) resource ID of the layout you want to inflate
2) viewgroup to be the parent of the inflate layout.
3) boolan indicating whether the infalted layout should be attached to the ViewGroup (the second parameter) during inflation ( in this case this false because the systemm inserting the inflated layout into the container--passing true would create a redundant view group in the final layout)


=> Adding a fragment to an activity
Usually a fragment contribute a portion of UI to the host activty which is embedded as a part of the activity overall view hierarchy.
There are two ways you can add a fragment to the activity layout:


1) Declared the fragment inside the activity's layout file.

In this case you can specify layout properties for the fagment as if it were a view.For example here's the layout file for an activity with two fragments:

=>Steps for creating the Fragment statically

1) create another layout xml file for Fragment
2) create Fragment (by extending class of fragment)
3) set the layout xml file to fragment
4) use fragment tag to include fragment in xml layout




<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <fragment android:name="com.example.news.ArticleListFragment"
            android:id="@+id/list"
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="match_parent" />
    <fragment android:name="com.example.news.ArticleReaderFragment"
            android:id="@+id/viewer"
            android:layout_weight="2"
            android:layout_width="0dp"
            android:layout_height="match_parent" />
</LinearLayout>

The android:name attribute in the <fragment> specifies the Fragment class to instantiate in the layout.



2)
Programmatically add the fragment to an existing ViewGroup.
At any time while your activity is running, you can add fragments to your activity layout.

<//
FragmentManager fragmentManager = getSupportFragmentManager();
FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();
//>


To make fragment transactions in your activity (such as add, remove, or replace a fragment), you must use APIs from FragmentTransaction.

<//

ExampleFragment fragment = new ExampleFragment();
fragmentTransaction.add(R.id.fragment_container, fragment);
fragmentTransaction.commit();

//>

The first argument passed to add() is the ViewGroup in which the fragment should be placed, specified by resource ID, and the second parameter is the fragment to add.

Once you've made your changes with FragmentTransaction, you must call commit() for the changes to take effect.


=> Managing Fragments :----
To manage the fragment in your activity you need to use FragmentManager.
to get it call getSupportFragmentManager() from your activity.

Some things that you can do with FragmentManager include:

Get fragments that exist in the activity, with findFragmentById() (for fragments that provide a UI in the activity layout) or findFragmentByTag() (for fragments that do or don't provide a UI).
Pop fragments off the back stack, with popBackStack() (simulating a Back command by the user).
Register a listener for changes to the back stack, with addOnBackStackChangedListener().

Before you call commit(), however, you might want to call addToBackStack(), in order to add the transaction to a back stack of fragment transactions. This back stack is managed by the activity and allows the user to return to the previous fragment state, by pressing the Back button.

=> Communicating with the Activity

Although a Fragment is implemented as an object that's independent from a FragmentActivity and can be used inside multiple activities, a given instance of a fragment is directly tied to the activity that hosts it.

Specifically, the fragment can access the FragmentActivity instance with getActivity() and easily perform tasks such as find a view in the activity layout:

View listview = getActivity().findViewById(R.id.list);

Likewise your activity can call methods in the fragment by acquiring a reference to the Fragment from FragmentManager using findFragmentById() or findFragmentByTag(). For example

ExampleFragment fragment = (ExampleFragment)getSupportFragmentMnager().findFragmentById(R.id.example_fragment);


















 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  
					                 Android ManifestFile
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

Every app project must have an Androidmanifest.xml file (with precisely that name) at the root of the project source set. The manifest file describe essential information about your app to the Android build tools

Among many other things the manifest file is required to declare the following :-

1) The app's package name which usually matches your code's namespace. The Android build tools use this to determine the location of code entities when building your project. When packaging the app the build tools replace this value with the application ID from Gradle build files, which is used as the unique app identifier on the system.

Package name and application ID :-
The manifest file's root element requires an attribute for your app's package name.
For example the following snippet shows the root <manifest> element with the package name "com.example.myapp"

<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.myapp"
    android:versionCode="1"
    android:versionName="1.0" >
    ...
</manifest>

while building your app into the final application package (APK) the Android build tools use the package attribute for two things
1) It applies this name as the namespace for your app's generated R.java class (used to access your app resources).


Example with the above manifest the R class is created at com.example.myapp.R

R.java is generated file by ADT or Android Studio. It will be located under app\build\generated\source\r directory



	Compiling :--------------------
This is where we will dig deeper When we run our code from the editor following process takes palce.

1) java compiling Packaging
Android java code files compiles to .class files view javac command

2) .class fiels gets converted to .dex
.class files is also known as java byte-code this byte code further get converted to ( delvik byte-codes ) which is the format which android OS understands here all .class fiels and any .jar library files compiles to single classes .dex using dx command. DEX is called executable files.

DEX files is memory efficient and loads very swiftly compared to JVM based .class files and is lightweight too.

3) Packaging (.APK file)

Packaging is done using android apkbuilder rool (APPT).It generated a .apk file from a DEX file + non-java libraries + zipped resources. The classes.dex file resource files are compressed by aapt (Android Asset Packaging Tool) This.apk file is what you run on android device and is distributed to all the major app stored after beign singned for release. User gets to download this files from Google Play Store and other app stored on their android powered device.





	App components in manifest file:--------------------------

For each app component that you create in your app you must declare a corresponding XML element in the manifest file:

<activity> for each subclass of Activity.
<service> for each subclass of Service
<receiver> for each subclass of BroadcastReceiver
<provider> for each subclass of Content provider

if you subclass any of these components without declaring it in the manifest file the system cannot start it.

The name of your subclass must be specified with the name attribute using the full packaging designation. an Activity subclass can be declared as follows:

<manifest ... >
    <application ... >
        <activity android:name="com.example.myapp.MainActivity" ... >
        </activity>
    </application>
</manifest>


However, if the first character in the name value is a period, the app's package name (from the <manifest> element's package attribute) is prefixed to the name. For example, the following activity name is resolved to `"com.example.myapp.MainActivity"`:

<manifest package="com.example.myapp" ... >
    <application ... >
        <activity android:name=".MainActivity" ... >
            ...
        </activity>
    </application>
</manifest>

If you have app components that reside in sub-packages (such as in com.example.myapp.purchases), the name value must add the missing sub-package names (such as ".purchases.PayActivity") or use the fully-qualified package name.


=> Intent filters
App activities, services, and broadcast receivers are activated by intents.
An intent is a message defined by an Intent object that describes an action to perform, including the data to be acted upon, the category of component that should perform the action, and other instructions.



=> Icons and labels
A number of manifest elements have icon and label attributes for displaying a small icon and a text label, respectively, to users for the corresponding app component.

=> Permissions
Android apps must request permission to access sensitive user data (such as contacts and SMS) or certain system features (such as the camera and internet access). Each permission is identified by a unique label. For example, an app that needs to send SMS messages must have the following line in the manifest:

<manifest ... >
    <uses-permission android:name="android.permission.SEND_SMS"/>
    ...
</manifest>



=> Device compatibility
The manifest file is also where you can declare what types of hardware or software features your app requires, and thus, which types of devices your app is compatible with. Google Play Store does not allow your app to be installed on devices that don't provide the features or system version that your app requires.

<uses-feature>
The <uses-feature> element allows you to declare hardware and software features your app needs. For example, if your app cannot achieve basic functionality on a device without a compass sensor, you can declare the compass sensor as required with the following manifest tag:

<manifest ... >
    <uses-feature android:name="android.hardware.sensor.compass"
                  android:required="true" />
    ...
</manifest>


<uses-sdk>
Each successive platform version often adds new APIs not available in the previous version. To indicate the minimum version with which your app is compatible, your manifest must include the <uses-sdk> tag and its minSdkVersion attribute.

However, beware that attributes in the <uses-sdk> element are overridden by corresponding properties in the build.gradle file. So if you're using Android Studio, you must specify the minSdkVersion and targetSdkVersion values there instead:

android {
  defaultConfig {
    applicationId 'com.example.myapp'

    // Defines the minimum API level required to run the app.
    minSdkVersion 15

    // Specifies the API level used to test the app.
    targetSdkVersion 28

    ...
  }





Before the Android system can start an app component , start system must know that the component exist by reading the app's manifest file AndroidManifest.xml.
Your app must declare all its component  in this file which must be at the root of the app project directory.

The Manifest does a number of thing in addition to declaring the app's components such as the following:-
=> Identifies any user permission the app requires such  as internet access or read-access to the user's contacts.
=> Declaring the minimum level API Level required by the app based on which APIs the app uses.
=> Declares hardware and software feature sued or required by the app such as a camera, bluetooth service or a multitouch screen.
=> Declares API libraries the app needs to be linked againest 

<?xml version="1.0" encoding="utf-8"?>
<manifest ... >
    <application android:icon="@drawable/app_icon.png" ... >
        <activity android:name="com.example.project.ExampleActivity"
                  android:label="@string/example_label" ... >
        </activity>
        ...
    </application>
</manifest>

In the <application> element, the android:icon attribute points to resources for an icon that identifies the app.

In the <activity> element, the android:name attribute specifies the fully qualified class name of the Activity subclass and the android:label attribute specifies a string to use as the 
user-visible label for the activity.


You must declare all app components using the following elements:

<activity> elements for activities.
<service> elements for services.
<receiver> elements for broadcast receivers.
<provider> elements for content providers.
Activities, services, and content providers that you include in your source but do not declare in the manifest are not visible to the system and, consequently, can never run. 
However, broadcast receivers can be either declared in the manifest or created dynamically in code as BroadcastReceiver objects and registered with the system by calling 
registerReceiver().


	Declaring component capabilities :----------------------------
	
As discussed above, in Activating components, you can use an Intent to start activities, services, and broadcast receivers. You can use an Intent by explicitly naming the target component
(using the component class name) in the intent. You can also use an implicit intent, which describes the type of action to perform and, optionally, the data upon which youd like to perform 
the action. 

The system identifies the components that can respond to an intent by comparing the intent received to the intent filters provided in the manifest file of other apps on the device.


Once you externalize your app resource you can access them using resources IDs that are generated in your project's R class. This document shows you how to group your resources in your Android project and provide alternative resources for specific device configurations and then access them from your app code or other XML files.




<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.broadcastreceiver">

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        <activity
            android:name=".MainActivity"
		
            android:screenOrientation="sensorLandscape">	// android:screenOrientation="sensorLandscape" is used for screen oritation of app
						   sensorLandscape is used for only landscape either in left or right
						// portrait is only used for horizontal
						// fullSensor means rotate in any direction with respect to sensor
						// landscape that will only be in one direction that is landscape
						// fullUser & sensor

            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <receiver
            android:name=".MyReceiver"
            android:enabled="true"
            android:exported="true">

            <intent-filter>
                <action android:name="alihasan"></action>
            </intent-filter>
        </receiver>

    </application>

</manifest>









 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  
					              Android ActivityLife-Cycle
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
As a user navigates through out of and back to your app the Activity instances in your app transition through different states in their lifecycle. The Activity class provides a number of callbacks that allow the activity to know that a state has changed: that the system is creating , stopping, or resuming an activity or destroying the process in which the activity resides.
	within the lifecycle callback method you can declare how your activity behaves when the user leaves and re-enters the activity.

A good implementation of the activity callback can help ensure that your app avoids:
1) Crashing if the user receives a phone call or switches to another app while using your app.
2) Consuming valuable system resources when the user is not actively using it.
3) Losing the user's progress if they leave your app and return to it at a later time.
4) Crashing or losing the user's progress when the screen rotates betwnn landscape and portrait orientation.


Activity-lifecycle concepts :--------------------------
To navigate transition between stages of the activity lifecycle, the Activity class provides a core set of six callbacks:
1) onCreate()
2) onStart()
3) onResume()
4) onPause()
5) onStop()
6) onDestroy()

Depensing on the complexity of your activity you probably don't need to implement all the lifecycle method. However, it's important that you understand each one and implement those that ensure your app behaves the way users expect.

Some actions such as calling setContentView() belong in the activity lifecycle methods themselves. However the code implementing the actions of a dependent component should be placed in the component itself.


=> onCreate()
On activity creation the activity enters the Create state. In the onCreate() method you perform basic application startup logic that should happen only once for the entire life of activity.

The method receives the parameter saveInstanceState which is a Bundle object containing the activity's previously saved state.If the activity has never existed before the value of the Bundle object is null.

onCreate() method is called when activity gets memory in the OS. To use create state we need to override onCreate(Bundle saveInstanceState) method.

When the activity first call or launched then onCreate(Bundle savedInstanceState) method is responsible to create the activity.



=> onStart()
onStart() method is called just afer it's creation. In other case Activity can also be calling rstart method after activity stop.So this means onStart() gets called by Android OS.when  user switch between applications.
If a user was using Application A and then a notification comes and user clicked on notification and moved to Application B in this case Application A will paused. And again if a user click on app icon of Application A then Application A which was stopped will again gets started.


=> onResumed()
Activity resumed is that situation when it is actually visible to user means the data displayed in the activity is visible to user. In lifecycle it always gets called after activity start and in most use case after activity paused (onPause).


=> onPaused()
Activity is called paused when it's content is not visible to user, in most case onPause9) method called by Android OS when user press Home button (center Button on Device) to make hide.
Activity also gets paused before stop called in case user press the back navigation button. The activity will go in paused state for these reasons also if a notification or some other dialog is overlaying any part (top or bottom) of the activity (screen). Similarly, if the other screen or dialog is transparent then user can see the screen but cannot interact with it. For example, if a call or notification comes in, the user will get the opportunity to take the call or ignore it.

=> Activity Stopped: onStop():

Activity is called stopped when its not visible to user. Any activity gets stopped in case some other activity takes place of it. For example, if a user was on screen 1 and click on some button and moves to screen 2. In this case Activity displaying content for screen 1 will be stopped.

Every activity gets stopped before destroy in case of when user press back navigation button. So Activity will be in stopped state when hidden or replaced by other activities that have been launched or switched by user. In this case application will not present anything useful to the user directly as its going to stop.

=> Activity onRestart()
Activity is called in restart state after stop state. So activitys onRestart() function gets called when user comes on screen or resume the activity which was stopped. In other words, when Operating System starts the activity for the first time onRestart() never gets called. It gets called only in case when activity is resumes after stopped state.

=> Activity Destroyed: onDestroy():

Any activity is known as in destroyed state when its not in background. There can different cases at what time activity get destroyed.

First is if user pressed the back navigation button then activity will be destroyed after completing the lifecycle of pause and stop.

In case if user press the home button and app moves to background. User is not using it no more and its being shown in recent apps list. So in this case if system required resources need to use somewhere else then OS can destroy the Activity.

After the Activity is destroyed if user again click the app icon, in this case activity will be recreated and follow the same lifecycle again. Another use case is with Splash Screens if there is call to finish() method from onCreate() of an activity then OS can directly call onDestroy() with calling onPause() and onStop().




















	App resources Overview :--------------------------------

Resources are the additional files and static content that your code uses such as bitmap, layout definitions, user interfaces string, animation instruction and more.
You should always externalize app resources such as image and string from your code so that you can maintain them independently. you should also provide alternative resources for specific 
device configurations by grouping them in specially-named resources directories. At runtime android uses the appropriate resource based on the current configuration.



	Grouping resource types :- - - - - - - - - - - - - - -

You should place each type of resource in a specific subdirectory of your project's res/directory.

As you can see in this example, the res/ directory contains all the resources (in subdirectories): an image resource, two layout resources, mipmap/ directories for launcher icons, and a string resource file. 

 

animator / 	XML files that define property animations
anim/		XML file that define tween animation
color/		XML file that define as state list of color
drawable/		Bitmap files (.png, .9.png, .jpg, .gif) or XML files that are compiled into the following drawable resource subtypes
mipmap/		Drawable files for different launcher icon densities
layout/		XML files that define a user interface layout
menu/		XML files that define app menus such as Options Menu or Sub Menu
raw/		Arbitrary files to save in their raw form.
values/		XML files that contain simple values, such as string integers and colors.

These resources that you save in the subdirectories defined in table 1 are your default resources. That is these resources define the default design and content for your app.


	Providing Alternative Resources :----------------------------

However different types of Android-powered devices might call for different types of resource.For example if a device has a larger than normal screen then you should provide different layout resource that take advantage of the extra screen space.

Almost every app should provide alternative resource to support device configuration. For instance you should include alternative drawable resources for different screen densities and alternatives string resources for different languages.


To specify configuration-specific alternatives for a set of resources:

Create a new directory in res/ named in the form <resources_name>-<config_qualifier>.

<resources_name> is the directory name of the corresponding default resources (defined in table 1).
<qualifier> is a name that specifies an individual configuration for which these resources are to be used (defined in table 2).
You can append more than one <qualifier>. Separate each one with a dash.
Save the respective alternative resources in this new directory. The resource files must be named exactly the same as the default resource files.


The hdpi qualifier indicates that the resources in that directory are for devices with a high-density screen. The images in each of these drawable directories are sized for a specific screen density, but the filenames are exactly the same. This way, the resource ID that you use to reference the icon.png or background.png image is always the same, but Android selects the version of each resource that best matches the current device, by comparing the device configuration information with the qualifiers in the resource directory name.




	String and other simple values :-----

To create an alias to an existing string simply use the resource ID of the desired string as the value for the new string

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="hello">Hello</string>
    <string name="hi">@string/hello</string>
</resources>


The R.string.hi resource is now an alias for the R.string.hello
Other simple values work the same way.

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="red">#f00</color>
    <color name="highlight">@color/red</color>
</resources>


	Drawable :---

To create an alias to an existing drawable use the <drawable> element:

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="red">#f00</color>
    <color name="highlight">@color/red</color>
</resources>

If you save this file as drawable.xml (in an alterative resource directory such as res/value-en-rCA/ ), it is compiled into a resource that you can reference as R.drawable.icon, but is actually an alias for the R.drawable.icon_ca resource (which is saved in res/drawable/).




	Accessing your app resources :-------------------------

Once you provide a resource in your application, you can apply it by referencing its resource ID. All resource IDs are defined in your project's R class, which the aapt tool automatically generates.


AAPT2 :------
AAPT2 (Adroid Assest Packaging Tool) is a build tool that Android Studio and Android Gradle Plugin use to compile and package your app's resurces. AAPT2 parse indexes and compiles the resources into binary format that is optimized for the Android platform.

	Android Gradle plugin 3.0.0 and higher enable AAPT2 by default and you typically won't need to invoke AAPT2 yourself. However if you prefer to use your terminal and your own build system over Android Studio you can use AAPT2 from command line. 


When your application is compiled, aapt generates the R class, which contains resource IDs for all the resources in your res/ directory. For each type of resource, there is an R subclass (for example, R.drawable for all drawable resources), and for each resource of that type, there is a static integer (for example, R.drawable.icon). This integer is the resource ID that you can use to retrieve your resource.


There are two ways you can access a resource :

1) In code : using a static integer from a sub-class of your R class such as
R.string.hello

where string is the resource type and hello is the resource name


2) In XML : Using a special XML syntax that also corresponding to the resource ID defined in your R class such as.
@string/hello

where string is the resource type and hello is the resource name.


  Accessing resource in Code :-------

You can use a resource in code by passing the resource ID as a method parameter

ImageView imageView = (ImageView) findViewById(R.id.myimageview);
imageView.setImageResource(R.drawable.myimage);

you can also reterive individual resources using methods in Resources which you can  get an instance of with getResources().

Here are some examples of accessing resources in code .


// Load a background for the current screen from a drawable resource
getWindow().setBackgroundDrawableResource(R.drawable.my_background_image) ;

// Set the Activity title by getting a string from the Resources object, because
//  this method requires a CharSequence rather than a resource ID
getWindow().setTitle(getResources().getText(R.string.main_title));

// Load a custom layout for the current screen
setContentView(R.layout.main_screen);

// Set a slide in animation by getting an Animation from the Resources object
flipper.setInAnimation(AnimationUtils.loadAnimation(this,
        R.anim.hyperspace_in));

// Set the text on a TextView object using a resource ID
TextView msgTextView = (TextView) findViewById(R.id.msg);
msgTextView.setText(R.string.hello_message);




	Accessing resources from XML :-------------------------

you can define values for some XML attributes and element using a reference to an  existing resource.

If we add Button to your layout we should use a string resource for button text:

<Button
	android:layout_widget="fill_parent"
	android:layout_height="fill_parent"'
	android:text="@string/submit" />


Use Cases :------------------------
In some cases you must use a resource for a value in XML (for example to apply a drawable image to a widget image to a widget) but you can also use a resource in XML any place that accepts a simple value. For example if you have the following resource file that includes a color resource and a string resource

<?xml version="1.0" encoding="utf-8"?>
<resources>
	<color name="opaque_red">#f00</color>
	<string name="hello">Hello!</string>
<resources>


you can use these resource in the following layout file to set the text color and text string:

<?xml version="1.0" encoding="utf-8"?>
<EditText xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:textColor="@color/opaque_red"
    android:text="@string/hello" />


you can even use resources in XML to create aliases. For example you can create a drawable resource that is an alias for another drawable resource:

<?xml version="1.0" encoding="utf-8"?>
<bitmap xmlns:android="http://schemas.android.com/apk/res/android"
    android:src="@drawable/other_drawable" />




	Accessing platform resources :-------------------------
Android contains a number of standard resources such as styles, theme, and layouts. To access these resource qualify your resource reference with the android package name. For example provides a layout resource you can use got list items ina ListAdapter:


setListAdapter(new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, myarray));

In this example simple_list_item_1 is a layout resource defined by the platform for items in a ListView.


	Menus :------------------
Menus are a common user interfaces component in amny types of applications.To provides a familier and consistent user experiance.you should use the Menu APIs to present user actions and other options in your acitivities.

Beginning with Android 3.0 (API level 11), Android-powered devices are no longer required to provide a dedicated Menu button with this change Android apps should migrate away from a dependence on the traditional 6-item menu-panel and intead provide an app bar to present common user actions.

How to create the three fundamental types of menus or action presentations on all versions of Android :----------------

Options / Menu and  / App bar:-----------------

1) The Option menu is the primary collection of menu items for an activity. It's where you should place actions that have a global impact on the app such as Search Compose email and Setting.

To specify the option menu for an activivy overirde onCreateOptionMenu()  (fragments provide their own onCreateOptionMenu() callback). In this method you can inflate your menu resource (defined in XML) into the Menu provided in the callback.

@Overirde
public boolean onCreateOptionMenu(Menu menu)
{
	MenuInfalter infalter=getMenuInflater();
	inflater.infalte(R,menu.game)menu,menu);
	return true;
}

you cal also add items using add() and reterive items with findItem() to revise thier properties with menuitem APIs

Handling click events :----------------------------
When the user selects an items from the options menu(including action items in the app bar) the system calls your activity's onOptionItemSelected() method. This method passes the MenuItem selected. you can identify the item by calling getItemId() which returns the unique ID for the menu item. you can match this ID against known menu items to perform the appropriate action.

For Example:---
@Override
public boolean onOptionsItemSelected(MenuItem item) {
    // Handle item selection
    switch (item.getItemId()) {
        case R.id.new_game:
            newGame();
            return true;
        case R.id.help:
            showHelp();
            return true;
        default:
            return super.onOptionsItemSelected(item);
    }
}

When you successfully handle a menu item, return true. If you don't handle the menu item, you should call the superclass implementation of onOptionsItemSelected() (the default implementation returns false).



Context Menu and contextual action mode :-----------------------------

A context menu is a floating menu that appears when the user performs a long-click on an element.It provides actions that affect the selected content ot context frame.
The contextual action mode display action items that affect the selected content in a bar at the top of the screen and allows the user to select multiple items.

A contextual menu offers actions that affect a specific item or context frame in the UI. You can provide a context menu for any view, but they are most often used for items in a ListView, GridView, or other view collections in which the user can perform direct actions on each item

There are two ways to provide contextual actions:

1) In a floating context menu. A menu appears as a floating list of menu items (similar to a dialog) when the user performs a long-click (press and hold) on a view that declares support for a context menu. Users can perform a contextual action on one item at a time.

2) In the contextual action mode. This mode is a system implementation of ActionMode that displays a contextual action bar at the top of the screen with action items that affect the selected item(s). When this mode is active, users can perform an action on multiple items at once (if your app allows it).



	Activity: -----------------------------------
Generally one activity implements one screen in an app

Activity life cycle :----
1) onCreate()	// First callback and called when activity is first created
2) onStart()	// This callback is called when the activity become visible to user
3) onResume()	// this is called when user interacting with application
4) onPause()	// paused activity does not receive any input and cannot execute
5) onStop()	// this activity is called  when activity is not visible
6) onRestart()	// this callback is called when activity restart after stopping
7) onDestroy()	// this callback is called before activity is destroyed by the system

	onCreate() :--------------------

You must implement this callback, which fires when the system first creates the activity. On activity creation, the activity enters the Created state. In the onCreate() method, you perform basic application startup logic that should happen only once for the entire life of the activity. For example, your implementation of onCreate() might bind data to lists, associate the activity with a ViewModel, and instantiate some class-scope variables. This method receives the parameter savedInstanceState, which is a Bundle object containing the activity's previously saved state. If the activity has never existed before, the value of the Bundle object is null

The following example of the onCreate() method shows fundamental setup for the activity, such as declaring the user interface (defined in an XML layout file), defining member variables, and configuring some of the UI. In this example, the XML layout file is specified by passing files resource ID R.layout.main_activity to setContentView().





	Services Overview :------------------------
A serivce is an application that can perform long-running operations in the background and it doesn't provide a user interface. Another application component can start a service and it contines to run in the background even if the user switches to another application.

Additionally a component can bind to a service to inteact with it and even perform interprocess communication (IPC)

{ Interprocess communication (IPC) is a set of programming interfaces that allow a programmer to coordinates activities that can run concurrently in an opearating system. This allows a program to handle many user request at the same time. }


 
	Bound :--------------------------

A service is bound when an application component binds to it by calling bindService(). A bound service offers a client-server interface that allows components to interact with the service, send requests, receive results, and even do so across processes with interprocess communication (IPC). A bound service runs only as long as another application component is bound to it. Multiple components can bind to the service at once, but when all of them unbind, the service is destroyed.











-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
10:31 AM 9/3/2019		Android Intent
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
An Intent is a messaging object you can use to request an action from another app component. Although intents facilitate communication between components in several ways there are three fundamental use cases:-

=> Starting an activity :-
An Activity represents single screen in an app.You can start a new instance of an Activity by passing an Intent to startActivity(). The Intent describes the activity to start and carries any  necessary data.

	Intent new_intent=new Intent(Context context,NextActivity.class)
	new_intent.putExtra(name,value);
	startActivity(new_intent);



If you want to receive a result from the activity when it finishes call startActivityForResult(). your activity receives the result as a separate Intent object in your activity's onActivityResult() callback.


Here this is an example of of accessing camera and take a photo using startActivityFor Result(intent,CONSTANT);
static final int REQUEST_IMAGE_CAPTURE = 1;

private void dispatchTakePictureIntent() {
    Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
    if (takePictureIntent.resolveActivity(getPackageManager()) != null) {
        startActivityForResult(takePictureIntent, REQUEST_IMAGE_CAPTURE);
    }
}


=> Starting a service
you can start a service by  using  methods of the Service class. You can start a service to perform a one-time operation (such as downloading a file) by passing an Intent to startService().The Intent describes the service to start and carries any necessary data.


=> Delivering a broadcast
A broadcast is a message that any app can receive.The system delivers various broadcasts for system events, such as when the system boots up or  th device starts charging. you can deliver a broadcasr to other apps by passing an Intent to send Broadcast() or sendOrderedBroadcast().


Intent types :-----------------------
there are two types of Intents
1) Implicit Intent
2) Explicit Intent

Explicit Intent  specify which application will saticfy the intent by supplying either the target app's package name or fully-qualified component class name.You will typically use an explicit intent to start a component in your own app because you know the class name of the activity or service. to download file in the background.

Implicit intent do not name a specific component but instead declare a general action to perform which allows a component from another app to handle it. For example if you want to show the user a location on a map you can use an implicit intent to request that another capable app to show a specific location on a map.


When you use an implicit intent the Android system finds the appropriate component  to start by comparing the contents of the intent to the intent filter declared in the manifest file of other apps on the device. if the intent matches an intent filer the sytsem starts that component and deliver it the intent object.If multiple intent filters are compatible the system displays a dialog so the user can pick which app to use. 




Building an Intent :---------------------------------------

An  intent object carries information that the android system uses to determine which component to start (such as the exact component name or component category that should recevice the intent), plus information that the recipient component uses in order to properly perform the action( such as the action to take and the data to act upon).

The primary information contained in an Intent is the following:

=> Component name	( The name of the component to start)

=> Action (A string that specifies the generic action to perform (such as view or pick)).

1) ACTION_VIEW
use this action in an intent startActivity() when you have some information that an activity ca show to the user such as photo to view in a gallery app or an address to view in a map app.

2) ACTION_SEND
Also known as the share intent you should use this in an inten twith startActivity() when you have some data that the user can share through another app such as an email app or social sharing app.


=> Data

The URI ( a Uri object) that reference the data to be acted on and /or the MIME type of that data. The type od data supplied is generally dictated by the intent's action.For example if the action ACTION_EDIT the data should contain the URI of the document to edit.

When creating anintent it's often important to specify the type of data (its MIME type) in addition to its URI. 
To set only data URI call setData(). To set only the MIME type call setType() .If necessary you can set both explicitly with setDataAndType().


=> Category

A string containing additional information about the kind of component that should handle the intent. Any number of category description can be placed in an intent but most intent do not require a category.

CATEGORY_BROWSABLE
The target activity allows itself to be started by a web browser to display data referenced by a link such as an image or an e-mail message.

CATEGORY_LAUNCHER
The activity is the initial activity of a task and is listed in the system's application launcher.


=> Extras
Key-value pairs that carry additional information required to accomplish the requested action.Just as some actions use particular kinds of data URIs some actions also use particular extras.
You can add extra data with various putExtra() method each accepting two aprameter the ley name and the value.
You can also create Bundle object with all the extra data then insert the Bundle in the Intent with putExtras().

public class Intent extends Object implements Parcelable, Cloneable

Parcelable => Interface for classes whose instance can be written to and restored from a Parcel. Classes implementing the Parcelable interface must also have a non-null static field caled 
	       CREATOR of a type that implements the Parcelable.Creator interface
Parcel	 => Container for a message (data and object references) that can be sent through an IBinder.

Cloneable => A class implements the Cloneable interface to indicate to the Object.clone() method that it is legal for that method to make a field-for-field copy of instance of that class.
		creates and returns a copy of this object.


An Intent is an abstract description of an operation to be performed. It can be used with
Intents are asynchronus message which allow Android component to request functionality from other component of the Android System.

startActivity(Intent) 	=> to launched an Activity
broadcastIntent	=> to send it to any interested  BroadcastReceiver components
startService(Intent)	/ bindService(Intent, ServiceConnection, int)	=> to communicate with background.

Intent has been used to call another acitivity
Its most significant use  is in the launching of activites, where it can be throught of as the glue between activites.
It is basically a passive data structure holding an abstract description of an action to be performed.



Intent Structure :--------------
The primary pieces of information in an intent are :

1) Action	:- the general action to be performed such as  ACTION_VIEW,  ACTION_EDIT,  ACTION_MAIN

2) Data	:- the data to operate on such as a person records in the contact database, expressed as a Uri.

Some of the Example of action/data pair are: --------

1) ACTION_VIEW content://contacts/people1 => display information about the person whose identifier is 1
2) ACTION_DIAL tel:123	=> display the phone dialer with the given number filled in 


Inaddition to these primary attributes there are number of secondary attribute that you can also include with an intent:-

3) Category	:- gives additional information about the action to execute. For example CATEGORY_LAUNCHER means it should appear in the Launcher as a top-level application.

4) Type		:- specifies an explicity type (a MIME type) of the intent data

5) Component	:- specifies an explicit name of a component class to use for the intent >Normally this is determined by looking at the other information in the intent (action, data/type and categories)
		and matching that with a component that can handle

6) Extras		:- this is a Bundle of any additional information.this can be used to provide extended information to the component.
		For example if we have a action to send an e-mail message we could include extra pieces of data here to supply a subject body etc.


In Android the reuse of other application components is a concept knowns as task. An application can access other Android components to achieve a task.
For Example from a component of your application you can trigger another component in the Android system which manage photos, even it thif component is not part of your application. 
In this component you select a photo and return to your application to use the selected photo.


 => Here are some examples of other operations you can specify as intents using these additional parameters:

ACTION_MAIN with category CATEGORY_HOME -- Launch the home screen.

ACTION_GET_CONTENT with MIME type vnd.android.cursor.item/phone -- Display the list of people's phone numbers, allowing the user to browse through them and pick one and return it to the parent activity.


=> Example of the Explicit Intent
An explicit intent is one that you use to launched a specific app component such as a particular activity or service in your app.To cretae an explicit intent the component name for the Intent object all other intent properties are optional

Example=>
		// Executed in an Activity, so 'this' is the Context
		// The fileUrl is a string URL, such as "http://www.example.com/image.png"
		
		Intent downloadIntent = new Intent(this, DownloadService.class);
		downloadIntent.setData(Uri.parse(fileUrl));
		startService(downloadIntent);

Example implicit Imtemt =>

An implicit intent specifies an action that can invoke any app on the devce able to perform the action. Using an implicit intent is useful when your app cannot perform the action other apps probably can and you 's like the user to pick which app to use.

For example if you have content that you want the user to share with other people create intent with the ACTION_SEND action and add extras that specify the content to share.

// Create the text message with a string
Intent sendIntent = new Intent();
sendIntent.setAction(Intent.ACTION_SEND);
sendIntent.putExtra(Intent.EXTRA_TEXT, textMessage);
sendIntent.setType("text/plain");

// Verify that the intent will resolve to an activity
if (sendIntent.resolveActivity(getPackageManager()) != null) {
    startActivity(sendIntent);
}


// Create the text message with a string
Intent sendIntent = new Intent();
sendIntent.setAction(Intent.ACTION_SEND);
sendIntent.putExtra(Intent.EXTRA_TEXT, textMessage);
sendIntent.setType("text/plain");



To show the chooser, create an Intent using createChooser() and pass it to startActivity(), as shown in the following example. This example displays a dialog with a list of apps that respond to the intent passed to the createChooser() method and uses the supplied text as the dialog title.

Intent sendIntent = new Intent(Intent.ACTION_SEND);
...

// Always use string resources for UI text.
// This says something like "Share this photo with"
String title = getResources().getString(R.string.chooser_title);
// Create intent to show the chooser dialog
Intent chooser = Intent.createChooser(sendIntent, title);

// Verify the original intent will resolve to at least one activity
if (sendIntent.resolveActivity(getPackageManager()) != null) {
    startActivity(chooser);
}



=> Intent-filter :------------------

Intent Filter is an expression in app's manifest file (ActivityManifest.xml) and it is used to specify the type of intent that the component would like to receive. In case if we create Intent filter 
for an activity there is a possibility for other apps to start our activity by sending a certain type of intent.
											otherwise the activity can be started only by an explicit intent.




There are three intent characteristics you can filter on the action , data and categories. For each of these characteriscs you can provides multiple possible matching values (via addAction(String),
 addDataType(String), addDataScheme(String), addDataSchemeSpecificpart(String ,int), addDataAuthority(String,String), addDataPath(String,int) and addCategory(String), respectively)


Filter Rule :-----------
A match is based on the following rule.Note that for an IntentFilter to match an Intent three condition must hold the action and category must match and the data (both data type and data 
scheme+authority+path if specified) must match

=> Action matches if any of the given values match the Intent action; if the filter specifies no actions, then it will only match Intents that do not contain an action.

=> Data Type matches if any of the given values match the Intent type. The Intent type is determined by calling Intent#resolveType. A wildcard can be used for the MIME sub-type, in both 
the Intent and IntentFilter, so that the type "audio/*" will match "audio/mpeg", "audio/aiff", "audio/*", etc. Note that MIME type matching here is case sensitive, unlike formal RFC MIME
types! You should thus always use lower case letters for your MIME types.

=> Data Scheme matches if any of the given values match the Intent data's scheme. The Intent scheme is determined by calling Intent#getData and Uri.getScheme() on that URI.
Note that scheme matching here is case sensitive, unlike formal RFC schemes! You should thus always use lower case letters for your schemes.

=> Data Scheme matches if any of the given values match the Intent data's scheme. The Intent scheme is determined by calling Intent#getData and Uri.getScheme() on that URI.
 Note that scheme matching here is case sensitive, unlike formal RFC schemes! You should thus always use lower case letters for your schemes.





Generally the Intent Filter ( <intent-filter> ) whatever we define in manifest file can be nested in the corresponding app components and we can specify the type of intent to accept using these
three elements.

<Action>It define the name of an intent action to be accepted and it must be a literal string value of an action not the class contant.

<categories> it define the name of an intent category to be accepted and it must be the literal string value of an action not the class constant.

<data>
It defines the type of data to be accepted and by using one or more attributes we can specify various aspects of the data URI (scheme, host, port, path) and MIME type


Intent Filter in Manifest File 
Following is the code snippet of defining an activity with Intent Filter (<intent-filter>) in Android Manifest file (AndroidManifest.xml) like as shown below.

 

<activity android:name=".MainActivity">
    <intent-filter>
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.LAUNCHER" />
        <data android:mimeType="text/plain"/>
    </intent-filter>
</activity>

We can define a filter with multiple instances of <action>, <category> or <data> elements and we need to make sure that component can handle all the combinations of filter elements.



23:54 02-10-2019 ListView :----------------------------------------------------------------------------------


Display a vertically scrollable collection of views where each view is positioned immediately below the previous view in the list.

To display a list you can include a.ist in your layout  XML file
<ListView
      android:id="@+id/list_view"
      android:layout_width="match_parent"
      android:layout_height="match_parent" />

A list view is an adapter view that does not know the details such as type and content of view it contains. Instead list view request views on demand from a list adapter as needed such as to displaynew views as the user scrolls up or down.

In order to display items in the lilst call setAdapter(android.widget.ListAdapter) to associate an adapter with the list.









-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	ArrayAdapter :------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Use this Adapter when your data source is an array. By default ArrayAdapter creates a view for each array item by calling toString() on each item and placing the content in TextView.

For example if you have an array of strings you want to display in a ListView, initialize a new ArrayAdapter using a constructor to specify the layout for each string and the string array.


ArrayAdapter<String> adapter = new ArrayAdapter<String>(this,
        android.R.layout.simple_list_item_1, myStringArray);

The argument of this constructor are :

=> Your app Content
=> The Layout that contains a TextView for each string in the array
=> The String array

Then simple cann setAdapter() on your ListView

ListView listView = (ListView) findViewById(R.id.listview);
listView.setAdapter(adapter);

=> SimpleCursorAdapter
Use this dapter when your data comes froma Cursor. When using SimpleCursorAdapter you must specify a layout to use for each row in the Cursor and which columns in the Cursor should be inserted into which views of the layout.
		For eample if you want to create a list of people's names and phone numbers you can perform a query that return a Cursor containing a row for each person and columns for the name and numbers. You then create a string array specifying which columns from the Cursor you want in the layout for each result and an integer array specifying the corresponding views that each column should be placed:


String[] fromColumns = {ContactsContract.Data.DISPLAY_NAME,
                        ContactsContract.CommonDataKinds.Phone.NUMBER};
int[] toViews = {R.id.display_name, R.id.phone_number};


When you instantiate the SimpleCursorAdapter, pass the layout to use for each result, the Cursor containing the results, and these two arrays:

SimpleCursorAdapter adapter = new SimpleCursorAdapter(this,
        R.layout.person_name_and_number, cursor, fromColumns, toViews, 0);
ListView listView = getListView();
listView.setAdapter(adapter);


The SimpleCursorAdapter then creates a view for each row in the Cursor using the provided layout by inserting each fromColumns item into the corresponding toViews view.





10:11 AM 9/4/2019

Notification :--------------------------------------------------

A notification is a message that android display outside your app's UI to provide the user with remainders communication from other people or other timely information from your app.


Appearance on a Device :----------------------

 Notification appear to user in different locations and formats such as an icon in the status bar a more detailed entry in the notification drawer as a badge on the app's icon and on paired wearable automatically.

1) Staus bar notification drawer
When you issue a notification, it first appears as an icon in the status bar.
Users can swipe down on the status bar to open the notification drawer, where they can view more details and take actions with the notification.


2) Heads-up notification
Beginning with Android 5.0, notifications can briefly appear in a floating window called a heads-up notification. This behavior is normally for important notifications that the user should 
know about immediately, and it appears only if the device is unlocked.

The heads-up notification appears the moment your app issues the notification and it disappears after a moment, but remains visible in the notification drawer as usual.

Example conditions that might trigger heads-up notifications include the following:

The user's activity is in fullscreen mode (the app uses fullScreenIntent).
The notification has high priority and uses ringtones or vibrations on devices running Android 7.1 (API level 25) and lower.
The notification channel has high importance on devices running Android 8.0 (API level 26) and higher.


4) Lock screen

Beginning with Android 5.0, notifications can appear on the lock screen.
You can programmatically set the ( level of detail visible ) in notifications posted by your app on a secure lock screen, or even whether the notification will show on the lock screen at all.
Users can use the system settings to choose the level of details visible in lock screen notifications, including the option to disable all lock screen notifications. Starting with Android 8.0, 
users can choose to disable or enable lock screen notifications for each notification channel.

5) App icon badge
In supported launchers on devices running Android 8.0 (API level 26) and higher, app icons indicate new notifications with a colored "badge" (also known as a "notification dot") 
on the corresponding app launcher icon.

Users can long-press on an app icon to see the notifications for that app. Users can then dismiss or act on notifications from that menu, similar to the notification drawer.


6) Wear OS devices
If the user has a paired Wear OS device, all your notifications appear there automatically, including expandable detail and action buttons.

You can also enhance the experience by customizing some appearances for the notification on wearables and provide different actions, including suggested replies and voice input 
replies. For more information, see how to add wearable-specific features to your notification.


Notification anatomy :-------------------

The design of a notification is determined by system templatesyour app simply defines the contents for each portion of the template.


Notification actions
Although it's not required, every notification should open an appropriate app activity when tapped. In addition to this default notification action, you can add action buttons that complete
 an app-related task from the notification (often without opening an activity)

Expandable notification
By default, the notification's text content is truncated to fit on one line. If you want your notification to be longer, you can enable a larger text area that's expandable by applying an 
additional template


	Notification updates and groups :----------------------

To avoid bombarding your users with multiple or redundant notifications when you have additional updates, you should consider updating an existing notification rather than issuing a 
new one, or consider using the inbox-style notification to show conversation updates.

However, if it's necessary to deliver multiple notifications, you should consider grouping those separate notifications into a group (available on Android 7.0 and higher). 
A notification group allows you to collapse multiple notifications into just one post in the notification drawer, with a summary. The user can then expand the notification to 
reveal the details for each individual notification.



	Notification channels :------------------

Starting in Android 8.0 (API level 26), all notifications must be assigned to a channel or it will not appear. By categorizing notifications into channels, users can disable specific notification 
channels for your app (instead of disabling all your notifications), and users can control the visual and auditory options for each channelall from the Android system settings (figure 11).



	Notification importance :-------------------

Android uses the importance of a notification to determine how much the notification should interrupt the user (visually and audibly). The higher the importance of a notification, 
the more interruptive the notification will be.

On Android 8.0 (API level 26) and above, importance of a notification is determined by the importance of the channel the notification was posted to. Users can change the importance
 of a notification channel in the system settings (figure 12). On Android 7.1 (API level 25) and below, importance of each notification is determined by the notification's priority.



The possible importance levels are the following:

Urgent: Makes a sound and appears as a heads-up notification.
High: Makes a sound.
Medium: No sound.
Low: No sound and does not appear in the status bar.



	Do Not Disturb mode ;---------------

Starting in Android 5.0 (API level 21), users can enable Do Not Disturb mode, which silences sounds and vibration for all notifications. Notifications still appear in the system UI as
 normal, unless the user specifies otherwise.

There are three different levels available in Do Not Disturb mode:

Total silence: blocks all sounds and vibrations, including from alarms, music, videos, and games.
Alarms only: blocks all sounds and vibrations, except from alarms.
Priority only: users can configure which system-wide categories can interrupt them (such as only alarms, reminders, events, calls, or messages). For messages and calls, users can also 
choose to filter based on who the sender or caller is



Notifications for foreground services (Some Doubt)

A notification is required when your app is running a "foreground service"a Service running in the background that's long living and noticeable to the user, such as a media player. 
This notification cannot be dismissed like other notifications. To remove the notification, the service must be either stopped or removed from the "foreground" state.


	Posting limits :---------------

Beginning with Android 8.1 (API level 27), apps cannot make a notification sound more than once per second. If your app posts multiple notifications in one second, they all appear as 
expected, but only the first notification per second makes a sound.



	Notification compatibility :--------------------------------

Since Android 1.0, the notification system UI and the notification-related APIs have continually evolved. To use the latest notification API features while still supporting older devices,
 use the support library notification API: NotificationCompat and its subclasses, as well as NotificationManagerCompat. This will allow you to avoid writing conditional code to check API 
levels because these APIs handle that for you.

NotificationCompat is updated as the platform evolves to include the latest methods. It is important to note that the availability of a method in NotificationCompat does not guarantee that 
the corresponding feature will be provided on older devices. In some cases calling a newly-introduced API results in a no-op on older devices. For example,
NotificationCompat.addAction() displays the action button on a device running Android 4.1 (API level 16) and higher only.




Create Basic Notification :------------------------

1) Set the notification content 

To get started you need to set the notification's content and channel using  ( NotificationCompat.Builder   Builder class for NotificationCompat objects. Allows easier control over all the 
flags, as well as help constructing the typical notification layouts.) object
The following example shows how to create a notification with the following:

A small icon, set by setSmallIcon(). This is the only user-visible content that's required.
A title, set by setContentTitle().
The body text, set by setContentText().
The notification priority, set by setPriority(). The priority determines how intrusive (Intruptive) the notification should be on Android 7.1 and lower. 
(For Android 8.0 and higher, you must instead set the channel importanceshown in the next section.)


NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID)	//single interface for creating notification and let support library do all compatibility
        .setSmallIcon(R.drawable.notification_icon)
        .setContentTitle("My notification")
        .setContentText("Much longer text that cannot fit one line...")
        .setStyle(new NotificationCompat.BigTextStyle()
                .bigText("Much longer text that cannot fit one line..."))
        .setPriority(NotificationCompat.PRIORITY_DEFAULT);


3) Show the notification

To make the notification appear, call NotificationManagerCompat.notify(), passing it a unique ID for the notification and the result of NotificationCompat.Builder.build(). For example:

NotificationManagerCompat  notificationManager = NotificationManagerCompat.from(this);

// notificationId is a unique int for each notification that you must define
notificationManager.notify(notificationId, builder.build());



//Updating Single Notification 
to update notification (that is already showing active) one just should just send new notification with the same.id Old notification will be replaced with new one.

2) Set the notification's tap action
Every notification should respond to a tap, usually to open an activity in your app that corresponds to the notification. To do so, you must specify a content intent defined with a 
PendingIntent object and pass it to setContentIntent().
for Handling clicking on notification one should set content intent.


//pendingintent is a special token it can be reterived from static methods such  as PendingIntent#getActivity, PendingIntent#getBroadcast #PedningInent#getService etc. to start service or send  broadcast.


Intent intent = new Intent(this, AlertDetails.class);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, intent, 0);

NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID)
        .setSmallIcon(R.drawable.notification_icon)
        .setContentTitle("My notification")
        .setContentText("Hello World!")
        .setPriority(NotificationCompat.PRIORITY_DEFAULT)
        // Set the intent that will fire when the user taps the notification
        .setContentIntent(pendingIntent)
        .setAutoCancel(true);


5) Add action buttons

A notification can offer up to three action buttons that allow the user to respond quickly, such as snooze a reminder or even reply to a text message. 
But these action buttons should not duplicate the action performed when the user taps the notification.

To add an action button, pass a PendingIntent to the addAction() method. 
This is just like setting up the notification's default tap action, except instead of launching an activity, 
you can do a variety of other things such as start a BroadcastReceiver that performs a job in the background so the action does not interrupt the app that's already open.



<Code>

Intent snoozeIntent = new Intent(this, MyBroadcastReceiver.class);
snoozeIntent.setAction(ACTION_SNOOZE);
snoozeIntent.putExtra(EXTRA_NOTIFICATION_ID, 0);
PendingIntent snoozePendingIntent =
        PendingIntent.getBroadcast(this, 0, snoozeIntent, 0);

NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID)
        .setSmallIcon(R.drawable.notification_icon)
        .setContentTitle("My notification")
        .setContentText("Hello World!")
        .setPriority(NotificationCompat.PRIORITY_DEFAULT)
        .setContentIntent(pendingIntent)
        .addAction(R.drawable.ic_snooze, getString(R.string.snooze),	 	// adding the PendingIntent instance in the addAction() method.
                snoozePendingIntent);



10:14 AM 9/5/2019

Since Android 0 release we can't show notification  by normal way
Notification channels enables us app developer to group our notification into group - channels
with the user having the ability to modify notification setting
Ex:- For each channel user can block all notification or allow notification to show.



=> Add a DIrect reply action :---------------------
The direct reply action introduced in ANdroid &.0 (API Level 24) allows uses to enter text directly into the notification which is delivered to your app without opening an activity.
You can use a direct reply action to let user reply to text message or update taks list from wihtin notificaiton.

Add the reply button

1) create an instance of RemoteInput.Builder that you add to your notification action. This class's constructor accepts a string that the system uses as the key for the text input

private static final String KEY_TEXT_REPLY="key_text_reply";
String replyLabel=getresource().getString(R.string.reply_label);
RemoteInput remoteInput=new RemoteInput.Builder(KEY_TEXT_REPLY)
.setLabel(replyLabel)
.build();

2) Create PendingIntent for the reply action

PendingIntent replyPendingIntent=PendingIntent.getBroadcast(getApplicationContext(), conversation.getConversationId(), getMessageReplyIntent(conversation.getConversationId()),PendingIntent.FLAG_UPDATE_CURRENT);


3) Attach the RemoteInput object to an action using addRemoteInput()
//create the reply action and add the remote input

NotificationCompat.Action action=new NotificationCompat.Action.Builder(R.drawable.ic__reply_icon,getString(R.string.label),replyPendingIntent)
.addRemoteInput(remoteInput)
.build();


4) Apply the action to a notification and issue the notificaiton

Notification newMessageNotification = new Notification.Builder(context,CHANNEL_ID)
.setSmallIcon(R.drawble.icon_message)
.setContentTitle(getString(R.string.title))
.setContentText(getString(R.string.content))
.addAction(action)
.build()

//Issue Notification
NotificationManagerCompat notificatioManager=NotificationManagerCompat.from(this);
notificationManager.notify(notificationId,newMessageNotification)



=> Reterieve user input from reply :-------------------

To receive user input from the notification's reply UI call RemoteInput.getResultsFromIntent() passing it the Intent received by your BroadcastReceiver

private ChaSequence getMessageText(Intent intent)
{
	Bundle remoteInput=RemoteInput.getResultsFromIntent(intent);
	if(remoteInput!=null)
	{
		return remoteInput.getCharSequence(KEY_TEXT_REPLY);
	}
	return NULL;
}



After youve processed the text, you must update the notification by calling NotificationManagerCompat.notify() with the same ID and tag (if used). This is necessary to hide direct reply 
UI and confirm to the user that their reply was received and processed correctly.

// Build a new notification, which informs the user that the system
// handled their interaction with the previous notification.
Notification repliedNotification = new Notification.Builder(context, CHANNEL_ID)
        .setSmallIcon(R.drawable.ic_message)
        .setContentText(getString(R.string.replied))
        .build();	//here we use notification builder to set various notification properties like its small and large icons title priority etc.

// Issue the new notification.
NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this);
notificationManager.notify(notificationId, repliedNotification);





=> Set a system-wide category :--------------------

Android uses a some pre-defined system-wide categories to determine whether to distrub the user with a given notification when the user has enable Do Not Disturb mode.

if your notification falls into one of the pre-defined notification categories deined in NotificationCompat  such as  CATEGORY_ALARM, CATEGORY_REMINDER, CATEROY_EVENT or CATEGORY_CALL
you should declared it as such by passing the appropriate category to setCategory().

NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID)
        .setSmallIcon(R.drawable.notification_icon)
        .setContentTitle("My notification")
        .setContentText("Hello World!")
        .setPriority(NotificationCompat.PRIORITY_DEFAULT)		// to set the priority
        .setCategory(NotificationCompat.CATEGORY_MESSAGE);  // use to set  when to interact with the user category


=> Show an Urgent Message :----------

Your app might need to display an urgent time-sensitive message such as an incoming phone call or a ringing alarm. In these situation you can associate a full-screen intent with your notification
When the notification is invoked users see one of the following depending on the device's lock status.

If the user's device is locked, a full-screen activity appears, covering the lockscreen.
If the user's device is unlocked, the notification appears in an expanded form that includes options for handling or dismissing the notification.

Intent fullScreenIntent = new Intent(this, ImportantActivity.class);
PendingIntent fullScreenPendingIntent = PendingIntent.getActivity(this, 0,
        fullScreenIntent, PendingIntent.FLAG_UPDATE_CURRENT);

NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID)
        .setSmallIcon(R.drawable.notification_icon)
        .setContentTitle("My notification")
        .setContentText("Hello World!")
        .setPriority(NotificationCompat.PRIORITY_DEFAULT)
        .setFullScreenIntent(fullScreenPendingIntent, true);



=> Set lock screen visibility

To control the level of detail visible in the notification from the lock screen, call setVisibility() and specify one of the following values:

VISIBILITY_PUBLIC shows the notification's full content.
VISIBILITY_SECRET doesn't show any part of this notification on the lock screen.
VISIBILITY_PRIVATE shows basic information, such as the notification's icon and the content title, but hides the notification's full content.

When VISIBILITY_PRIVATE is set, you can also provide an alternate version of the notification content which hides certain details. 
For example, an SMS app might display a notification that shows You have 3 new text messages, but hides the message contents and senders. 
To provide this alternative notification, first create the alternative notification with NotificationCompat.Builder as usual. 
Then attach the alternative notification to the normal notification with setPublicVersion().


=> Create a Expandable Notification :------------------

To start, build a notification with all the basic content as described in Create a Notification. Then, call setStyle() with a style object and supply information corresponding to each template

1) Add a Large Image
Notification notification=new NotificationCompat.Builder(context,CHANNEL_ID);
.setSmallIcon(R.drawable.new_post)
.setContentTitle(imageTitle)
.setContextText(imageDescription)
.setStyle(new NotificationCompat.BigPictureStyle().bigPicture(myBitmap))
.build()


to make the image appear as a thumbnail only while the notification is collapse call setLargeIcon() and pass it the image, but also call BigPictureStyle.bigLargeIcon() and pass it 
null so the large icon goes away when the notification is expanded:

Notification notification = new NotificationCompat.Builder(context, CHANNEL_ID)
        .setSmallIcon(R.drawable.new_post)
        .setContentTitle(imageTitle)
        .setContentText(imageDescription)
        .setLargeIcon(myBitmap)
        .setStyle(new NotificationCompat.BigPictureStyle()
                .bigPicture(myBitmap)
                .bigLargeIcon(null))
        .build();



=> Add  a large block of text :----------

Apply NotificationCompat.BigTextStyle to display text in the expanded content area of the notification.

Notification notification = new NotificationCompat.Builder(context, CHANNEL_ID)
        .setSmallIcon(R.drawable.new_mail)
        .setContentTitle(emailObject.getSenderName())
        .setContentText(emailObject.getSubject())
        .setLargeIcon(emailObject.getSenderAvatar())
        .setStyle(new NotificationCompat.BigTextStyle()			// BigTextStyle to display text in the expanded content area of notification
                .bigText(emailObject.getSubjectAndSnippet()))
        .build();





=> Create an Inbox-style Notification :------------------

Apply NotificationCompat.InboxStyle to notification if you want to add multiple short summary linea such as snippets from incoming emails.This allows you to add multiple pieces of content text
 that are truncated to one line instead of one continues line of text provided by NotificationCompat.BigTextStyle.

to add a new line call addLine() up to 6 times if you add more than 6 lines only the first 6 are visible.

Notification notification = new NotificationCompat.Builder(context, CHANNEL_ID)
        .setSmallIcon(R.drawable.new_mail)
        .setContentTitle("5 New mails from " + sender.toString())
        .setContentText(subject)
        .setLargeIcon(aBitmap)
        .setStyle(new NotificationCompat.InboxStyle()
                .addLine(messageSnippet1)
                .addLine(messageSnippet2))
        .build();




=> Show a conversation in a notification :-
Apply NotificationCompat.MessagingStyle to display sequential messages between any number of people. This is ideal for messaging apps because it provides a consistent layout for 
each message by handling the sender name and message text separately, and each message can be multiple lines long.

NotificationCompat.MessagingStyle.Message message1 =
        new NotificationCompat.MessagingStyle.Message(messages[0].getText(),
                                                      messages[0].getTime(),
                                                      messages[0].getSender());
NotificationCompat.MessagingStyle.Message message2 =
        new NotificationCompat.MessagingStyle.Message(messages[1].getText(),
                                                      messages[1].getTime(),
                                                      messages[1].getSender());

Notification notification = new NotificationCompat.Builder(context, CHANNEL_ID)
        .setSmallIcon(R.drawable.new_message)
        .setStyle(new NotificationCompat.MessagingStyle(resources.getString(R.string.reply_name))
                .addMessage(message1)
                .addMessage(message2))
        .build();










-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
00:00 15-09-2019	Content Provider :----------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

A content provider manages access to central repository of data. A provider is part of an Android Application which often provides its own UI for working with the data.
However content providers are primarily intended to be used by other application which access the provider client object.

Typically you work with content providers in one of two scenarios; 
1) you may want to implement code to access an existing content provider in another application
2) You may want to create a new content provider in your application to share data with other applications.

we are just going to describe the following cases: --------------------
=> How content providers works.
=> The API you use to reterieve data from a content provider
=> API you use to insert, update or delete in content provider
=> other API features that facilitate working with providers.



A content provider presents data to external application as one or more tables that are similar to the tables found in a relational databse.
A row represent an instance of some type of data the provider collects.
Each column in the row represent an individual piece of data collected for an instance.

1) Sharing access to your application data with other applications.
2) Sending data to a widget 
3) Returning custom search suggestions for your application through the search framework using SearchRecentSuggestionsProvider
4) Synchronizing application data with your server using an implementation of AbstractThreadedSyncAdapter
5) Loading data in yout UI using a CursorLoader.





=> Acceesing a Provider :-----------------------------------------

When you want to access data in a content provider, you use the ContentResolver object in your application's Context to communicate with the provider as a client.
The ContentResolver object communicates with the provider object an instance of a class that implements ContentProvider.
The provider object receives data request from client perform the requested action and returns the results.
The ContentResolver methods provide the basic CRUD ( create, reterive, update and delete) functions of persistent storage.

The common pattern for accessing a ContentProvider from your UI uses a CursorLoader to run an asynchronous query in the background.The Activity or Fragment in your UI call a CursorLoader to the query, which in turn gets the ContentProvider using the ContentResolver. This allows the UI to continue to be available to the user while the query is running. 


To get a list of the words and their locales from the User Dictionary Provider you call ContentResolver.query().

/*
this operation runs in the background after calling the ContentResolver.query()
The query() method calls the ContentProvider.query() method defined by the Dictionary Provier. The following line of code:---
*/


// Queries the user dictionary and returns results
cursor = getContentResolver().query(
    UserDictionary.Words.CONTENT_URI,   // The content URI of the words table
    projection,                        // The columns to return for each row
    selectionClause,                   // Selection criteria
    selectionArgs,                     // Selection criteria
    sortOrder);                        // The sort order for the returned rows


how the arguments to query(Uri, projection, selection, selectionArgs,sortOrder) match an SQL SELECT statement:


Uri  		FROM table_name		Uri maps to the table in the provider named table_name.
projection		col, col, col		projection is an array of columns that should be included for each row reterived.
selection		WHERE col=value		selection specifies the criteria for selecting rows
selectionArgs	(Now exact equivalent
		  selection arguments
		replace ?  place holders
		in the selection clause.

sortOrder		ORDER BY col, col		sortOrder specifies the order in which rows appear in the returned Corsur.





=> Content URIs :-------------------------------------------

A content URI is a URI that identifies data in a provider. Content URIs include the symbolic name of the entire provider (its authority) and a name that points to a table  (a pth). When you canna client method to access a table in a provider, the content URI for the table is one of the arguments.


In the preceding line of code the constant CONTENT_URI contains the content URI of the user dictionary's words table. The ContentResolver object parses out the URI's authority and uses it to resolve the provider by comparing the authority to a system  table of known providers. The ContentResolver can then dispatch the qurey arguments to the correct provider.
								The ContentProvider uses the   path part of the content URI to choose the table to access.

In the previous line of code the full URI for the words table is :
content://user_dictionary/words

where the user_dictionary string is the provider's authority and the words string is the table's path.
The String content:// (the scheme) is always present and identifies this as a content URI.

Many providers allow you to access asingle row in a table by appending an ID value to the end of the URI. For example to reterive a row whose _ID is 4 from user dictionary you can use this content URI:

Uri singleUri=ContentUris.withAppendedId(UserDictionary.Words.CONTENT_URI,4);



=> Retrieving data from the provider :--------------------------------------------

This sections describes how to reterive data from a provier using the User Dictionary Provider as an example

To reterive data from a provider follow these basic steps :-------------------
1) Request the read access permission for the provider
2) Define the code that sends a query to the provider


Requesting read access permission :-
To reterive data from a provider your application needs read access permission for the provider. You can't request this permission at run time; instead you have to specify that you need this permission in your manifest, using the 
	
	<uses-permission> element and exact permission name defined by the provider
when users install your application they implicitly grant this request.

The User Dictionary Provider defines the permission android.permission.READ_USER_DICTIONARY in its manifest file, so an application that wants to read from the provider must request this permission.



	Constructing the query :--------------------------------------

The next step in reteriving data from a provider is to construct a query. This first snippet defines some variable for accessing the User Dictronary
Provider :

// A "projection" defines the columns that will be returned for each row
String[] mProjection =
{
    UserDictionary.Words._ID,    // Contract class constant for the _ID column name
    UserDictionary.Words.WORD,   // Contract class constant for the word column name
    UserDictionary.Words.LOCALE  // Contract class constant for the locale column name
};

// Defines a string to contain the selection clause
String selectionClause = null;

// Initializes an array to contain selection arguments
String[] selectionArgs = {""};



	

	Reteriving data from the provider :-------------------------------
This section describes how to reterive data from a provider using the User Directory Provider as an example.

To reterive data from a provider follow these basic stpes:-
1) Request the read access permission for the provider
2) Define the code that sends a query to the provider.


=> Requesting read access permission:-
To reterive data from provider your application needs read access permission for the provider. you can;t request this permission at run-time instead, you have to specify that you need this permission in your manifest , using the 

	<uses-permission> element and  the exact permission name defined by the provider.
When you specify this element in your manifest you are in effect requesting this permission for your application. When user install your application they implicitly grant this request.




=> Constructing the Query
The next stpe in reteriving data from a provider is to constrcut a query. This first snippet defines some variables for accessing the User Directory Provider.

// A "projection" defines the columns that will be returned for each row
String[] mProjection =
{
    UserDictionary.Words._ID,    // Contract class constant for the _ID column name
    UserDictionary.Words.WORD,   // Contract class constant for the word column name
    UserDictionary.Words.LOCALE  // Contract class constant for the locale column name
};

// Defines a string to contain the selection clause
String selectionClause = null;

// Initializes an array to contain selection arguments
String[] selectionArgs = {""};




Example of Contact List :--------------------------------------------------------------

package com.example.content;
import android.content.ContentResolver;
import android.database.Cursor;
import android.net.Uri;
import androidx.appcompat.app.AppCompatActivity;
import androidx.appcompat.app.ActionBar;
import android.widget.ArrayAdapter;
import android.widget.ListView;
import android.os.Bundle;
import android.provider.ContactsContract;
import java.util.ArrayList;

public class MainActivity extends AppCompatActivity {
    private ActionBar actionBar;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        actionBar=getSupportActionBar();
        actionBar.setTitle("Contact List");
        fetchContact();
    }

    public void fetchContact()
    {
        ArrayList<String> contacts=new ArrayList<>();
        Uri uri= ContactsContract.CommonDataKinds.Phone.CONTENT_URI;
        String[] projection={ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME,ContactsContract.CommonDataKinds.Phone.NUMBER};
        String selection=null;
        String[] selectionArgs=null;
        String sortOrder="";

        ContentResolver resolver=getContentResolver();
        Cursor cursor=resolver.query(uri,projection,selection,selectionArgs,sortOrder);

        while(cursor.moveToNext())
        {
            String name=cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME));
            String number=cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER));
            contacts.add(name+"\n"+number);
        }

        ((ListView)findViewById(R.id.listview)).setAdapter(new ArrayAdapter<>(this,android.R.layout.simple_list_item_1,contacts));

    }
}











-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
20:02 12-10-2019 		ListView
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Displays a vertically-scrollable collection of views where each view is positioned immediately below the previous view in the list.

Step (1)	to display a list we can include a list view in our layout XML file:

<ListView 
	android:id="@+id/list_view"
	android:layout_width="match_parent"
	android:layout_height="match_parent" />


Step (2)
A list view is an adapter view that does not know the details such as type and content of the views it contains instead list view requests views on demands from a listadapter as needed such as to display new views as the user scrolls up or down.

in order to display items in the list call setAdapter(android.widget.ListAdapter) to associate an adapter with the list.


To display more custom view for each item in your dataset implement a ListAdapter.For example extends BaseAdapter and create andd configure the view for each data item in getView(...)

=> XML attributes

android:divider			Drawable or color to draw between list items.
android:dividerHeight		Height of the divider
android:entries			Reference to an array resources that will populate the ListView.
android:footerDividersEnabled		When set to false, the ListView will not draw the divider before each footer view. 
android:headerDividersEnabled	When set to false, the ListView will not draw the divider after each header view. 



=> Custom ListView

Step (1)
Create a ListView in activity_main.xml
set string[] and Integer[] for image 


Step (2)
create a new class object and pass the context,string,imageid

pass the object of custom class with listview   instance.setAdapter(instace_of_custom_class)
 perform set onclick listener on list view
call list.setOnClickListener(new AdapterView<?> parent,View view,int position,long id)

Step (3)
go to custom_class 
make variable of string and image id that have pass from mainactivity.class

make constructor of the class
for initializing the variable

override the getView method
inflate the view from xml file where we declare the custom layout of custom list view
using view inflator set the TextView and imageview and after that set string and image with position
and return the view.


















-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
23:58 10-10-2019 		RecyclerView
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Android RecyclerView is a more advanced powerful and flexible version of the ListView.
RecyclerView is similar to ListView except that it forces us to use RecyclerView.ViewHolder class to hold the element which is not a compulsion in ListView.

As the name suggests Android RecyclerView is used to reuse cells when scrolling up and down by recycling the items in the list.
Another improvement in RecyclerView is that it allows us to set the LayoutManager dynamically at runtime, unlike the ListView which was only available in a vertical scrolling List.

LinearLayoutManager : it supports both vertical and horizontal lists
StaggeredLayoutManager : it supports staggered lists
GridLayoutManager : it supports displaying grids as seen in GalleryView earlier

Glossary of terms :--------------------

=> Adapter: A subclass of RecyclerView.Adapter responsible for providing views that represent items in a data set.

=> Position: The position of a data item within an Adapter.

=> Index: The index of an attached child view as used in a call to getChildAt(int). Contrast with Position.

=> Binding: The process of preparing a child view to display data corresponding to a position within the adapter.

=> Recycle (view): A view previously used to display data for a specific adapter position may be placed in a cache for later reuse to display the same type of data again later. This can drastically improve performance by skipping initial layout inflation or construction.

=> Scrap (view): A child view that has entered into a temporarily detached state during layout. Scrap views may be reused without becoming fully detached from the parent RecyclerView, either unmodified if no rebinding is required or modified by the adapter if the view was considered dirty.

=>Dirty (view): A child view that must be rebound by the adapter before being displayed.


=> Step to create the RecyclerView

Step (1)
in main activity infalte the recycler view that we have declared in the activity_main.xml
set the layout of the Recycler view using LayoutManager
 set the adapter of the RecyclerView and pass the instance of the view Holder where we declared the recycle view



Step (2)
create a new layout where we declare the view which we are going to the use in recycler view

the class that we pass the instance in the recyclerview adapter
extends that class with RecyclerView.Adapter<class.classViewHolder>

create a constructor of the class 
where we pass the data of the mainactivity to show in recycler view

override the three method 1) onCreateViewHolder 2) getItemCount 3) onBindView

1)
we will use layout inflater to infalte the view and return it to the classViewHolder

we will binfthe data with position in onBindView method

we will count the length of data in getItemCount.

in classViewHolder we will recycle the view using constructor of classViewHolder
 






















-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------14:13 13-10-2019		Android Firebase
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Firebase a mobile and web application development platform by Firebase Inc in 2011 then acquired by Google in 2014. As of October 2018 the Firebase platform has 18 products which are used by 1.5 million apps.

The services provided by the Firebase :-

=> Firebase Analytics
Firebase Analytics is a cost-free app measurnment solution that provides insight into app usage and user engagement.


=> Fire Cloud Messaging
Formerly known as Google Cloud Messaging(GCM) Firebase Cloud Messaging (FCM) is a cross-platform solution for message and notification for Android,IOS and web applicatio at no cost.

=> Firebase Auth
Firebase Auth is a service that can authenticate users using only client-side code.It support social login provides facebook,GitHub, Twittter and Google (and Google Play Games). Additionaly it includes a user management system whereby developers can enable user authentication with email and password store with Firebase.

=> Firebase Realtime Database
Firebase provides a realtime database abd backend as a service. The servce provides application developers an API that allows application data to be synchronized across clients and stored on Firebase's cloud. The company provides client libraries that enable integration with Android,IOS,JavaScript,java,Objective-C,Swift and Node.java application. The database is also accessible through RESTAPI.

=> Firebase Storage
Firebase Hosting is  a static dynamic web hosting service that launched on May 13,2014.It supports hosting static files such as CSS,HTML,JavaScript and other files as wellas support through Cloud Functions.The service delivers files over a content delivery network (CDN) through HTTP Secure (HTTPS) and Secure Sockets layer encryption (SSL).


=> ML Kit
ML kit is mobile machine learning system for developers. ML kit API's feature a variety of feature including text recognition , face detecting scanning  barcodes, labelling images and recognising landmarks. It is currently available for IOS or Android developers. you may also import your own TensorFlow lite models if models if the given API's aren't enough .The API's can be used on device or on cloud.


Step to start Firebase in Android.

=> we can connnect our  Android app to Firebase using one of the following options:
option1: use the Firebase console setup workflow
option2: use the Android Studio Assistant (requires additional configuration)

Option 1 Add Firebase using the Firebase console
Adding Firebase to your app involves taks both in the Firebase console.

Step 1
Before you can add Firebase to your Android app, you need to create a Firebase project to connect to your Android app Visit understand Firebase Project to learn more about Firebase projects.

Step 2 Register your app with Firebase
After you have a Firebase project you can add your Android app to it.

 After creatting a project in Firebase

 Enter your app's package name / application ID in the Andorid package name field.

 An application ID is sometimes referred to as a package name.

 find this application ID in your module app-level Gradle file usually app/build.gradle (example ID: com.yourcompany.yourproject)
 
=> (Optional) Enter other app information as prompted by the setup workflow (The nick name is an intent convenience identifier and is only visible to you in the Firebase console.)

SHA-1 information is required by Firebase Authentication (when using Google -Sign in or PHone number sign in) and Firebase Dynamic Links.


Step 3 : Add a Firebase configuration file

1 => Add the Firebase Android configuration file to your app:

=> click Donload google-service.json to obtain your Firebase Android config file(google-service.json)
	=> You can download your Firebase Android config file again at any time.
	=> Make sure the config file is not appended with additional characters


2 => To enable Firebase products in your app add the google-service plugin to your Gradle files.
	=> In your root-level (project-level) Gradle file (build.gradle), add rules to include the Google Services plugin. Check that you have 		     Google's Maven repository, as well.


buildscript {

  repositories {
    // Check that you have the following line (if not, add it):
    google()  // Google's Maven repository
  }

  dependencies {
    // ...

    // Add the following line:
    classpath 'com.google.gms:google-services:4.3.2'  // Google Services plugin
  }
}

allprojects {
  // ...

  repositories {
    // Check that you have the following line (if not, add it):
    google()  // Google's Maven repository
    // ...
  }
}


b => In your module (app-level) Gradle file (usually app/build.gradle), add a line to the bottom of the file.

apply plugin: 'com.android.application'

android {
  // ...
}

// Add the following line to the bottom of the file:
apply plugin: 'com.google.gms.google-services'  // Google Play services Gradle plugin




Step (4) Add Firebase SDKs to your app .

you can add any of the support Firebase products to your Android app.

1. To your module (app-level) Gradle file (usually app/build.gradle) add the dependencies for the Firebase products that you want to use in your app.

dependencies {
  // ...

  // Add the Firebase SDK for Google Analytics
  implementation 'com.google.firebase:firebase-analytics:17.2.0'

  // Add the SDKs for any other Firebase products you want to use in your app
  // For example, to use Firebase Authentication and Cloud Firestore
  implementation 'com.google.firebase:firebase-auth:19.1.0'
  implementation 'com.google.firebase:firebase-firestore:21.1.1'

  // Getting a "Could not find" error? Make sure that you've added
  // Google's Maven repository to your root-level build.gradle file
}

Sync your app to ensure that all dependencies have the necessary versions.


Option 2: Add Firebase using the Firebase Assistant


Note that the recommended option to connect your app to Firebase is to use the Firebase console setup workflow.

Open your Android project in Android Studio.

Select Tools > Firebase to open the Assistant window.

Expand one of the listed Firebase products (for example, Analytics), then click the provided tutorial link (for example, Log an Analytics event).

Click Connect to Firebase to register your app with an existing or new Firebase project and to automatically add the necessary files and code to your Android project.

Check that your plugin and library versions are up-to-date:

In your root-level (project-level) Gradle file (build.gradle), check that your Google Services plugin version is up-to-date (com.google.gms:google-services:4.3.2).

In your module (app-level) Gradle file (usually app/build.gradle), check that your Firebase Android library versions are up-to-date.




ML Kit  (Machine Learning ) :-----------------------------------------------------

Detect Faces with ML kit on Android :-
you can use ML kit to detect faces in image and video

Step to dive in ML kit face detection :---------------------

=> In your project-level build.gradle file make sure to include google's maven rpository in both your buildscript and allproject sections.
=> Add the dependencies for the ML kit android libraries to your module (app-level) gradle file (usually app/build.gradle):

dependencies {
  // ...

  implementation 'com.google.firebase:firebase-ml-vision:23.0.0'
  // If you want to detect face contours (landmark detection and classification
  // don't require this additional model):
  implementation 'com.google.firebase:firebase-ml-vision-face-model:18.0.0'
}
apply plugin: 'com.google.gms.google-services'


=> Optional but recommended : Configure your app to automatically download the ML module to the device after your app is installed from the Play store
To do so add the following declaration to your app's AndroidManifest.xml file:

<application ...>
  ...
  <meta-data
      android:name="com.google.firebase.ml.vision.DEPENDENCIES"
      android:value="face" />
  <!-- To use multiple models: android:value="face,model2,model3" -->
</application>



Input image guideline :---
 for ML kit accurately detect faces input image must contain faces that are represented by sufficient pixel data.In general each face you want to detect in an image should be at least 100x100 pixels.if you want to detect the contours of faces ML Kit requires higher resolution input each face should be at least 200x200 pixels.

if you are detecting faces in a real time application you might also want to consider the overall dimensions of the input image. Smaller image can
be processed faster so to reduce latency capture image at lower resolution and ensure that the subject's face occupies as much of the image as possible .

Poor image focus can hurt accuracy.If you aren't getting acceptable results try asking the user to recapture the image .


1. Configure the face detector
If we want to change any of the face detector's default setting specify those setting with a FirebaseVisionFaceDetectorOption object you can change the following setting.


Settings :-------------------------------------------------------------------------------------------------------------------

Performance mode		FAST (default) | ACCURATE
			Favor speed or accuracy when detecting faces.

Detect landmarks		NO_LANDMARKS (default) | ALL_LANDMARKS
			Whether to attempt to identify facial "landmarks": eyes, ears, nose, cheeks, mouth, and so on.

Detect contours		NO_CONTOURS (default) | ALL_CONTOURS
			Whether to detect the contours of facial features. Contours are detected for only the most prominent face in an 			image.


Classify faces		NO_CLASSIFICATIONS (default) | ALL_CLASSIFICATIONS
			Whether or not to classify faces into categories such as "smiling", and "eyes open".

Minimum face size		float (default: 0.1f)
			The minimum size, relative to the image, of faces to detect.

Enable face tracking		false (default) | true
			Whether or not to assign faces an ID, which can be used to track faces across images.

			Note that when contour detection is enabled, only one face is detected, so face tracking doesn't produce useful 			results. For this reason, and to improve detection speed, don't enable both contour detection and face tracking.













	Drawable resource :---------------

A drawablw resource is a general concept for a graphics that can be drawn to the screen and which you can reterieve with APIs such as getDrawable(int) or apply to another Xml resource 
attributes such as android:drawable and android:icon

Different types of Drawable :-

1) Bitmap		:- a bitmap graphics file (.png, .jgp, or .gif) create a BitmapDrawable
2) Nine-patch File	:- A PNG file with stretchable region to allow image resizing on content
3) Layer List	:- A drawable that manage an array of other Drawables .these are drawn in array order so the element with the largest index is be drawn on top.
4) State List	:- an Xml file that reference different bitmap graphics for different states (for example to use a different image when a button is pressed)
5) Level List	:- an Xml file that defines a drawable that manges a number of alternative Drawable each assign a maximum numerical value.
6) Transition Drawable :-  an xml file that define a drawable that can cross fade between two drawable resource.
7) Inset Drawable	:- an sml file that define drawable that insets another drawable by a specific distane.
8)clip drawable	:- an xml file that define a drawable that clip another drawabable
9) Scale Drawable	:- an xml file that define a drawable that change the size of another drawable


A bitmap file is a .png, .jpg, or .gif file. Android creates a Drawable resource for any of these files when you save them in the res/drawable/ directory.

resource reference:
In Java: R.drawable.filename
In XML: @[package:]drawable/filename






23:52 26-09-2019	Retrofit REST-API :----------------------------------------------------------------------------------------------------------------------------------------------------------------
Retrofit  is a type-safe HTTP client for Android and Java.
Retrofit is REST Client library (Helper Library) used in Android and Java to create an HTTP request and also to process the HTTP response from a REST API. It was created by square, you can also use retrofit to receive data strcutures other than JSON.

REST Client in our case is the Retrofit library that is used on the client side (Android) to make HTTP request to REST API.

A REST API defines a set of functions which developers can perform requests and receive response via HTTP protocol such as GET and POST.

We can also simply say that a RESTful API is an application program interface (API) that uses HTTP requests to GET, PUT ,POST and DELETE data.


public interface GitHubService
{
	@GET("user/{user}/respo")
	Call<List<Repo>> listRepos(@Path("user")String user);

	@GET("group/{id}/users")
	
	Call<List<User>> groupList(@Path("id") int groupId);
}

Every method inside an interface represent one possible API call.It must have a HTTP annotation(GET,POST etc) to specify the request type and the relative URL.
The return value wraps the response in a Call object with the type of the expected result.

@GET(group/{id}/users)
Call<List<User>> groupList(@Path(id) int groupId, @Query(sort) String sort);

Retrofit supports Authentication for API calls that require the user to be authenticated before using the API to access resources. Querying Twitter, Facebook and StackoverFlow all require authentication. 













-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
14:18 06-10-2019 Chronometer in Android :----------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

In Android Chronometer is a class that implements a simple timer. Chronometer is a subclass of TextView.
This class helps us to add a timer in our app.

You can give it start time in the SystemClock#elapsedRealtime timebase and it counts up from that or if you don't give it a base time it will use the time at which you call start().

The timer can also count downword towards the base time by setting setCountDown(boolean) to true.

By default it will display the current timer value in the "MM:SS" or "H:MM:SS" or you can use setFormat(String) to format the timer value into an arbitrary string.


interface Chronometer.OnChronometerTickListener		A callback that notifies when the chronometer has incremented on its own.


android:countDown	=> Specifies whether this Chronometer counts down or counts up from the base. 
android:format	=> Format string: if specified, the Chronometer will display this string, with the first "%s" replaced by the current timer 		     value in "MM:SS" or "H:MM:SS" form. 


=> Chronometer code in XML

<Chronometer
android:id="@+id/chronometer_timer"
android:layout_width="wrap_content"
android:layout_height="wrap_content"/>


=> Public constructors

	Chronometer(Context context)				initialize this Chronometer object

	Chronometer(Context context,AttributeSet attrs)		initialize with standdard view layout information
	
	Chronometer(Context context,AttributeSet attrs,int defStyleAttr) initialize with standard view layout information and style
	
	Chronometer(Context context,AttributeSet attrs,int defStyleAttr,int defStyleRes)


public methods:------------------

CharSequence	getAccessibilityClassName()
Return the class name of this object to be used for accessibility purposes.

long	getBase()
Return the base time as set through setBase(long).

CharSequence	getContentDescription()
Returns the View's content description.

String	getFormat()
Returns the current format string as set through setFormat(String).

Chronometer.OnChronometerTickListener	getOnChronometerTickListener()
boolean	isCountDown()
boolean	isTheFinalCountDown()
void	setBase(long base)
Set the time that the count-up timer is in reference to.

void	setCountDown(boolean countDown)
Set this view to count down to the base instead of counting up from it.

void	setFormat(String format)
Sets the format string used for display.

void	setOnChronometerTickListener(Chronometer.OnChronometerTickListener listener)
Sets the listener to be called when the chronometer changes.

void	start()
Start counting up.

void	stop()
Stop counting up.



XML Attributes:---------------------------

android:countDown
Specifies whether this Chronometer counts down or counts up from the base. If not specified this is false and the Chronometer counts up.

May be a boolean value, such as "true" or "false".

android:format
Format string: if specified, the Chronometer will display this string, with the first "%s" replaced by the current timer value in "MM:SS" or "H:MM:SS" form. If no format string is specified, the Chronometer will simply display "MM:SS" or "H:MM:SS".












-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
12:56 12-10-2019	ConnectivityManager --------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Class that answer queries about the state of network connectivity.It also notifies applications when network connectivity changes.

The primary responsibility of this class are to :
1) Monitor network connections (WiFi, GPRS, UMTS, etc )
2) Send broadcast intents when network connectivity changes
3) Attempt to fail over to another network when connectivity to a network is lost.
4) Provide an API that allows applications to query the coarse-grained or fine-grained state of the available networks
5) Provide an API that allows applications to request and select networks for their data traffic


class		ConnectivityManager.NetworkCallback (Base class for NetworkReuest callback)

interface		ConnectivityManager.OnNetworkActiveListener
		( Callback for use with ConnectivityManger #addDefaultNetworkActiveListener) to find out when the system default 		network has gone in to a high poser state.



Public methods :---------------------------------------------------------------------------------------

void 		addDefaultNetworkActiveListener(ConnectivityManager,OnNetworkActiveListener l)
		start listening to report when the system's default data network is active meaning it is a good time to perform network.

boolean		bindProcessToNetwork(Network network)
		Binds the current process to network

Network		getActiveNetwork()
		Return a Network object corresponding to the currently active default data network.

NetworkInfo	getActiveNetworkInfo()
		get an instance that represents current network connection.


NetworkInfo[]	getAllNetworkInfo[]/getAllNetworks()	Returns an array of all Network currently tracked by the framework.

ProxyInfo		getDefaultProxy()	Get the default HTTP proxy setting




=> Determine if you have an internet connection
There is no need schedule an update based on an internet resource if you aren't connected to the internet.the following snippet show how to use the ConnectivityManager to query the active network and determine if it has Intenet sconnectivity.


	ConnectivityManager cm =(ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE);
	NetworkInfo activeNetwork = cm.getActiveNetworkInfo();
	boolean isConnected = activeNetwork != null && activeNetwork.isConnectedOrConnecting();

=> Determine the type of your internet connection
It's also possible to determine the type of internet connection currentlyavailable.
Device connectivity can be provided by mobile data,WiMAX,Wi-Fi and ethernet connections.By querying the type of the active network as shown below, you can alter your refresn rate based on the bandiwth available.

	boolean isWiFi= activeNetwork.getType()==ConnectivityManger.TYPE_WIFI
