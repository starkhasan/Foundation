					-------------------------:  Flutter Architecture overview  :-------------------------
Flutter is a cross platform UI toolkit that is designed to allow code reuse across operating systems such as iOS and Android while also allowing application to interface directly with underlying
platform services.

	During development Flutter apps run in a VM offers stateful hot reload of changes without needing full recompile. For release, Flutter apps are compiled directly to machine code.


=> Architectural layers 
Flutter is designed as an extensible layered system. It exists as a series of independent libraries that each depend on the underlying layer. No layer has privileged access to the layer below
and every pert of the framework level is designed to be optional and replaceable.

1) Platform-specific Embedder privides an entrypoint coordinates with the operating system for access to services like rendering surfaces accessibility and input and manages the message
event loop. The embedder is written in language that is approriate for platform currently Java and C++ for Android , Objective-C/Objective-C++ fir iOS and macOS and C++ for Windows and
Linux.

2) At the core Flutter is the Flutter engine which is mostly written in C++ and supports the primitives necessary to support all Flutter application. The engine is reponsible for rasterizing
composited scenes whenever a new frames needs to be painted. It provides the low-level implementation of Flutter's core API including graphics (through Skia) text layout file and network
I/O accessibility support , plugin architecture and Cart runtime and compiled toolchain.


The engine is exposed to the Flutter framework through dart:ui, which wraps the underlying C++ code in Dart classes.

3) Typically developers interact with Flutter through the Flutter framework which provides a modern reactive framework written in the Dart language. It includes a rich set of platform layout
and fundational libraries composed of series of layers.


Widget state :--------------------------------------------------------
The framwork introduce two major widget stateful and statelwss widgets. 

Many widgets have no mutable state: they don't have any properties that change over time (for example an icon or a label ). These widget subclass StatelessWidget.

However if the unique characteristics of a widget need to change based on user interaction or toher factors that widget is stateful. For example if a widget has counter that increments
whenever the user taps a button then the values of the counter is the state for that widget. When that value changes the widget needs to be rebuilt to update its  part of the UI. These widget
subclass StatefulWidget and (because the widget itself is immutable) they store mutable state in a seperate class that subclasses State.	

	StatefulWidget don't have a build method instead their user intreface is built through their State object.Whenever you mutate a State you must call setState() to single the
framework to update the user nterface by calling the State's build again.



import 'package:flutter/material.dart';

void main() {
  runApp(
    Center(
      child: Text(
        'Hello, world!',
        textDirection: TextDirection.ltr,
      ),
    ),
  );
}


main() function came from Java-like languages so it is where all program statrted without it you can't write any program on Flutter even without UI.

runApp() function should return widget that would be attached to the screen as a root of the widget Tree that will be rendered.


What is Widget ?
Widget is a description of a part of UI.
In flutter Widget is a way to declare and construct UI.
If you are familiar with the Android or iOS development then you might make the immediate connection with the views (on Android) or UIViews (on iOS).


Basic widgets =>
Flutter comes with a suite of powerful basic widget, of which the following are commonly used.

Text
The Text widget lets you create a run of styled text within your application.

Row, Column
These widget let you create layout in both the horizontal and vertical directions. The design of these object is based on the web's flexbox layout model.

Row is a widget used to display child widget in horizontal manner.
Column is a widget used to display child widgets in a vertical manner. 

CrossAxisAlignment Property :-
We can use the crossAxisAlignment property to align our child widget in the desired cross Axis. 
Example crossAxisAlignment.start would place the children with their start edge aligned with the start side of the cross axis.
Example crossAxisAlignment.center  Place the children so that their centers align with the middle of the cross axis.
Example crossAxisAlignment.stretch require the children to fill cross axis.


MainAxisAlignment Property :-------------------
The poistioning of the child widget on the main axis.

MainAxisAlignment.start => Place the children as close to the start of the main axis as possible.

MainAxisAlignment.center => Place the children as close to the middle of the main axis as possible.

MainAxisAlignment.end => Place the children as close to the end of the main axis as possible.



mainAxisSize property :---------------------------------------------
MainAxisSize mainAxisSize 

How much space should be occupied in the main axis
After allocating space to children there might be some remaining few space. This value control whether to maximize or minimize the amount of the free space to the incoming layout 
constraints. If some children have a non-zero flex factor  (and none have a fit of FlexFit loose) they will expand to consure all the available space and there will be no  remaining free space 
to maximizing or minimizing making this value irrelevant to the final layout.




Stack ================>
Instead of being linearly oriented (either horizontally or vertically) a Stack widget lets you place widgets on top of the each other in paint order. You can then use the Positioned widget
on children of Stack to position them relative to the top right bottom or left edge of the stack. Stacks are based  on the web's absolute positioning layout model.

A Stack widget allows us to make multiple widget overlay each other. This not only allows brillant custom designed but also some really cool animations. There are two main types of Stacks:
1) Stack
2) Indexed Stack


Stack widget allows us to put up multiple layers of the widget onto the screen.
The widget takes multiple children and orders them from bottom to top. So the first item is the bottommost and the last is the topmost.

Stack(
  children: <Widget>[
    BottomWidget(),
    MiddleWidget(),
    TopWidget(),
  ],
)

Each member in the stack needs to be positioned or aligned or else it ends up in the top left corner by default.
you can align or position your widget using the Align or Positioned widget.

An Align widget usually takes widget to extreme positions

Positioned has multiple types, we'll focus on the default. It accepts values from all four sides telling the child how far it should be away from the respective side. If no value os given it 
shrink to the lowest possible size.



IndexedStack
An IndexedStack is a Stack where only one element is displayed at one time by its index.

IndexedStack(
  index: 1,
  children: <Widget>[
    BottomWidget(),
    MidWidget(),
    TopWidget(),
  ],
)

It tackes children like usual Stack but it contrast to it only displays one child at one time.




=> Container
The Container widget lets you create a rectangular visual element. A Container can be decorated with BoxDecoration such as a background a border or a shadow. A Container can also have 
margins, padding and constraints applied to its size. In addition a Container can be transformed in three dimensional space using a matrix.

Container(
 height: 56.0, // in logical pixels
 padding: const EdgeInsets.symmetric(horizontal: 8.0),
 decoration: BoxDecoration(color: Colors.blue[500]),
 child: Row(
   children: <Widget>[
   ],
  ),
);

Here Container with a height of 56 device independent pixel with an internal padding of 8 pixel both on the left and the right



















=>   Navigator class :--------------------------------------------------------------------
A widget that manage a set of child widgets with a stack discipline.

Many apps have a navigator near the top of their widget hierarchy in order to display their logical history using an Overlay with the most recent visited pages visually on top of the older pages.

=> Overlay class :-
   A Stack of entires that can be maanges independently
   Overlays let independent child widget "float" visual elements on top of other widgets by inserting them into the overlay's Stack. The overlay lets each of these widgets manage their  
   participation using OverlayEntry object.

   => OverlayEntry class
	1) A place in an Overlay that can contain a widget
	2) Overlay entries are inserted into Overlay using the OverlayState.insert or OverlayState.insertAll functions. To find the closest enclosing overlay for a given BuildContext use the
	     Overlay.of function 
	3) An overlay entry can be in at most one overlay at a time. To remove an entry from its overlay call the remove function on the overlay entry.


Using this pattern lets the navigator visually transition from one page to another by moving the widgets around in the overlay. Similarly the navigator can be used to show dialog by 
positioning the widget above the current page.

 => Using the Navigator API
	Mobile apps typically reveal their contents via full-screen elements screens or pages. In Flutter these elements are called routes and they're managed by a Navigator widget.
	
	The navigator manages a stack of Routes object and provides two ways for managing the stack the declarative API Navigator.pages or imperative API Navigator.push and pop.


Diaplying a full-screen route :----------------
Althoughyou can create a navigator directly, it's most common to use the navigator created by the Router which itself is created and configured by a WidgetsApp or a MaterialApp widget.

A MeterialApp is the simplest way to set things up. The MaterialApp's home becomes the route at the buttom of the Navigator's Stack. It is what you see when the app is launched

void main(){
	runApp(MaterialApp(home: MyAppHome()));
}

To push  a new route on the stack you can create an instace of MaterialPageRoute with a builder function that creates whatever you want to appear on the screen.

 =>  Navigator.push(context, MaterialPageRoute( builder : (context) => SecondScreen()));

The route defines its widget with builder function instead of a child widget because it will build and rebuilt in different cntexts depending on when it's pushed and popped.

new route can be popped revealing the app's home page with the Navigator's pop method
	
	Navigator.pop(context);

It's usually isn't necessary to provide a widget that pops the Navigator in a route with a Scaffold because the scaffold automatically adds back button to its AppBar. Pressing the back button
causes Navigator.pop to be called. On Android pressing the system back button does the same thing.


Routes can return a value :------------------------
When a route is pushed to ack the user for a value , the value can be returned via the pop methods result parameter. 
Methods that push a route return a Future. The Future resolves when the route is popped and the Future's value is the pop method result parameter.

if we wanted to ask the user to press 'OK to confirm an operation we could await the result of Navigator.push

bool value = await Navigator.push(context, MaterialPageRoute<bool>(
  builder: (BuildContext context) {
    return Center(
      child: GestureDetector(
        child: Text('OK'),
        onTap: () { Navigator.pop(context, true); }
      ),
    );
  }
));

if the user  presses OK then value will be true. If the user block out of the route for example by pressing the Scaffold's back button the value will be null.
When a route is used to return a value the route's type parameter must match the type of pop's result. That's why we've used.


Popup routes :---------------------------
Routes don't have to obscure the entire screen PopupRoutes cover the screen with a ModalRoute.barrierColor that can be only partially opaque to allow the current screen to show through.
Popup routes are modal because they block input to the widget below.

There are functions which create and show popup routes. For example showDialog, showMenu and showModalBottomSheet. These function return their pushed route's Future as described
above. Callers can await the returned value to take an action when the route is popped.

There are also widgets which create popup route like PopupMenuButton and DropdownButton. These widgets create internal subclasses of PopupRoute and use the Navigator's
push and pop methods to show and dismiss them.


Custom routes :-----------------------------
you can create your own subclass on one of the widget library route clases like PopupRoute, Modal Route or PageRoute to control the animated transition employed to show the route the
color and behaviour of the route's modal barrier and other aspect of the route.

The Page RouteBuilder class makes it possible to define a custom route in terms of collbacks.


Navigator.push(context, PageRouteBuilder(
  opaque: false,
  pageBuilder: (BuildContext context, _, __) {
    return Center(child: Text('My PageRoute'));
  },
  transitionsBuilder: (___, Animation<double> animation, ____, Widget child) {
    return FadeTransition(
      opacity: animation,
      child: RotationTransition(
        turns: Tween<double>(begin: 0.5, end: 1.0).animate(animation),
        child: child,
      ),
    );
  }
));


Nesting Navigators :---------------------------------
An app can use more than one Navigator , Nesting one Navigator below another Navigator can be used to create an inner journey such as tabbed navigator.












17:38 28-11-2020
What are Future Operations ?
Future operations are the operations which take time to perform and return the result later. To handle this problem, we use Asynchronus functions.

2.






Facebook with Login Problem in Flutter :------------------------------

[dart] The method 'logInWithReadPermissions' isn't defined for the class 'FacebookLogin'

Solution :-  if you are using flutter_facebook_login version above 2.0.1 change the fblogin.loginWithReadPermission(['email','public_profile'])  with fbLogin.**logIn**(['email', 'public_profile']) The Future function has been renamed to just logIn(List permissions)


Exploring Draggable and DragTargets :---------------------------------
Draggable and DragTarget allows us drag a widget across screen.


Draggable :----------------------
A Draggable makes a widget movable around the screen.

Draggable(
  child: WhiteKnight(
    size: 90.0,
  ),
  feedback: WhiteKnight(
    size: 90.0,
  ),
  childWhenDragging: Container(),
)


There are three main parts to the Draggable widget:
1. Child : The child parameter is the widget that will be displayed when the draggable is stationary
2. Feedback : The feedback is the widget that will be displayed when the widget is being dragged.
3. Child When Dragging: The childWhenDragging parameter takes the widget to display in the original place of child when the widget is being dragged.


=> Restricting motion for Draggabled
Setting the axis parameter helps us restrict motion in one dimension only.
Axis.horizontal makes the feedback widget on y move in the horizontal axis.


=> Adding data to Draggable
Data can be attached to a Dragable. This is useful to us since we use Draggable and DragTargets.

Draggable(
  child: WhiteKnight(
    size: 90.0,
  ),
  feedback: WhiteKnight(
    size: 90.0,
  ),
  childWhenDragging: Container(),
  data: [
    "White",
    "Knight"
  ],
)



Callbacks :-----------
The draggable widget supplies callbacks for actions on the widget. These callback are:

onDragStarted : This is called when a drag is sarted on a widget.

onDragCompleted : When a draggble is dragged to DragTarget and accepted this callback is called. We will look at DragTarget is in the nest section.

onDragCancelled : When a draggable does not reach a DragTarget or is rejected this callback is Fired.

DragTarget :----------------------------------------
While a Draggable allows a widget to be dragged a Dragtarget provides a destination for the draggable.

bool accepted = false;
DragTarget(builder: (context, List<String> candidateData, rejectedData) {
  return accepted ? WhiteKnight(size: 90.0,) : Container();
}, onWillAccept: (data) {
  return true;
}, onAccept: (data) {
   accepted = true;
},),

Builder
The Builder build the actual widget inside the DragTarget. This function is called everytime a Draggable is hovered over the DragTarget or is dropped onto it.
This function has three parameters, context, candidateData and rejectData.

candidateData is the data of a Draggable whilst it is hovering over the DragTarget ready for acceptance by DragTarget. 

rejectData is the data of a Draggable hovering over a Dragtarget at moment it is not accepted.

onWillAccept :---------------------
onWillAcept is a function which gives us the Draggable data for us to decide whether toaccept or reject it.

DragTarget(
  // ...
  onWillAccept: (data) {
    if(data == "Knight") {
      return true;
    } else {
      return false;
    }
  },
)


onAccept => 
If the Draggable is dropped onto the DragTarget and onWillAccept returns true then onAccept is called.
onAccept also gives us the data of the Draggable and is usually used for storing the Draggable dropped over DragTraget.

onLeave =>
onLeave is called when  a Draggable is hovered iver the DragTarget and leaves without deing dropped.










Introduction to the Transform widget: ----------------------------------

A Transform widget 'transform'  (ie changes the shape size position and orientation) its child widget before painting it .
This is expremely useful for custom shapes and many different kinds of animations in Flutter.
This can be used to transform any widget and distort it to any shape we like or move it around as well.


Exploring the types of transform widget :---------------------------------------------
Common operations such as scaling rotation or translation are all provided via constructors.

The types of Transform widgets are 
1. Transform (default constructor)
2. Transform.rotate
3. Transform.scale
4. Transform.translate


=> Transform.rotate 
As the name suggests Transform.rotate simply rotates the child by an angle.  Here the child is square container	

Transform.rotate(
  angle: 1.0,
  child: Container(
    height: 200.0,
    width: 200.0,
    color: Colors.pink,
  ),
)


The angle parameter lets us set an angle (in radius) the child will be rotate by.
The widget also allows us specify an origin for the rotation of our widget. We specify the origin using the origin parameter. This takes an Offset
The Offset notes the distance of the origin in relation to the center of the child itself.
When we don't need explicitly set the offset however the child rotates around its own center.



Tranform.scale =:------------------------------------------------
The scale consructor scales the child by the given scale parameter.
Transform.scale(
  scale: 0.5,
  child: Container(
    height: 200.0,
    width: 200.0,
    color: Colors.yellow,
  ),
)

Here we set the scale to 0.5 to reduce the size of the cotainer by half.
Similarly to the rotation transform we can also set an origin in scalling.



Transform.translate :-----------------------------------------------
Transform.translate translatees the child of the transform widget by a specific amount in the X and Y direction.
We supply an Offset which  has the amount by which  we want to move the child by in the X and Y directions.


Transform.translate(
offset: Offset(100.0, 0.0),
  child: Container(
    height: 100.0,
    width: 100.0,
    color: Colors.yellow,
  ),
)



Transform (Default constructor)
Unlike the other constructor in the list , the default constructor allows us to do multiple operations at once. It is the most powerful constructor from the list.
Instead of taking a specific parameter like an angle or scaling this constructor takes a 4D Matrix directly in the transform parameter. This allows us to carry out multiple operations.
Transform(
  transform: Matrix4.skewY(0.3)..rotateZ(3.14 / 12.0),
  origin: Offset(50.0, 50.0),
  child: Container(
    height: 100.0,
    width: 100.0,
    color: Colors.blue,
  ),
)





Flutter Visibility :------------------------------------------------------------------------
When it come to manage your widget visibility in Flutter, you have many options. Flutter provides us with some cool widgets for this purpose. 

1) Use Opacity widget

Opcaity(
	opacity:0.0,
	child:Container(
		child:child
	)
)

This widget  simply sets  the child's opacity to zero but still renders it. So the child it hidden but take space and you can interact with it.



2) Offstage widget :-------------------------------------------------------

Offstage(
	offstage:true,
	child:child(
	)
);

Offstage renders the child widget off set the screen. This means that the widget is not rendered in the subtree and so doesn't take any space.


3) Use Visibility

Visibility(
	visibility:false
	child:child(
	)
);

Here child widget is not rendered in the subtree and Flutter uses instead a shrinked sized box to replace it. the result is pretty much the same as with Offstage..







Start thinking Declaratively :----------------------------------------------------
If you're coming to Flutter from an impretive framework (such as Android SDK or IOS UIKit) you need to start thinking about app development from a new prespective.

Many assumption that you might have don't apply to Flutter. For example in Flutter it's okay to rebuild parts of your UI from scratch instead of modifying it. Flutter is fast enough to do that 
even on every frame if needed.

Flutter is declarative. This means that Flutter builds its user interface to reflect the current state of your app:

When the state of your app change (for example the user flips switch in the setting screen), you change the state and that triggers a redraw of the user interface. There is no imperative 
changing of the UI itself ( like widget.setText ) you change the state and the UI rebuilds from scratch.

The declarative style of UI programming has many benefits. Remarkably there is only one code path for any state of the UI. you describe what that UI should look like for any given state 
once and that is it.

In the broadest possible sense the state of an app is eveything that exist in memory when the app is running. This includes the app's assets, all the variable that the flutter framework keeps 
about the UI animated state textures fonts ans so on.
While this broadest possible definition of state is valid it's not very usefult for architecture an app.


Ephemeral State :-----------------------
Ephemeral state (sometimes called UI state or local state) is the state you can neatly contain in a single widget
This is intentionally a vague definition so here are a few examples.

current page in PageView
current progress of a complex animation
current selected tab in a BottomNavigationBar


App state :------------------------------------
State that is not ephemeral that you want to share across many parts of your app, and that you want to keep between user sessions is what we call application state (sometimes also called shared state).

Examples of application state :
User preferences
Login Info
Notifications in a social networking app
The Shopping cart in an e-commerce app
Read/unread state of articles in a newsapp




Widget in Flutter are categorized into two categories :
1) Stateless widget
2) Stateful widgets

The Simple difference between the two is that the data (State) that is used in creating the Stateful widget can change. Data in a Stateless widget can't

Example of Stateless widget :-
class StatelessButton extends StatelessWidget {
@override
Widget build(BuildContext context) {
     return Text("HI!");
    }
}

we notice that nothing is really changing inside the Widget object and if we try to defined variable inside the class 

String _name  = "Adnan" ;

Flutter would warn us that :
This class  (or a classwhich this class inherits from ) is marked as  '@immutable' but one or more of its instance fields are not final.

which means that the variable we defined it useless as it won't contribute to the future state of the widget.

Stateful widget on the other hand can have variable that could contribute in the future state of the widget.


A little extra thing that helps with this process is the State class 
=> you might wonder why StatefulWidget and State are separate objects. In Flutter these two types of object have different life cycles.

=> Widget are temporary object used to construct a presentation of the application in its current state.

=> State object on the other hand are persisitent between calls to build(), allowing them to remember information.

=> the build method calls a method  ( setState() ) that inside we do the modification on the state variables.

=> after the setState method is executed the Widget object is replaced with a new one having the modified variable values.

when the RaisedButton is pressed setState is triggered and run which change the _name variable. This variable is then used to create a new updated widget object.



Why a declarative UI ?
Framwork from win32 to web Android and iOS typically use an impretive style of UI programming. This might be the style you're most familier with where you manually construct a full-functioned UI entity such as UIView or equivalent and later mutate it using method and setters when the UI changes.

In order to lighten the burden on developers from having to program how to transition between variaous UI states, Flutter by contrast lets the developer describe the current UI state and leaves the transitioning to the framwork. this is however requires a slight shift in thinking for manipulating UI.





What is the difference between AbsorbPointer and IgnorePointer in Flutter ?
The difference is when we have two widget overlapping each other that can both receive clicks
Consiber a red and blue square clicable where the blue square is smaller and on the top of the red square:


By default without IgnorePointer / AbsorbPointer tapping blue send a click event on blue and red gets nothing.

In that situation wrapping blue square into an AbsorbPointer means that when tapping the blue zone neither the blue square nor the red one gets the click event.

If we instead used an IgnorePointer the red square would receive click event when taping the blue square.



Ignore Pointer :-------------------------
When ignoing is true this widget (and its subtree) is invisible to hit testing. It still consumes space during layout and paints its child as usual.It just cannot be the target of located events it returns false from the RenderBox.hitTest.

AbsorbPointer Class :-----------------------------
When absorbing is true this prevent its subtree from receiving pointers events by terminating hit testing at itself. It still consumes space during layout and paints its child as usual:
It just prevents its children from being the target of located events because it returns true from RenderBox.hitTest.




Flutter provides some really amazing widgets out of the box which comes pre-built for handling touch events sych as in InkWell and InkResponse. These widgets wrap your widgets so that they are able to respond to touch events. In addition to doing this it also adds the Material Ink splash and widget. InkResponse for example has options to control the shape and clipping of the splash as it extends out of the widget boundary. 

AN interesting thing to note is InkWell and InkResponse don't do any rendering instead they update the parent Material widget . Acommon example of this is an image if you wrap an image is an inkWell you would notice that the ripple is not visible. This is because it is drawn behind the image on the Material.


 To make the Ink splash visible, wrap your image using Ink.Image. 

=> They both provide many common feature like onTap, onLongPress etc. The main difference is GestureDetector provides more controls like dragging etc. on the other hand it doesn't  include ripple effect tap which InkWell does.

=> You can use either of them according to your needs you want ripple effects go with InkWell need more controls go with GestureDetector or even combine both of them.




BoxFit enum :--------------------------
How a box should be inscribe into another box.

Constants :-----------------------

1) contain    const BoxFit
As large as possible while still containing the source entirely within the target box.

2) cover    const  BoxFit
As small as possible while still covering the entire taeget box.

fill const BoxFit
3) fill Fill the target box by distorting the source's aspect ratio

4) fitHeight
Make sure thefull height of the source shown regardless of whether this means the source overflows the target boc horizontally.


RichText :-----------------------------------------------
The RichText widget display text that uses multiple different styles. The text to display is described using a tree of TextSpan objects each of which has an associate style that is used for that subtree. The Text might break across multiple lines or might all be displayed on the same line depending on the layout constraints breakacross multiple lines or might all be displayed on the same line depending on the layout constrains.






To add customcolor in flutter
To convert the colors code in dart ( from hexadecima to integer)

color: Color(int.parse('#000000'.replaceAll('#', '0xff')))




Working with futures : async and await :----------------------------------

The async and wait keywords provides a declarative wat to define asynchronous and use their results.
=> To define an async function add async before the function body.
=> The await keyboard works only in async functions.

Example => Here's an example that convert main() from a synchronous function.
First add the async keyboard before the function body.

void main() async{

}

if the function has declared return type then update the type to be Future<T> where is the type value that the function returns if the function doesn't explicitly return a value then the return type is Future<void>

Future<void> main() async{
}


Now that you have as async function you can use the await keyboard to wait for a function to complete.

print(await createOrderMessage());


The asynchronous example is different in three ways :-
1) The return type for createOrderMessage() changes from String to Future<String>
2) The async keyword appears before the function bodies for createOrderMessage() and main()
3) The await keyword appears bfore calling the asynchronous functions fetchUserOrder() and createOrderMessage()



Key terms :----------------
async  :- you can use the aysn keyword bfore a functions body to mark it as asynchromous.
async function :- An async function is a function labeled with the async keyword.
await you can use the await keyword ot get the complete result of an asynchronous expression. The await keyword only works with in async functions.

Execution flow with async and await :-------------------------------
An async function runs synchronously until first await keyword.This means that within an async function body all synchronous code bfore the first await executes immediately.




FloatingActionButton :------------------------------------------
Flutter offers two types of FloatingActionButton out-of-the-box.
1) FloatingActionButton
2) FloatingActionButton.extended



FlaotingActionButton :-
The default constructor creates a simple circular FAB with a child widget inside it. It takes an onPressed method to react to taps and a child (not compulsory) to display a widget inside the FAB.

The code is relatively straightforword and is most often used with the floatingActionButton parameter of the Scaffold widget.


2) FlaotingActionbutton.extended
FloatingActionButton.extended offers awide FAB usually with an icon and a label inside it.

Instead of a child parameter we now have label and icon parameters.

FloatingActionButton.extended(
onPressed:(){},
icon:Icon(Icons.send),
label:Text('Send')
}






initState() is a method of class State and it is considered as an important lifecycle method in Flutter initState() is called only Once and we use it for one time initializations.





How do i lay out my widget? Where is my XML layout file?

In Android you write layouts in XML but in Flutter you write your layouts with a widget tree.
The following example shows how to display a simple widget widget with padding:

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text("Sample App"),
      ),
      body: Center(
        child: MaterialButton(
          onPressed: () {
	//do something on button pressed.
          },
          child: Text('Hello'),
          padding: EdgeInsets.only(left: 10.0, right: 10.0),
        ),
      ),
    );
  }



How do i use a Canvas to draw/paint ?
In Android you would use the Canvas and Drawable to draw images and shapes to the screen. Flutter has a similar Canvas API as well since it is based on the same low-level endering engine,Sika. As a result painting to a acanvas in Flutter is a very familiar task for Android developers.

Flutter has two classes that help you draw to the canvas: CustomPaint and CustomPainter the latter of which implements you algorithm to draw to the canvas.



Intents :------------------------------------------
What is the equivalent of an intent in Flutter ?
In Android there are two main use cases for Intents: navigation between Activities and communicating with components. Flutter on the other hand does not have the concept of intent, 
although you can still start intents through native integrations (using a Plugin)

Flutter doesn't reslly have a direct equivalent to activies and fragment rather in Flutter you navigate between screens using a Navigator and Routes all within the sameActivity.

A route is an abstraction for screen or page of an app, and a Navigator is a widget that manages routes. A route roughly maps to an Activity but it does not carry the same meaning. 
A navigator can push and pop routes to move from screen to screen. Navigatiors work like a stack on which you can push() new routes you want to and from which you can pop() 
routes when you want to go back.

In Android you declare your activies inside the app's Manifest.xml
In Flutter you have a couple options to navigate between pages"
1) Specify a Map of route names (using MaterialApp)
2) Directly navigate to route (using WidgetApp)


The following example builds a Map.
void main() {
 runApp(MaterialApp(
   home: MyAppHome(), // becomes the route named '/'
   routes: <String, WidgetBuilder> {
     '/a': (BuildContext context) => MyPage(title: 'page A'),
     '/b': (BuildContext context) => MyPage(title: 'page B'),
     '/c': (BuildContext context) => MyPage(title: 'page C'),
   },
 ));
}


Navigate to a route by pushing its name to the Navigator.
Navigator.of(context).pushNamed('/b');



What is Equivalent of OkHttp on Flutter?
Making a network call in Flutter is easy when you use the popular http package.
While the http package doesn't have every feature in OkHttp, it abstract away much of the network that you would normally implenting yourself, making it a simple want to make network
calls:

To use the http package add it yo your dependencies in pubsec.yaml:

dependencies:
	
	http: ^0.11.3+16

to make a network call await to the async function http.get():

import 'dart:convert';

import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;
[...]
  loadData() async {
    String dataURL = "https://jsonplaceholder.typicode.com/posts";
    http.Response response = await http.get(dataURL);
    setState(() {
      widgets = json.decode(response.body);
    });
  }
}




How do i show the progress for a long runnng task?
In Android you would typically show a ProgressBar view in your UI while executing a long running task on a background thread.
In Flutter use a progressIndicator widget. Show the progress programmatically by controlling when it's rendered through a boolean flag. Tell Flutter to update its state before your long running task starts and hide it after it ends.

In the following example, the build function is separated into three different functions. If showLoadingDialog() is true (when widgets.length == 0), then render the ProgressIndicator. Otherwise, render the ListView with the data returned from a network call.



Project structure & resources :-------------------------------------
Where do i store my resolution-dependent image files?

While Android treats resources and assets as distinct items Flutter apps have only assets. All resource that would live in hte res/drawable folder on Android are placed in an assets folder for Flutter.

Flutter follows a simple density-based format like iOS. Assets might be 1.0x, 2.0x, 3.0x, or any other multiplier. Flutter doesn’t have dps but there are logical pixels, which are basically the same as device-independent pixels. The so-called devicePixelRatio expresses the ratio of physical pixels in a single logical pixel.

Android density qualifier	Flutter pixel ratio
ldpi			0.75x
mdpi			1.0x
hdpi			1.5x
xhdpi			2.0x
xxhdpi			3.0x
xxxhdpi			4.0x

Assets are located in any arbitray folder Flutter has no predefined folder structre.You declare the assets (with location ) in pubsec.yml file and Flutter picks them up.


val flutterAssetStream = assetManager.open("flutter_assets/assets/my_flutter_asset.png")


Where do i store string? How do i handle localization?
Flutter currently doesn't have dedicated resources line system for string. At the moment the best practice is to hold your copy text in a class as static field and accessing them from there

class Strings {
  static String welcomeMessage = "Welcome To Flutter";
}


Then in your code you can access your string as such:
Text(Strings.welcomeMessage)


How do i listed to Android activity lifecycle events ?
In Android you can override methods from the Activity to capture lifecycle lifecycle methods for the activity itself or register ActivityLifeCycleCallback on the Applction. In Flutter you have neither cocept but you can instead listen to lifecycle events by hooking into the widgetBinding oberver and listening ot the didChangeAppLifeCycleState() change event.

The observable lifecycle events are:

inactive — The application is in an inactive state and is not receiving user input. This event only works on iOS, as there is no equivalent event to map to on Android.
paused — The application is not currently visible to the user, not responding to user input, and running in the background. This is equivalent to onPause() in Android.
resumed — The application is visible and responding to user input. This is equivalent to onPostResume() in Android.
suspending — The application is suspended momentarily. This is equivalent to onStop in Android; it is not triggered on iOS as there is no equivalent event to map to on iOS.



layouts :------------------------------
What is the equivalent of a Linearlayout?

In Android a LinearLayout is used to lay your widget out linearly either horizontally or vertically. InFlutter use the Row or Column widget to achieve the saem result.


What is the equivalent of RelativeLayout?
A RelativeLayout lays your widget out relative to each other. In Flutter there are a few ways to achieve the same result.
you can achieve the result of RelativeLayout by using a combination of Column Row and Stack widget.



What is the Equivalent of a  ScrollView?
In Android use  a ScrollView to layout your widget if the user's device has a smaller screen than your content it scrolls.

In Flutter the easiest way to do this is using the ListView widget. this might seem like overkill coming from Android but in Flutter a ListView widget is both ScrollView and an Android ListView.
@override
Widget build(BuildContext context) {
  return ListView(
    children: <Widget>[
      Text('Row One'),
      Text('Row Two'),
      Text('Row Three'),
      Text('Row Four'),
    ],
  );
}


How do i handle landscape transition in Flutter?
FlutterView handles the config change if AndroidManifest.xml contains:

android:configChange = "orientation | screenSize"

 


=> Chaging widget in response to input :---------------------------------------------------
So far this page has only stateless widgets. Stateless widget recevice argument from their widget. which only store in final member variables. When a widget is asked to build(), it use these stored values to derived new argument for the widget it creates.

In order to build more complex experience for example to react in more interesting ways to user input applications typically carry some state. Flutter uses StatefulWidgets to capture this idea. 


setState(){

}

setState() function tells Flutter framework that something has changed in this State which cause it to rerun the build method below so that the display can reflect the update values. if we change some value without calling setState values then the build method won't be called again, and so nothing would appears.



What is Scaffold ?
A Scaffold Widget provides a framework which implements the basic material design visual layout structure of the flutter app. It provides APIs for showing the drawer snack bars and bottom sheets. Have a look at its constructor and the properties it has.










Add the visible widget to the layout widget ;--------------------

All layout widget have wither of the following:
=> child property if they take a single child    for example Center or Container
=> A chilren property if they take alist of widgets  for example Row , Column , ListView , Stack.



Material Apps :-
For a Material app you can use a Scaffold widget it provides a default banner background color and has API for Adding drawer snack bars and bottom sheets.


Non-Material apps :------------------------
For a non-Material app you can add the Center widget to the app's build() method.

By default a non Metrial app doesn't include an AppBar, title or background color. If you want these feature in non-Material app you have to build them your self.



Layout multiple widget vertically and horizontally :--------------------------------------
One of the most common layout pattern is to arrange widget vertically or horizontally. You can use Row widget to arrange widgets horizontally and column widget to arrange widget vertically.


Row and Column are two of the most commonly used layout patterns.
Row and Column each take a list of child widgets.
A Child widget can itself be a row column or other complex widget.
 To create a row or column in Flutter you add a list of Children widget to Row or Column widget . In turn each whild can itself be a row or column and so on.



Alignning widgets :-------------------------------
You control how a row or column align its children using the mainAxisAlignment and crosAxisAlignment properties.

Fow a row the main axis runs horizontally and the cross axis runs vertically. For a column the main runs vertically and the cross axis runs horizontally.


Example =>
Row(
  mainAxisAlignment: MainAxisAlignment.spaceEvenly,
  children: [
    Image.asset('images/pic1.jpg'),
    Image.asset('images/pic2.jpg'),
    Image.asset('images/pic3.jpg'),
  ],
);

in the following example each of the 3 image is 100 pixel wide. the render box (in this case the entire screen) is more than 300 pixels wide so setting the main acis alignment to spaceEvenly divides the free horizontal space evenly between before and after each image.


Sizing widgets :-----------------------------------------
When a layout is too large to fit a device a yellow and black striped pattern appearn along the affected edge. Here is an example of row that is too wide:

Widget can be sized to file within a row or column by using Expanded widget. To fix the previous example where the row of image is too wide for its endex box wrap each image with an Expanded widget.

Row(
  crossAxisAlignment: CrossAxisAlignment.center,
  children: [
    Expanded(
      child: Image.asset('images/pic1.jpg'),
    ),
    Expanded(
      child: Image.asset('images/pic2.jpg'),
    ),
    Expanded(
      child: Image.asset('images/pic3.jpg'),
    ),
  ],
);




Flex :-----------------------------
Perhaps you want a widget to occupy twice as much as space as its sibling. For this use the Expanded widget flex property an integer that determine th fles for a widget. The default flex factor is 1.

Row(
  crossAxisAlignment: CrossAxisAlignment.center,
  children: [
    Expanded(
      child: Image.asset('images/pic1.jpg'),
    ),
    Expanded(
      flex: 2,
      child: Image.asset('images/pic2.jpg'),
    ),
    Expanded(
      child: Image.asset('images/pic3.jpg'),
    ),
  ],
);


Packing Widget :-----------------------------------
By default a row or column occupies as much space along its main axis as possible but if you want to pack the children closely togther set its mainAxisSize to min.


Widget fall into two category : Standdard widget from the widget libraray and specialized widgets from the Material library. ANy app can use the widgets library but only material app can use the Mateiral Components library.



Container :-----------------------------Many layout make liberals use of Container to separate widget passing or to add borders or margin you can change the device background by placing the entire layout into Container and Changing its backgroud color of image.

Container 
=> Add padding margin borders
=. Change background color or image
=> Contains a single child widget but that child can be Row Column or even the root of a widget tree.

GridView :--------------------------Use GridView to layouto widget out as two dimensionally GrideView provides two prefabricated lists or you can build your own custom grid. When a Grid View detect that its content are too long to fit the render box, it automatically scrolls.

Layout widget out in a grid
Detect when the column content exceeds the render box automatically provides scrolling.
Build your own custom grid or use one of the provideing grids:
=> GridView.count
=. GridView.extends


ListView, GridView Widget Inside the Column and Row Causes the Error try to put that inside the Expended  and make the child of the Expended to List, Grid 



=> Avability of context in Flutter Application during it life cycle

Context of a state is available to us from the moment the state loads its dependencies.

At the time build is called context is available to us and is passed as an argument.
Now moving on initState is called before the state loads its dependecies and for that reason no context is available and you get an error for that if you use context in initState. However
didChangeDependencies is called just few mements after the state loads its dependencies and context is available at this moment so here you can use context.

However both of them are called before build is called. Only the difference is that one is called before the state loads its dependencies  and other is called a few moments after the state loads its dependecies.

we can still use context in initState() method its hack buts works all you need to do is sought of delay whatever you will need to execute that has context in it like so:

#override
void initState(){
	Future.delayed(Duration.zero).then((_){
		// you code with context here
	});
	super.initState();
}






In many application you have seen an expansion or collapse view-like the above:

There are two ways of creating an expandable view in flutter

1) ExpansionTile
2) ExpansionPanelList and ExpansionPanel



ExpansionTile :----------------------------------------
 It is simple and useful widget. This widget let you create a collapse or expansion view with features similar to ListTile . It is like LIstTile which will expand on tapping the title.

ExpansionTile has the following attributes similar to List Tile:

=> title : this property lets you choose the Title for ExpansionTile Widget. The title will be the one item that will always be shown to the user. Only upon clicking this title the widget will
expand to revel the contents

=> children : The property holds any number of widgets. It could be a Card ListTile to simple Text. This will be revelead only upon clicking on the Title of the ExpansionTile Widget.

=> leading : Lets you give any Ion/Text before the Title (To the left of the title) Similar to how the ListTile is used this attribute does the same here also.

=> trailing : Let you give any Icon/Text after the Title ( To the right of the title). Similar to how the listtile is used this attribute does the same with the trailing property of the ExpansionTile.

=> backgroundColor : Let you provide the background color to the entire ExpandedTitle. Note that this is not the color of the color of the entireTitle, rather only the ExpandedTile.

Example :-

 ExpansionTile(
                        leading: Icon(Icons.account_circle,color:Colors.pink),
                        title: Text(response[index].name),
                        children: [
                          ListTile(
                            leading: Text(response[index].email),
                          )
                        ],
                      )




ExpansionPanelList and ExpansionPanel :---------------------------------------
Another way to achive the expansion collapse view is by using ExpansionPanelList and ExpansionPanel widget.

ExpansionalPanelList has the following attributes similar to ListTile

=> animationDuraiton :  this property is used to define the time require to expand/collapse

=> children ; this property takes the ExpansionPanel as a Parameter which means ExpansionPanel will be used to create hidden view and header.

=> expansionCallback : this property works whereeverthe view expans/collapse

ExpansionPanel has the following attributes similar to the ListTile.

=> headerBuilder : this property is used to design the visible part of the list or title of the list/row.

=> body : this proprty take the widget we can have any widget to expand and collapse

=> IsExpanded : This property indicate whether the panel is expanded or not.





23:46 06-04-2021

What is the difference between the TextField and TextFormField :---------------------------------

If you don't know what you need then use a TextField. This is the most basic Flutter widget for getting input from a user. It's the one you should master first.

=> TextField
Using a TextField is an eassy way to allow user input 

TextField(
	decoration: InputDecoration(hintText: 'Name')
)

To get the text that the user entered , you can either get notified every time there is a change using onChange: (text)

TextField(
  decoration: InputDecoration(
      hintText: 'Name'
  ),
  onChanged: (text) {
    // do something with text
  },
)

we can use TextEditingController can give you access to the text state.



=> TextFormField
It you find yourself needing to validate user text input before you save it you might consider using a TextFormField 
TextFormField when you are usingit inside of a Form widget (thourh that isn't a strict requirement).






10:58 08-04-2021					Flutter ListView

A ListView in Flutter is linear list of scrollable items. We can use it to make alist of items scrollable or make a list of repeating items.

Exploring the types of the ListView :--------------------------
1) ListView
2) ListView.builder
3) ListView.separator
4) ListView.custom


1 =>  ListView
This is default constructor of the ListView class. A ListView simply takes a list of children and make it scrollable.

ListView(
  children: [
	ItemOne(),
	ItemTwo(),
	ItemThree()
 ]
)

Usually this should be used with a small number of children as the List will also construct the invisible elements in the list and large amount of the elements may render this inefficient.


2 =>  ListView.builder()

The builder() constructor construct a repeating list of items. The constructor takes two main parameters: An itemCount for the number of items in the list and an itemBuilder for constructed
each list item

ListView.builder(
	itemCount: itemCount
	itemBuilder: (context, position) {
		return listItem();
	}
}

The list items are constructed lazily meaning only a specific number of list items are constructed and when a user scroll ahead the earlier ones are destroyed.

Neat trick : Since the elements are loaded laxily and only the needed number of element are loaded we don't really need an itemCount as a compulsory parameter and the list can be infinite



3 => ListView.seperator()
In the seperator() constructor we generate a list and we can specify the seperator between each item

Note that the infinite count discussed in the earlier constructor cannot be used here and this constructor enforces an itemCount.

The Code for this goes as :
ListView.seperated(
	itemBuilder: (context, position){
		return ListItem();
	},
	sparatorBuilder: (context, position){
		return SeparatorItem();
	},
	itemCount: itemCount,
),

This type of list let you dynamically define separator have different types of separator for  different types of items add or remove separator when needed.
This implementation can also be used for inserting other types of elements easily and without any modification to the main list in the middle of the list items.


sperator list length is 1 less than the item list as a separator does not exits after the last element.



3  =>   ListView.custom()
The custom() constructor as its name suggests lets you build ListViews with custom functionality for how the children of the list are built. The main parameter required for this is
SilverChildDelegate which builds the items

The types of SilverDelegates are :---------------
1) SilverChildListDelegate
2) SilverChildBuilderDelegate


SilverChildListDelegate accept a fiect list of children whereas SilverChildBuilderDelegate accept an IndexedWidgetBuilder (The builder function we use)


Exploring ScrollPhysics :---------------------------------
 To control the way scrolling takes place we set the physics parameter in the ListView constructor. the different types of physics are :

1) NeverScrollableScrollPhysics
It renders the list non-scrollable.Use this to disable the scrolling of the ListView completely.

2) BouncingScrollPhysics
BouncingScrollPhysics bounces back the list when the list ends. A similar effect is used on iOS.


3) ClampingScrollPhysics
this isthe default scrolling physics used on Android. the list stops at the end and gives an effect indicating it.

4) FixedExtentScrollPhysics
It will take a ListWheelScrollView which makes a wheel-like list


why does my ListView have space between the list and the outer widget?
	By default a ListView has padding between it and the outer widget to remove it set padding to EdgeInsets.all(0.0)





11:41 08-04-2021   						How to solve naming conflict or ambigous import 

Two or more package/libraries have the same class name. you import those package in the same dart files
The compiler is unable to understand which package/libraries is should use. It feels ambigous then it throw a kind or error like this.

Compiler message: 'Element' is imported from both
'package:flutter/src/widgets/framework.dart' and
'package:html/dom.dart'.


There are two solution 

1) Hide all conflict classes from particular libraries that you don't use so that the compiler only sees the class it should use.
 
import 'package:flutter/src/widgets/framework.dart' hide Element;
import 'package:html/dom.dart';



2) Use "as" keyword to provide the name to the class you want to use , then use this name as a prefix of the class(es)

import 'package:flutter/src/widgets/framework.dart';
import 'package:html/dom.dart' as dom;








Writing Custom Platform-specific code :---------------------------------------------

Flutter  uses a flexible system that allow you to call platform-specific APIs available in kotlin or java code on Android, or in Swift or Objective-C code on ios.

Flutter's buitin platform-specific API support does not rely on code generation but rather on a flexible message passing style.

=> The Flutter portion of the app sends messages to its host the IOS or Android portion of the app over a platform channel
=> The host listens on  the platform channel and receives the message. It then calls into any number of platform-specific APIs using the native progamming languages and send a response
back to the client the Flutter portion of of the app.

Messagea and response are passed asynchronously to ensure the user interface remains responsive

On the client side MethodChannel enables sending messages that correspond to method calls. On the platform side MethodChannel on Android (MethodChannelAndroid) and FlutterMethod
Channel on IOS (MethodChanneliOS) enable receiving method calls and sending back a result. These classes allow you to develop a platform lugin with very little biolerplat code.





=> Create the Flutter platform client

First construct the channel , User a MethodChannel with a single platform emthod that returns the battery level.
The client and host sides of a channel are connected through a channel name passed in the channel constructor. All the channel names used in a single app must be unique,


import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
...
class _MyHomePageState extends State<MyHomePage> {
  static const platform = const MethodChannel('samples.flutter.dev/battery');

  // Get battery level.
}


Next invoke a method on the method channel specific the concrete method to call using the String identifier getBatteryLevel. The call might fail for example if the platform does not support
the platform API (such as when running in a simulator) so wrap the invokedMethod call in try-catch statement.


  // Get battery level.
  String _batteryLevel = 'Unknown battery level.';

  Future<void> _getBatteryLevel() async {
    String batteryLevel;
    try {
      final int result = await platform.invokeMethod('getBatteryLevel');
      batteryLevel = 'Battery level at $result % .';
    } on PlatformException catch (e) {
      batteryLevel = "Failed to get battery level: '${e.message}'.";
    }

    setState(() {
      _batteryLevel = batteryLevel;
    });
  }


=>   Adding an Android platform-specific implementation
Open MainActivity.kt of Android Side file
	Inside configureFlutterEngine() method create MethodChannel and call setMethodCallHandler(). Make sure to use the same cahnnel name as was used on the Flutter client side.


import androidx.annotation.NonNull
import io.flutter.embedding.android.FlutterActivity
import io.flutter.embedding.engine.FlutterEngine
import io.flutter.plugin.common.MethodChannel

class MainActivity: FlutterActivity() {
  private val CHANNEL = "samples.flutter.dev/battery"

  override fun configureFlutterEngine(@NonNull flutterEngine: FlutterEngine) {
    super.configureFlutterEngine(flutterEngine)
    MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL).setMethodCallHandler {
      call, result ->
      if (call.method == "getBatteryLevel") {
        val batteryLevel = getBatteryLevel()

        if (batteryLevel != -1) {
          result.success(batteryLevel)
        } else {
          result.error("UNAVAILABLE", "Battery level not available.", null)
        }
      } else {
        result.notImplemented()
      }
    }
  }
}


add the Platform specific code to get the level of the battery

  private fun getBatteryLevel(): Int {
    val batteryLevel: Int
    if (VERSION.SDK_INT >= VERSION_CODES.LOLLIPOP) {
      val batteryManager = getSystemService(Context.BATTERY_SERVICE) as BatteryManager
      batteryLevel = batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY)
    } else {
      val intent = ContextWrapper(applicationContext).registerReceiver(null, IntentFilter(Intent.ACTION_BATTERY_CHANGED))
      batteryLevel = intent!!.getIntExtra(BatteryManager.EXTRA_LEVEL, -1) * 100 / intent.getIntExtra(BatteryManager.EXTRA_SCALE, -1)
    }

    return batteryLevel
  }


Channel and platform threading :-----------------------------
Invoke all channel method on the platform's main thread when writing code on the platform side. On Android this thread is sometimes called the "main thread" but it is technically defines
as the UI thread. Annotate method that need be run on the UI thread with @UiThread.

Jumping to UI thread in Android :-
To comply with cahnnel's UI thread reqirement you may need to jump from background thread to Android's UI thread to execute a channel method. In Android this is accomplished by 
post() ing a Runnable to Android'UI thread Looper, which cause the Runnable to execute on the main thread at the next opportunity.


Handler(Looper.getMainLooper()).post {
  // Call the desired channel message here.
}

=> Running Android task in background threads.
All Android apps use a main thread to handle UI operations. Calling long- running operations from this main thread can lead to freezes and unresponsiveness. For example if youe app makes
a network request from the main thread, your app's UI is frozen untilit receive the network response. you can create additional background threads to handle long-running operations
while the main continues to handle UI unpdates.




=> What is the difference between the dependencies and dev_dependencies in Flutter pubspec.yaml

dependencies  => are packages that are included in your app during compilation 

dev_dependencies => are packages that you use during developing your app and these are not included in the APK. 
(these are only required for development or which are used to build your bundle)



=> what happen when execute flutter pub get command
On executing flutter pub get inside your project root folder to makethese new dependencies available in your project








=> Json and Serialization

=> jsonDecode(jsonString)
Decode the JSON by calling the jsonDecode() function with the JSON string as the method argument and returns a Map<String,dynamic> meaning that you do not know the typesof the
values until runtime.


Map<String, dynamic> user = jsonDecode(jsonString);

print("Howdy, ${user['name']}');
print('We sent verification link to ${user['email']}');



Inside the User Class, you'll find

1) A User.fromJson() constructor for constructing a new User instance from map Structue.
2) toJson() method which converts a User instance into a map.


class User{
final String name;
final String email;

User(this.name, this.email);

User.fromJson(Map<String, dynamic> json)
	: name = json['name'],
	:  email = json['email'];

Map<String, dynamic> toJson() => 
{
	'name' : name,
	'email' : email,
};
}

With this new approach you can decode a user easily


Map userMap = jsonDecode(jsonString);
var user = User.fromJson(userMap);

print(user.name);
print(user.email);


To encode a user pass the User object to the jsonEncode() function. You don't need to call the toJson() method, since jsonEncode() already does it for you.

String json = jsonEncode(user);







01:37 13-04-2021  New Button and Button Themes :----------------------------------------
A new set of basic material button widgets and themes have been added to flutter. The original classes have been deprecated and will eventually be removed. The overall goal is to make 
button more flexible and easier to configure via constructor parameters or themes.


The FlatButton, RaisedButton and OutlineButton widgets have been replaced by TextButton, ElevatedButton and OutlinedButton respectively.
Each new button has its own theme: TextButtonTheme, ElevatedButtonTheme and OutlinedButtonTheme







FittedBox Widget :------------------------------------------
FittedBox is a very useful widget that scales and positions its child within itself according to fit and alignment

FittedBox restrict its child widgets from growing its size beyond a certain limit. It rescales them according to the size available. For instance if the text is displyed inside a container and
the text is grow bryond its allocated size FittedBox wat it then it fit the text according to the size available. For large string it would shrink its size hence would fit in the container.


FittedBox({
	key: key,
	fit: BoxFit.contain,
	alignment: Alignment.center,
	child: 
})




MediaQuery :------------------------------------------------------------
 	(( There are multiple ways to make your UI responsive in Flutter but just to name a few rules of thumb that will mostly get the job done. ))

MediaQuery : Establish a subtree in which media queries resolve to the given data.
MediaQueryData : Information about a piece of media (eg a window)

Using MediaQuery we can get the different device screen property like size / width / height  / devicePixelRatio  / 

1) devicePixelRatio 		var _devicePixelRatio = MediaQuery.of(context).devicePixelRatio;
2) deviceWidth 		var _deviceWidth = MediaQuery.of(context).size.width
3) deviceHeight		var _deviceHeight = MediaQuery.of(context).size.height
4) statusBarHeight		var _toolBarHeight = MediaQuery.of(context).padding.top
5) height of the AppBar	MediaQuery.of(context).kToolbarHeight
6) height of BottomNavigatioBar	MediQuery.of(context).kBottomNavigationBarHeight


we can also get the different portion of the screen in ratio or in percentage:

SizedBox(
	height: MediaQuery.of(context).size.height * 0.5	=> it will take 50% of the height of the screen
	width: MediaQuery.of(context).size.width* 0.5	=> it will take 50% of the width of the screen
)



Flex :-------------------------------------
By using Flex widgets such as Expanded and Flexible. When used in a Row or Column they'wll dynamically adapt based on the  costrints imposed by them and along with Column and Row
alignment/size they are qiote powerful enough to make your UI responsive.

For example you can have a two Container in one Row where one uses 1/4 of the view and the other takes 3/4 of the space available.

Row(
  children: <Widget>[
         Expanded(
           flex: 1,
           child: Container(),
         ),
         Expanded(
           flex: 3,
           child: Container(),
         ),
      ]
)


Platform :-------------------------------------
Also you can always lookup for the underlying platform to make some decision by using the Platform class getters

import 'dart:io';

if(platform.isAndroid){
	print('Running of Android Device');
}else{
	print('Running of iOS Device');
}








15:04 04-05-2021

Adding Image to Marker BitmapDescriptor :----------------------------------


 BitmapDescriptor myIcon;
  BitmapDescriptor originMarker;
  BitmapDescriptor dropMarker;
  BitmapDescriptor stopMarker;
  BitmapDescriptor stopMarker1;
  BitmapDescriptor stopMarker2;
  BitmapDescriptor stopMarker3;

  void setOriginMarker() async {
    originMarker = await BitmapDescriptor.fromAssetImage(ImageConfiguration(size: Size(20.0, 20.0)),'assets/images/new_marker.png');
    dropMarker = await BitmapDescriptor.fromAssetImage(ImageConfiguration(size: Size(20.0, 20.0)),'assets/images/des_marker.png');
    stopMarker = await BitmapDescriptor.fromAssetImage(ImageConfiguration(size: Size(20.0, 20.0)),'assets/images/markerImage.png');
    stopMarker1 = await BitmapDescriptor.fromAssetImage(ImageConfiguration(size: Size(64, 64)),'assets/images/stop_marker_1.png');
    stopMarker2 = await BitmapDescriptor.fromAssetImage(ImageConfiguration(size: Size(64, 64)),'assets/images/stop_marker_2.png');
    stopMarker3 = await BitmapDescriptor.fromAssetImage(ImageConfiguration(size: Size(64, 64)),'assets/images/stop_marker_3.png');
    //drawMarker();
  }


setOriginMarker(); ///////////call this method in initState()




















Hero Widget   ;-----------------------------------------------------------
Animate a widget across screens

It's often helpful to guide users through an app they navigate from screen to screen. A Common technique to lead users through an app is to animatea widget from one screen to next.
This creates a visual anchor connecitng the two screens.

Use the Heor widget to animate a widget from one screen to next.

The hero animation is a powerful built-in animation to convery an action by automatically animating a widget from one page to another to the correct size and position. When you navigate 
back to the previous page the Hero animates back to the original position. Each Hero tag must be unique and match on both the originating and landing pages.



This receipe uses the following steps:

1. Creates two screen showing the same image
2. Add a hero Widget to the first screen
3. Add a Hero Widget to the screen.


1. Create two screen showing the same screen

import 'package:flutter/material.dart';

class MainScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Main Screen'),
      ),
      body: GestureDetector(
        onTap: () {
          Navigator.push(context, MaterialPageRoute(builder: (_) {
            return DetailScreen();
          }));
        },
        child: Image.network(
          'https://picsum.photos/250?image=9',
        ),
      ),
    );
  }
}

class DetailScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: GestureDetector(
        onTap: () {
          Navigator.pop(context);
        },
        child: Center(
          child: Image.network(
            'https://picsum.photos/250?image=9',
          ),
        ),
      ),
    );
  }
}



2. Add a hero widget to the first screen
To connect the two screen together with an animation, wrap the Image on both screen in a Hero widget. The Hero widget requirestwo arguments:

tag => An object that identifies the Hero it must be the same on the both screens

child => The widget to animated across screens

Hero(
  tag: 'imageHero',
  child: Image.network(
    'https://picsum.photos/250?image=9',
  ),
)



3. Add a Hero widget to te second screen
To complete the connection with the first screen wrap the Image on the second with a Hero widget that has the same tag as the Hero in the first screen
After applying the Hero widget to the second screen the animation between screen just works

Hero(
  tag: 'imageHero',
  child: Image.network(
    'https://picsum.photos/250?image=9',
  ),
)



import 'package:flutter/material.dart';

void main() => runApp(HeroApp());

class HeroApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Transition Demo',
      home: MainScreen(),
    );
  }
}

class MainScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Main Screen'),
      ),
      body: GestureDetector(
        onTap: () {
          Navigator.push(context, MaterialPageRoute(builder: (_) {
            return DetailScreen();
          }));
        },
        child: Hero(
          tag: 'imageHero',
          child: Image.network(
            'https://picsum.photos/250?image=9',
          ),
        ),
      ),
    );
  }
}

class DetailScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: GestureDetector(
        onTap: () {
          Navigator.pop(context);
        },
        child: Center(
          child: Hero(
            tag: 'imageHero',
            child: Image.network(
              'https://picsum.photos/250?image=9',
            ),
          ),
        ),
      ),
    );
  }
}
