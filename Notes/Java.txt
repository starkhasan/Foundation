
                                                                        ------------------------------------::  JAVA ::----------------------------------------

	Software :------------

Computer Software is often called as software is a set of instruction and its associated documentations that tells a computer what to do  or how to perform a task


	System Software :-----------

System software includes the operating system and all the utilities that enable the computer to function


	Application Software :-----------

It includes  programs that do real work for user . example => word processors, spreadsheets, and database management  system fall under the category of application software.




=> The Birth of Modern Programming Language :-------------------------------------
The C language shook the compiter world. Its impact should not be underestimated because it fundamentally changed the way programming was approached and thought about. The creation of C was direct result of the need for a structured efficient high-level language that could replace assembly code when creating programs. As you probably know when a computer language is designed trade offs are often made such as the followings :---------------

1) Ease of use versus power
2) Safety versus efficiency
3) Rigidity versus extensibility 



Computer language innovation  and development occurs for two fundamental reasons:
=> To adapt to changing enviroment and uses
=> To implement refinements and improvements in the art of programming

Java's Linkeage :-
java is realated to C++ which is a direct descendant of C. Much of the character of  java inherited from these two language.
From C java derived its syntex Many of java object-oriented feature were influenced by C++.


What is Java ?
Java is high-level, class-based, object oriented programming lanaguage.\nJava was developed by Sun Microsystems (which is not subsidiary of Oracle) in 1995 by the Father of java James Gosling.
\nBefore its name was Oak.





	The History and Evolution of Java :---------------------

Somewhere surprisingly the original impetus for java was not the Internet! Instead the primary motivation was the need for a platform-independent (that is architecture-neutral) language 
that could be used to create software to be embedded in various consumer electronic  devices, such as microwave ovens and remote controls.

The second force was ofcourse the World Wide Web (WWW).


Platform :- Any Hardware or Software enviroment in which a program runs, is known as a platform.


	Platform Independence :---------------

Platform independence in software means that you can run some code with little or no modification on multiple platform
it is important to note that some language are platform independent at source code level ( C / C++ is good example ) but loose platform independency once the code is compiled (since native code is platform specific). java retains platform independence even after code is compiled because it compiles to platform independence bytecode.

While you execute Java programs, they are interpreted by a program named as Java Run-time Environment (JRE) which is platform dependent in nature. Here I consider  the term platform as a combination of underlying hardware and operating system. There are different JREs for different platforms. For example I can run the same  Java program within my PC (  windows + Pentium 4 processor),  laptop( Linux + Core i3 processor) and Raspberry Pi (Linux + ARM) without even recompiling. This is not the case for other languages without a virtual machine associated with them. An example will be Turbo C. The Turbo C compiler will produce a platform dependent executable so that you have to compile them for each platform. While in the case of java compiler (javac), it will produce byte codes instructions within class files that can be executed (interpreted + JIT compilation) by JRE which is present within target platform.
How platform independence helps software developers



=====================================

The Java SDK (JDK) provides enough generalization so that you don't have to worry about the underlying hardware  and software layers. We say that Java is platform independent because the java source files and the byte code that is generated by compiling them doesn't care about the platform that you are going to use them.

In short Java compiler (javac) and byte code interpreter(jre) are platform dependent while the code you write (.java files) and the generated byte code (enclosed in .class files) are platform independent.

=====================================

Question => Difference between Java Components (JRE,JDK,JVM)

	JDK = JRE + Development Tools
	JRE = JVM + Library Classes


	What is JDK JRE and JVM

	JDK :------------

Java Development Kit(in Short JDK) is Kit which provides the enviroment to Develop and execute(run) the java program 

Example:- you (as java Developer ) are developing an accounting application on your machine , so what do you going to need into your machine to develop and run this desktop app? 
you are going to need JDK.

Hence JDK is Kit which include two things 
1) Development Tools (to provide an enviroment to develop your java program) 
2) JRE(to execute your java program) JDK is only used by java Developers



	JRE :------------
Java Runtime Enviroment (to say JRE) is an application package which provides enviroment to only run( not develop) the java program (or application) onto your machine
Example=> counting with the same example after developing your accounting application you want to run this application into your client's machine . 
Now in this case your client only need to run your application into his/her machine so your client should install JRE in-order to run your applicationn into his/her machine.

Hence JRE in only used by them who only wants to run the java program end users your system



	

	JVM :--------------

Java Virtual Machine(JVM) is a very important part of both JDK and JRE because it is contained or inbuilt in both. Whatever java program you run using JRE or JDK goes into JVM and JVM 
is responsible to execute the java program line by line hence it is also known as interpreter . Hence you don't need to install JVM separately into your machine because it is inbuilt into your JDK or JRE installation package.

=====================================


How can we get to know whether java is install or not in our system ?
in CMD just type and enter   < java  > to know where the java install in the system or not


to know which version of java is running in our system
in CMD just type  < java -version > and hit enter

JVM

JVM(Java Virtual Machine) is an abstract machine. It is called virtual machine because it doesn't physically exist.it is a specification that provides runtime environment.

(JVM , JRE and JDK are platform dependent because configuration of each OS are different )

> Java is a programming language that produced software for multiple plateform
> It is high-level Programming Language.
> It is concurrent , class-Based , object oriented.

> Java was conceived by James Gosling, Patrick Naughton, Chris Warth, Ed Frank and Mike Sheridan at Sun Microsystem in 1991.

    (Full Form of SUN is Standford University Network)

> This language was initially called "Oak" but was renamed "Java" in 1995.
> The internet helped catapult Java to forefront of programming by using Applet.
> JVM was designed as an interpreter for bytecode
h
> Java Buzzword
  1)  Simple
  2)  Secure
  3)  Portable
  4)  Object-oriented
  5)  Robust
  6)  Multithreaded
  7)  Dynamic 
  8)  High Performance
  9)  Distributed               ( It is designed for the distributed environment of  internet because it handle TCP/IP protocols ).
10)  Interprete




				                  -------------: Java Evolution :------------


>  Initial relesed of java was nothing short of revolution java 1.0 and  java 1.1
> Java  added support for number of new features such as swing and the collection framework and it enhanced the java virtual machine   (JVM)
> Java 1.4  added the new keyword assert ,chained exceptions, and channel based I/O it also made change in the collection framework and                   networking class
> Java 5 made to java consider the following list of its major new features
    * Generics
    * Annotations
    * Autoboxing and Auto-Unboxing
    * Enumeration
    * Enhanced for loop
    * variable length arguments(varargs)
    * static import
    
> Java 7 contined many new features including significant addition to the language and API libraries
> Java 7 having a list of the language features added by JDK7
    * A string can now control a switch statement
    * Binary integer literal
    * Underscore in numeric literal
    * an extended try statement called try-with-resource

> Java SE 7 made several addition to the java API library.Two important Framework added NIO framework  Fork/Join framework
    * NIO originally stood for New I/O
    * Fork/Join framework provides important support for parallel programming

> Java 8 was released in 18th March 2014

  Some of the important Java 8 features are;

	forEach() method in Iterable interface
	default and static methods in Interfaces
	Functional Interfaces and Lambda Expressions
	Java Stream API for Bulk Data Operations on Collections
	Java Time API
	Collection API improvements
	Concurrency API improvements
	Java IO improvements
	Miscellaneous Core API improvements



> Java 9 is a major release and it has brought us a lot of features for developers.

   Some of the important java 9 features are;

	Java 9 REPL (JShell)
	Factory Methods for Immutable List, Set, Map and Map.Entry
	Private methods in Interfaces
	Java 9 Module System
	Process API Improvements
	Try With Resources Improvement
	CompletableFuture API Improvements
	Reactive Streams
	Diamond Operator for Anonymous Inner Class
	Optional Class Improvements
	Stream API Improvements
	Enhanced @Deprecated annotation
	HTTP 2 Client
	Multi-Resolution Image API
	Miscellaneous Java 9 Features



> Java 10 Released



Some of the important Java 10 features are:-

=>Local Variable type interface(JEP 286) 
			
Similar to JavaScript, Kotlin, and Scala, now Java will also have a var keyword that allows you to declare a local variable without specifying its type. The type will be inferred from context. For example, when you say var name = "Java", the compiler will already know the type is String.

Also note that the var keyword can only be used for local variables, i.e. variables inside methods or code blocks — you cannot use it for member variable declaration inside the class body.


=>Time Based Release version
with the JDK 10 release java has adopted a new release cadence- every six month.


=>Garbage- Collection Interface
This is one of the more interesting and useful Java 10 features. It increases code isolation of different garbage collectors and introduces a clean interface for them.


=>Parallel Full GC for G1

=>Heap Allocation on Alternative Memory Devices
This sounds like a really cool feature. It enables the HotSpot VM to allocate the Java object heap on an alternative memory device, specified by the user.

For example, this feature makes it possible to assign lower priority processes to use the NV-DIMM memory, and instead only allocate the higher priority processes to the DRAM in a multi-JVM environment.

=>Consolidate the JDK Forest Into a Single Repository
This new Java 10 feature is all about housekeeping. It will combine the numerous repositories of the JDK forest into a single repository.

=>Root Certificates
This is another important change Java 10 is bringing. If you remember, JDK 10 was created with the close collaboration with OpenJDK, and this is evident from this feature.

It will provide a default set of root Certification Authorities, making OpenJDK builds more appealing to developers.

It also aims to reduce the difference between the OpenJDK and Oracle JDK builds. Critical security components such as TLS will now work by default in OpenJDK builds


=>Experimental Java-Based JIT Compiler

This is another interesting feature that enables the Java-based JIT compiler, Graal, to be used as an experimental JIT compiler on the Linux/x64 platform.

If you remember, Graal was already added back in Java 9, but now you can enable it with the following JVM arguments:

-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler

If you don't know Graal, it is a new Java-based JIT compiler, which is the basis of an experimental Ahead-of-Time (AOT) compiler.

However, keep in mind that it is in an experimental stage, and you should not use it for production.

=>Thread-Local Handshakes
This Java 10 feature lays the groundwork for improved VM performance by making it possible to execute a callback on application threads without performing a global VM savepoint. This would mean that the JVM could stop individual threads and not just all of them.

There are several small improvements done as part of this feature or JEP 312 to improve VM performance, e.g. some memory barriers have been removed from the JVM and biased locking is improved by only stopping individual threads for revoking biases.

=>Remove the Native-Header Generation Tool
This is another Java 10 feature that focuses on housekeeping. It will remove the javah tool from the JDK, a separate tool to generate header files when compiling JNI code, as this can be done through javac.






=> Why java is not a Pure Object Oriented Programming Language?

A Pure Object-Oriented Programming Language should be true for all the 7 conditions mentioned below:

1. Inheritance

2. Encapsulation/Data Hiding

3. Polymorphism

4. Abstraction

5. All predefined types are objects

6. All operations are performed by sending messages to objects

7. All user defined types are objects

Java generally satisfies almost all the conditions except condition #5 as Java supports some primitive data types like int, float,long etc. Thus, Java is not a pure Object-Oriented Programming Language.





=> Two paradigms 
    All computer program consist of two elements : Code and Data
    there  are two paradigms that governs how a program is constructed.
    1) Process-oriented model
    2) Object-oriented model
 
=> Process oriented model :-
      this approach charcterized a program is constructed as a series of liner steps.
      The process-oriented model can be thought of as code acting on  data
      
     Problem with this approach appear as programs grow larger and more complex 

> Object-oriented model:-
	
	to manage increasing the complexity the second approach object orinted model conceived 

> Abstraction
   * an essential element of the object oriented programming is abstraction
   * they can ignore the details of how the program works , or run it only give the functionality..



> Encapsulation
   It is the mechanism that  binds together code and the data it manipulate and keep both  safe  from outside interface and misuse
   One way to think about encapsulation is as a protective wrapper that prevents the code and data from being arbitrarily accessed by other code    defined outside the wrapper.
    Encapsulation is the act of wrapping up of attributes (represented by data members) and operations (represented by functions) under one                single unit (represented by class)   

	
    Taking real world example
    Suppose you go to an automatic cola machine and request for a cola. The cola machine precessess your request and give the cola
    Here automatic cola vending machine is a class .It contains both data Cola can and operation service machanism and they are     wrapping/integrated under a single unit Cola Vending Machine. This is called Encapsulatsion

    We need not know how the machine is working. This is called Abstraction.
    We can say that Encapsulation is the way of implementing Abstraction.


> Inheritance
   * it is the process by which one object  acquire the properties of another object.this is important because it supports the concept of                         hierarchical classification


> Polymorphism
   * many form


> First program of java


                public class demo
                {
                     public static void main(String [] args) // static public void main(String [] args) // public static void main(String args [])
                      {
                        System.out.println(" Hello,World ! ... ");
                      }
                }



Compiling the Program:-

To compile the Example program execute the compiler , javac specifying the name of the source file on the command line as shown here:

c:\>javac Example.java

The javac compiler creates a file called Example.class that contains the bytecode version of the program.

To Run the program
c:\>java Example

we can also run the java program typing
c:\>java demo.java	=>demo.java is the file name and it will effect the latest code either you change the name of the class after manipulating the modifier of the class.


Explanation:---

> Line begins with the main() methods (It is the entry point of any java program, JVM start the execution of program)
> public,keyword is an access modifier,which allows the programmer to control the visiblity of class member(it can be accessed by outside the       (class in which it is declare)
> static,keyword allows main() to be called without having to instantiate a particular instance of the class.
> in main(), there is only one parameter    String args[]  declares a parameter named args which is an array of instance of the class String
main() is called by JVM ( Java Virtual Machine ) before any object are made
> System is a predefine class that provides access to the system


=> What is the return type of the main() method in java ?
As main() method doesn't return anything its return type is void as soon as the main() method terminates the java program terminated too. Hence it doesn't make any sense to return from 
main() method a JVM can't do anything with the return value.

=> Can we change the return type of main method in java ?
NOOOO  it can't   You can always print stdout from the main method(using System.out.print or System.out.println), but you can't change the return type of main. the main method's return 
type must be void because the java language specification enforces it.


=> Can we override main method in java ?
Well you can call it just lke any other method __ in short main method can be overloaded but cannot be overridden in java . That's all about overloading and overriding main method in java.
Now you Know that its possible to overload main in Java but its not possible to override it , simply because its a static method.

> out is the output stream that is connnected to the console...





=> What is System.out.println ?
System.out.println is a java statement that prints the argument passed into the System.out which is generally stdout

System  ---  is a final class in java.lang package. As per javadoc".....Among the facilities provided by the System class are standard output, Standard input and error output stream access to 
externally defined properties and enviroment variable.


out ----- is a static member field of System class and is of type PrintStream





=> Creating a class in java

     in java methods and method variable (Local variable/stack variable) are always gets executed in the stack memory.

    Whereas instance(object) and instance variable(object variable) is always created in Heap.


=> What is the Difference between Address and Reference
    
     Address is a number which is assign to a memory location whereas Reference is a mechanism to locate the memory location.


=> What is the Difference between Continuous and Contiguous

    Continuous => it is used to specify continuity in the time
    Contiguous => it is used to specify continuity in the space



What is the difference between print() and println()

=> Both method is same except that print() doesn't output a newline character after each call.

=> Atomic elements of Java
   * java program are a collection of  Whitespace, Identifier, Literals comments, Operator, Separator and Keywords

=> Whitespace
   * in java whitespace is  a space, tab or newline.

=> Identifier
   *  identifier  are  used to name many things like classes,variables and method
   *  it may be any  descriptive sequence of uppercase and lowercase latters,numbers,or the underscore and doller sign character
   * identifiers are used for identification purpose

	Some Rules for defining Identifiers :-
	* Identifers start with alphanumeric characters or the underscore  ( _  ) and doller ($) sign.
	* Identifiers cannot start with the digit 
	* Identifiers are case-sensitive
	* Reserved word cannot be used as the identifier name. (there are about 53 reverseed word in java like int,float,while,class,break etc...)

=> Literals 
   Any value that is assign to variable that is called the literals\r\nLiterals can be assigned to any primitive type variable.\r\nIt is the syntactic representation of boolean, character, muneric, or 
string data.
   int a= 10 here 10 is the literals

Types of Lieterals
* Boolean Literals
* Integer Literals
* Floating Point Literals
* Characters Literals
* String Literals
* null Literals

=> Comments
  1)//                            single line comments
  2)/*   */                      multiline comments
  3)/**    */                   documentation comments


=> Separators
   In java there are a few character that are used as separator. the most commonly used separator in java is the semicolon.
   List of the separator:--
   ()   Parantheses
   {}   Braces
   []   Brackets
    ;    Semicolon
    ,    Comma
    .    Period
   ::    Colons


=> Keywords
   Keyword are predefined ,reserved words used in programming that have special meaning to the compiler.keyword can't be used as an    identifier  
   there are about 50 keywords currently define in java language.

abstract	 	assert		boolean	break		byte
case		catch		char	class		const
continue		default		do	double		else
enum		extends		final	finally		float
for		goto		if	implements	import
instanceof		int		interface	long		native
new		package		private	protected		public
return		short		static	strictfp		super
switch		synchronized	this	throw		throws
transient		try		void	volatile		while







 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                                        		ASCII( American Standard Code for Information Interchange )
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

ASCII (American Standard Code for Information Interchange) is the most common format for text files in computers and on the Internet. In an ASCII file, each alphabetic, numeric, or special character is represented with a 7-bit binary number (a string of seven 0s or 1s). 128 possible characters are defined.



ASCII Table
Dec  = Decimal Value
Char = Character

'5' has the int value 53
if we write '5'-'0' it evaluates to 53-48, or the int 5
if we write char c = 'B'+32; then c stores 'b'


	Dec	Char                           		Dec  	Char     	Dec  	Char     	Dec  	Char
	------	-------                           		------     	---------        ------            -------           ------            -------
  	0  	NUL (null)                      	32  	SPACE    	64  	@         	96  	`
  	1  	SOH (start of heading)          	33  	!         	65  	A         	97  	a
  	2  	STX (start of text)             	34  	"         	66  	B         	98  	b
  	3  	ETX (end of text)               	35  	#         	67  	C         	99  	c
  	4  	EOT (end of transmission)          36  	$         	68  	D        	100  	d
  	5  	ENQ (enquiry)                   	37  	%         	69  	E        	101  	e
  	6  	ACK (acknowledge)               	38  	&         	70  	F        	102  	f
  	7  	BEL (bell)                      	39  	'         	71  	G        	103  	g
  	8  	BS  (backspace)                 	40  	(         	72  	H        	104  	h
  	9  	TAB (horizontal tab)            	41  	)         	73  	I        	105  	i
 	10  	LF  (NL line feed, new line)   	42  	*         	74  	J        	106  	j
 	11  	VT  (vertical tab)              	43  	+         	75  	K        	107  	k
 	12  	FF  (NP form feed, new page)    	44  	,         	76  	L        	108  	l
 	13  	CR  (carriage return)           	45  	-         	77  	M        	109  	m
 	14  	SO  (shift out)                 	46  	.         	78  	N        	110  	n
 	15  	SI  (shift in)                  	47  	/         	79  	O        	111  	o
 	16  	DLE (data link escape)          	48  	0         	80  	P        	112  	p
 	17  	DC1 (device control 1)          	49  	1         	81  	Q        	113  	q
 	18  	DC2 (device control 2)          	50  	2         	82  	R        	114  	r
 	19  	DC3 (device control 3)          	51  	3         	83  	S        	115  	s
 	20  	DC4 (device control 4)          	52  	4         	84  	T        	116  	t
 	21  	NAK (negative acknowledge)     53  	5         	85  	U        	117  	u
 	22  	SYN (synchronous idle)          	54  	6         	86  	V        	118  	v
 	23  	ETB (end of trans. block)       	55  	7         	87  	W        	119  	w
 	24  	CAN (cancel)                    	56  	8         	88  	X        	120  	x
 	25  	EM  (end of medium)             	57  	9         	89  	Y        	121  	y
 	26  	SUB (substitute)                	58  	:         	90  	Z        	122  	z
 	27  	ESC (escape)                    	59  	;         	91  	[        	123  	{
 	28  	FS  (file separator)            	60  	<         	92  	\        	124  	|
 	29  	GS  (group separator)           	61  	=         	93  	]        	125  	}
 	30  	RS  (record separator)          	62  	>	94  	^        	126  	~
 	31  	US  (unit separator)            	63  	?         	95  	_        	127  	DEL




 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                                                         DATA TYPES , VARIABLES  AND  ARRAYS
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Variable
The variable is the basic unit of storage. A variable is defined by the combination of an identifier a type and an optional initilizer. In addition all variable have a scope which defines their
visibility and a lifetime.

	Declaring a Variable :----
In java all variable must be delared before they can be used. the basic form of variable declaration is shown here

	type identifier[ =value][,identifier[=value]...];

the type is one of java's atomic types or the name of a class or interface

Example=>
int a,b,c;
int d=3,e,f=5;

byte z=22;
double pi=3.14159;
char x='X'



	Dynamic Initilization :-----

Java allow variable to be initilized dynamically using any expression valid at the time the variable is defined.

class demo
{
	public static void main(String [] args)
	{
		double a=3.0,b=4.0;
		double c=Math.sqrt(a*a + b*b);

		System.out.println("Hypotenuse is  = "+c);
	}
}



What is Datatype ?

Data type specifies the size and type of values that can be stored in an identifier

Java language is rich in its data types.    that are classified into two types

1) Primitive			 =>        Which include integer, character , Boolean and Floating Point
2) Non-Primitive Number		 =>        Which include classes Interface and Array, String 

=> A data type that is primitive such as the long variable actually stores the values

=> Non Primitive  or reference data types  they don't store the value but store a reference to that value.


Java is strongly types language (A strongly-typed programming language is one in which each type of data (such as integer, character, hexadecimal, packed decimal, and so forth) is predefined as part of the programming language and all constants or variables defined for a given program must be described with one of the data types.)

=> Java defines eight primitive types of data.(these are the only reason the java is not a pure object oriented language).
      byte, short , int , long , char , float , double , boolean                                                                                                


										Default Value
   
  Byte             =>   the smallest integer type is byte.this is a signed 8-bit type that has a range from -128 to 127      >>  0
  Short           =>   it is a signed 16-bit type.it has a range from -32768 to 32767                                                                >> 0
   int                =>  it is a signed 32-bit type.that has a range from -2147483648 to 2147483647                                     >>  0
  long             =>   it a signed 64-bit type                                                                                                                                     >>  0L
  char             =>                                                                                                                                                                               >>  'u0000'
  float             =>   it having a 32 bits storage                                                                                                                             >>  0.0f
  double         =>  it having a 64 bits storage                                                                                                                              >>  0.0d
  boolean       =>  it can have only two possible valus true and false                                                                                     >>  false






2) Non-Primitive Number :------------


> Non-primitive data types are not defined by the programmering language but are instead careated by the programmer. They are sometimes called reference variable or object reference since they reference a memory location.

> Non-primitive or reference data types are the most sophisticated member of the data type family.



> Array

An array is a group of same ( Homogeneous ) types variable that are refered to by a common name. Array of any type can be created and may have one or more dimension.

   Declaration of an Array in Java

   int a[] = new int[<size>]
   int[] a = new int[<size>]     //like that

   Example:-
  
   	//Java Array Program
	import java.util.Scanner;
	class demo
	{
   	         public static void main(String [] args)
    	          {
        		Scanner sc=new Scanner(System.in);
        		System.out.println("Enter Size : ");
        		int n=sc.nextInt();

		//Declaration of Array
        		int a[]=new int[n];             //int[] a=new int[n]       //both are same
        		System.out.println("Enter the Element in the Array : ");
        		for(int i=0;i<n;i++)
        		a[i]=sc.nextInt();

        		//Insertion Sort

        		int i=0,key=0;
        		for(int j=1;j<n;j++)
        		{
            		key=a[j];
            		i=j-1;
            		while(i>=0 && a[i]>key)
            		{
                		a[i+1]=a[i];
                		i-=1;
            		}
            		a[i+1]=key;
        		}

        		for(i=0;i<n;i++)
        		System.out.print(" "+a[i]);

        		sc.close();
                            }
                 }
 






	String :----------------

String is sequence of character. But in java a string is an object that represent a sequence of character the java.lang.String class is used to create a string object.

=> In computer programming  a String is traditonally a sequence of character either as a literal constants or as some kind of variable.
(Literal constant is a value such as number , character or sting that may be assigned ot varible or symbolic constant.
	
There are two ways to create a String object:------------

1) By using literal

Java String literal is created by using double quotes 
example =>  String s=''Welcome";

2) By new Keyword

Java string is created by using a keyword "new"
example => String s=new String("Welcome");


	Java String pool :------------ 

Java string pool refers to collection of String which are stored in heap memory . In this whenever a new object is created String pool first check whether the object is already present in the pool or not . If it is present then some reference is returned  to the variable else new object will be created in the string pool and the respective reference will be returned.

example=> String s1="Apple";
	  String s2="Apple";



	
	Java String Method :----------------

1) length()

java string length() method tells the length of the string  it return count of total number of character present in the string.





2) compareTo()  

java string compareTo() method compare the given string with current string It is a method of Comparable interface which is implemented by string class.


Example =>

import java.io.*;
import java.util.Scanner;
class demo
{
	public static void main(String [] args)
	{
		String s1="hello";
		String s2="hello";
		String s3="hemlo";
		String s4="flag";

		System.out.println(s1.compareTo(s2));
		System.out.println(s1.compareTo(s3));
		System.out.println(s1.compareTo(s4));
	}
}


output =>
D:\Hacker\collectionframework>java demo
0
-1
2

this program shows comparison between various string it is notice that

if s1>s2 it return a positive number
if s1<s2 it return a negative number
if s1==s2 it return 0


3) Trim() 
the java string trim() method removes the leading  and trailing  spaces. It checks the unicode value of space character before and after the string . If it exists then removes the space and return the omitted string.


Example =>

class demo
{
	public static void main(String [] args)
	{
		String str=" hello ";
		System.out.println(str+"hello are you");
		System.out.println(str.trim()+"how are you");
		
	}
}


output =>

D:\Hacker\collectionframework>java demo
 hello hello are you
hellohow are you




4) String.valueOf()


This method convert different type of value into string, Using this method you can convert int to String, long to String, Boolean to String, character to String, float to String, double to String

Syntex=>

	public static String.valueOf(boolean b)



5) equalsIgnoreCase()

this method compare two String on the basis of content but it does not check the case like equals() methods . In this method if the character match it return true else false.



class demo
{
	public static void main(String [] args)
	{
		String s1="hello";
		String s2="HELLO";
		String s3="hi";
		System.out.println(s1.equalsIgnoreCase(s2));
		System.out.println(s1.equalsIgnoreCase(s3));
	}
}


Output=>

D:\Hacker\collectionframework>java demo
true
false





=> Difference Between String , StringBuffer , StringBuilderClasses  

1) String 
String is immutable ( once created  can  not be changed ) object . The object created as a String is stored in the Constant String Pool.
Every immutable object in java is thread safe that implies String is also thread safe . String  can not be used by two thread simultaneously. String once assigned can not be changed.

2) StringBuffer
StringBuffer is mutable means one can change the value  of the object. The object created through StringBuffer is stored in the heap. StringBuffer
has the same methods  as the StringBuilder . but each method is StringBuffer is synchronized that is StringBuffer is thread safe.

	Due to this it does not allow two threads to simultaneously access the same method. Each method can be accessed by one thread at a time.

But being thread safe has disadvantage too as the performance of the String  hits due to thread safe property. Thus StringBuilder  is faster than the StringBuffer when  calling the  same methods of each class.

StringBuffer can be converted to string by using toString() method.

StringBuffer demo1=new StringBuffer("Hello");
//The above object stored in heap and its value can be changed  demo1 = new StringBuffer("Bye");


3) StringBuilder
StringBuilder is same as the StringBuffer that is it stores the object in heap and it can also be modified . The main difference between the StringBuffer and StringBuilder is that StringBuilder is not thread safe.
	
 


=> Thread-safe code is code that will work even if many Thread are executing it simultaneously. A piece of code is thread-safe if it only manipulates shared data structure in a manner that guarantee safe execution by multiple thread at the same time.




=> What is the difference between the String.valueOf(Object) and the Object.toString()

 According to the Java documentation String.valueOf() returns if the argument is null then a string equal to null otherwise the value of obj.toString() is returned. 

Also in the case of Object.toString() if the instance is null a NullPointerException will be thrown so argubly it is less safe



 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                                                         Type Conversion Wrapper Class in Java
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  

=> Java Automatic conversion

   When one type of data is assigned to another type of variable, an automatic type conversion will take place if the following two condition met:
   1) the two type are compatible
   2) the destination type is larger than the source type

   When these two condition are met a widening conversion take place.
   ex => int a;
             byte b;
             a=(int)b;
  
   When destination type is smaller than the source type that is called narrowing conversion.
    ex => int a;
              byte b;
              b=(byte)a



Example=>

import java.util.Scanner;
class demo
{
    public static void main(String [] args)
    {
        Scanner sc=new Scanner(System.in);
        Integer a=new Integer(sc.nextInt());
        Integer b=new Integer(sc.nextInt());
        if(a==b){
            System.out.println("This is working");
        }
        else{
            System.out.println("This is not working");
        }

        if(a.equals(b)){
            System.out.println("Second method is working");
        }
        else{
            System.out.println("Second method is not working");
        }

        Integer x=Integer.valueOf(5);
        Integer y=Integer.valueOf(5);
        if(x==y){
            System.out.println("True");
        }
        else{
            System.out.println("False");
        }
        sc.close();
    }
}



Explanation of direct assignment of an literal to an Integer reference is an example of auto-boxing concept where the literal value to object conversion code is ahndeled by the compiler converts Integer a=5   to  Integer a=Integer.valueOf(5);



AutoBoxing =>
The conversion of a primitive value into an object of the corresponding wrapper class is called autoboxing.


Unboxing =>
The conversion an object of a wrapper type to its corresponding primitive value is called unboxing.For Example conversion of Integer to int.






				                ---------------: Wrapper class :--------------


Wrapper class in Java provides the mechanism to convert primitive into object and object into primitive. Since J2SE 5.0 autoboxing and unboxing feature converts primitve into object and object into primitive automatically . The automatic conversion of primitive into object is known as autoboxing and vice-versa unboxing.

The eight classes of java.lang package are known as wrapper classes in java. The list of eight wrapper classes are given below.


	
			Primitive Type				Wrapper Class

			boolean					Boolean
			char					Character
			byte					Byte
			short					Short 
			int					Integer
			long					Long
			float					Float
			double					Double


Example=>  AutoBoxing

class demo
{
	public static void main(String [] args)
	{
		int a = 20;
		Integer i = new Integer(a);	// Now this method hash been deprecated
		Integer i = Integer.valueOf(i);	// Now this is used
		System.out.println(i);
	}
}



Output=>
D:\Hacker\collectionframework>java demo
20




Example =>	UnBoxing


class demo
{
	public static void main(String [] args)
	{
		Integer i=new Integer(3);
		int a=i.intValue();
		int j=a;

		System.out.println(i+" "+a+" "+j);
	}
}



Output=>

D:\Hacker\collectionframework>javac demo.java
Note: demo.java uses or overrides a deprecated API.
Note: Recompile with -Xlint:deprecation for details.

D:\Hacker\collectionframework>java demo
3 3 3





				------------------: How to get the Type of the Variable :-----------------


1) If variable are of the object type Like NonPrimitiveData Types

class demo{
    public static void main(String [] args){
        Integer str=12;					//NonPrimitiveTypes variable 
        System.out.println(str.getClass().getName());		// it will return java.lang.Integer
        int a=12;
        System.out.println(((Object)a).getClass().getName());
    }
}


2) if variable are of the Primitive types 
 int a=12;
float f=2.3f;


class demo{
    public static void main(String [] args){
     
        int a=12;						// Primitive Data types 
        System.out.println(((Object)a).getClass().getName());		// it will return java.lang.Integer

    }
}








				           			----------------: Annotation (Metadata) :------------------

Beginning with JDK5 a new facility was added to java that enables you to embed supplemental information into source file. this information called an annotation does not change the actions of a program Thus, an annotation leaves the semantics of a progam unchanges.

Annotation is created through a mechanism based on the interface. Let's begin with an example.
	Here is the declaration for an annotation called MyAnno:

//A simple annotation type

@interface MyAnno
{
	String str();
	int val();
}

First notice the @ that precedes the keyword interface. this tells the compiler that an annotation type is being declared. next notice the two members str() and val(). All annotation consist solely of method declarations. However you don't provide bodies for these methods.

	Annotation can't include an extends clause. However all annotation types automatically extend the Annotation interface. Thus Annotation is super-interface of all annotaions.It declared within the java.lang.annotation package. It override hashcode(), equals(), and toString() which are defined by object. It also specifies annotationType(), which return a Class object that represent the invoking annotation.



When you apply an annotation you give values to its members For example here is an example of MyAnno being applied to a method

//Annotate a method
@MyAnno(str="Annotation Example", val=100)
public static void myMeth()
{
	//....

This  annotation is linked with the method myMeth(). Look closely at the anootaion syntex. the name of the annotation preceded by an @ is followed by a parenthesis list of member initializations. To give a member a value that member's name is assigned a value. Therefore in the example, the string "Annotation Example" is assigned to the str member of MyAnno.



	Specifying A Retention Policy :--------------------

Before exploring annotation further it is necessary to discuss annotation retention policies. A retentation policy determines at what point an annotation is declared. Java defines three such policies which are encapsulated within the java.lang.annotation.RetentionPolicy enumeration .
They are SOURCE , CLASS, and RUNTIME

=> An annotation with a retention policy of SOURCE is retined only in the psurce file and is discarded during compilation.
=> An annotation with  a retention policy of CLASS is stored in the .class file during compilation .However it is not available through the JVM during run time.
=> An annotation with a retention policy of RUNTIME is tored in the .class file during compilation and is available through the JVM during run time . Thus RUNTIME retention offers the greatest annotation presistence.



 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                                                                              		Operators in Java
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  

=> Java provides a rich operator environment most of its operator can be divided into the following four group:
   
	Arithmetic
   	BitWise
   	Relational
   	Logical

What is the difference between the Relational and Logical Operator?


Relational operator are used to compare the value of two expressions, Relational operators are binary operator because they requires two operands

< 	less than
<=	less than or equal to
>	greater than
>=	greater than or equal to

Logical Operator are used with Boolean value you can combine relational operator using logical operator.

Logical AND ( && )
Logical OR ( || )
Logical NOT ( ! )



=> Arithmetic operators are used in mathematical expression in the same way that they are used in algebra.
 
	 +       Addition
  	 -        Subtraction
 	 *        Multiplication
 	 /        Division
 	 %      Modulas  (it return the remainder of a division operation)
 	 ++     Increment
 	 - -      Decrement
 	 +=     Addition assignment
 	 - =     Subtraction assignment
 	 *=     Multiplication assignment
 	 /=      Division assignment
 	 %=    Modulas assignment


the operator of the arithmetic operators must be of a numeric type.
( += , - = , *= , /= , %= ) these version are considered to be as the compound assignment operator.


=> Bitwise operator can  be applied to the integer types : long, int, short, char and byte
     the following list are:--

   	~          Bitwise unary NOT
   	&         Bitwise AND
   	|           Bitwise OR
   	^          Bitwise exclusive OR
   	>>        Shift Right
   	>>>     Shift Right zero fill 
   	<<       Shift Left
   	&=       Bitwise AND assignment
   	|=         Bitwise OR assignment
   	^=       Bitwise exclusive OR assignment
   	>>=     Shift right assignment
   	>>>=   Shift right zero assignment
   	<<=     Shift left assignment



=> Ternary Operator

The ternary operator is also known as the conditional operator. This operator consists of three operands and is used to evaluate Boolean expression The goal of the operator is to decide which values should be assigned to the variables.

	variable x = (expression) ? value if true : value if false


Example =>
	class demo
	{
		public static void main(String [] args)

		{
			double number=-5.5;
			String result;
			result=(number>0)?"Positive":"Negative";
			System.out.println(number+" is "+result);
		}
	}




=> Unary Operator

The unary Operator require only one operand they perform various operation such as incrementing / decrementing a value by one, negative a expression or inverting a value of a boolean.

example
		result++
		result--
		result=-result



=> Binary Operator

A Binary operator is an operator  that operate on two operand and manipulates them to return a result.

		x+y
		x-y
 




----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
						Control Statement



A programming language used control statements to cause the flow of execution to advance and branch based on change to the state of a program.  

Java's program control statements can be put into following categories
1) Selection
2) Iteration
3) Jump



Selection => Selection statements allow your program to choose different paths of execution based upon the outcome of an expression of or the state of a variable.


Java supports two selection statements if and switch. These statements allow you to control the flow of your program's execution based upon conditions known only during run time

IF  =>
The if statement is java's conditional branch statement. It can be used to route program execution through two different paths. Here is the general form of if statement:

	if(condition) statement1;
	else statement2;

Here each statement may be a single statement or a compound statement enclosed in curly braces (that is block).  The condition is any expression that return a boolean value.
				The else clause is optional

The if work like thisL If the condition is true then statement1 executed. Otherwise statement2 (if it exist) it executed. 

In no case will both statement be executed. For example consider the following:

	int a,b;
	
	if(a<b)
	a=0;
	else	
	b=0;
 

Here if a is less than b then a is set to zero. Otherwise b is set to zero. In no case are they noeth set to zero.


Most Often the expression used to control the if will involve th realational operators. However this is not technically necessary. It is possible to control the if using a single boolean variable as shown in this code fragment:

boolean dataAvailable

if(dataAvailable)
	ProcessData();
else
	waitForMoreData();

Remember only one statement can appear directly after the if or else. If you want to include more statements you'll need to create block as in this fragment:

int bytesAvailable;

if(bytesAvailable>0){
	ProcessData();
	bytesAvailable-=n;
} else
	waitForMpreData();

Here both statements within the if block will execute if bytesAvailable is greater than zero.




Nested ifs :------------------------------
A nested if is an if statement that is the target of another if or else. Nested ifs are very common in programming. When you nest ifs the main thing to remember is that an else statement always refers to the nearest if statement that is within the same block as the else and that is not already
associated with an else


if(i==20){
	if(j<20) a==b;
	if(k>100) c=d;
	else a=c;
} else
a=d;




=> The if-else if Ladder :------------------------------
A common programming construct that is based upon a sequense of nested ifs is the if-else-if ladder. It looks like this:

if(condition)
	statement:
else if(condition)
	statement;
else if(condition)
	statement;
.
.

The if statements are executed from the top down.
As soon as one of the condition controlling the if  is true, the statement associated with that if is executed and the rest of the ladder is bypassed.
if none of the condition is ture then the final else statement will be executed. The final else acts as a default condition that is if all other conditional tests fail, then last else statement is performed.

If there is not final else and all other conditions are false then no action will take place.



.
.






	switch :----------------------------------------------------

The switch statement is Java's multiway branch statement. It provides an easy way to dispatch execution to different parts of your code based on the value of an expression.
As such it often provides a better alternative than large series of if-else-if statements.

General form of switch statement:

switch(expression){
case value 1:
//statement sequence
break;
case value2:
//statement sequence
break;
case valueN:
//statement sequence
break;
default:
break;
}


For version of Java prior of JDK 7 expression must be of type byte short int char or an enumeration. 
Beginning with JDK 7 expression can also be type String. Each value specified in the case statement must be a unique constant expression (such as literal value).

Duplicate case value are not allowed. The type of each value must be compatible with the type of exression.

The switch statement works like this. the value of the expression is compared with each of the value in the case statements. If a match is found the code sequence following that case statement is executed. If none of the constant matched the value of the expression then the default statement is executed.
			However the default statement if optional. If no case matches and no default is present then no further action is taken.

The break statement is used inside the switch to terminate a statement sequence. When a break statement is encountered execution branches to the first line of code that follows the entire switch statement.This has the effect of jusmping out of the switch.









Iteration =>
Iteration statements enable program execution to repeat one or more statements (that is iteration statements form loops)
java's iteration statement are for , while and do-while. 

These statement create what we commonly call loops. As you know a loop repeatedly the same set of instrcutions until a termination condition is met.

while :----------------------
The while loop is Java's most fundamental loop statement. IT repeats a statement or block while its controlling expression is true. Here is the general form 

while(condition)
{
	//body of loop
}




for :--------------------
Beginning with JDK 5 there are two form of the for loop. the first is the traditional form that has been in use since original version of Java. the second is the newer for-each form Both types of for loops are discussed here beginning with the traditional form

Here is the general form of the traditional for statement

for(initialization; condition; iteration){
//body
}

if only one statement is being repeated there is no need for curly braces.










Jump =>
Jump statements allow your program to execute in a nonlinear fashion.

Java support three jump statements break, continue and return. These statements transfer control to another part of your program. Each is examined here.


Using break:
In java the break statement has uses First as you have seen, It terminates a statement sequence in a switch statement. Second it can be used to exit a loop. Third it can be used as civilized form of goto..





 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                                                       			OOPs (Object Oriented Programming Structure)
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
It is also said that OOPS  (Object Oriented Programming System)

Why java is not a pure Object-Oriented Language
Pure object oriented language or complete object oriented language are fully object oriented language which supports or have features which

=> It is a programming paradigms that provides many concept such as Inheritence, Encapsulation ( Data Hiding ), Polymorphism  etc.
=> It is a software develoment methodology that is based on modeling a real-world system.
=> it consist of class and object


// Simula is considered the first object oriented programming language.   (  Ole-Johan Dahl & Kristen Nygaard. )

// Smalltalk is considered the first truly object oriented programming language.   (  )

Object means a real world entity such as a pen,chair,table,computer,watch etc. 

It simplifies the software development and maintenane by providing some concepts:-

1) Object
2) Class
3) Inheritence
4) Polymorphism
5) Abstraction
6) Encapsulation


1) Object
 Any entity that has state(instance variable) and behavior( instance method) is known as an object. For example a chair, pen, table, keyboard, bike,  etc. It can be physical or logical.


It has unique identity.

Example=>

class Student
{

  String name;	//instance variable
  int age;		//instance variable

  public static void main(String [] args)
  {
     Student stu=new Student()	// Creating an object of Student
     System.out.println(name+" "+age);
  }

}


An Object can be defined as an instance of a class. An object contains an address and takes up some space in memory.
Object is created  to call non-static function which are not present inside the main method but present inside the class.

There are different ways we can create the object in java
1) by new Keyword
2) by new Instance() method
3) BY clone() method
4) by deserialization()
5) by factory method()


=> Anonymous object
Anonymous object means nameless. An object which has no reference is known as an anonymous object. It can be used at the time of object creation only

	new <ClassName>();		//anonymous object.



=> Creating multiple object at one time.

	Rectangle r1=new Rectangle(), r2=new Rectangle();





2) Class

A Simple Class :-
Let's begin our study of the class with a simple example. Here is a called Box that defines three instance variable width, height and depth. Currently Box does not contain any methods

class Box{
	doble width;
	double height;
	double depth;
}
As stated a class defines a new type of data. In this case the new data type is called Box. you will use this name to declare object of type Box.
It is important to remember that a class declaration only creates a template it does not create an actual object.

Box mybox  = new Box()  //Creating a Box object called mybox
After this statement executes mybox will be an instance of Box. This it will have physical reality.
As mentioned earlier each time you create an instance of a class you are creating an obejct that contains its own copy of each instance variable defied by the class.






Collection of objects is called class. It is a logical entity.
A class can also be defined as a blueprint from which you can create an individual object. Class doesn't consume any space.

3) Inheritence
When one object acquires all the properties and behaviors of a parent object, it is known as inheritance. It provides code reusability. It is used to achieve runtime polymorphism.

4) Polymorphism
If one task is performed by different ways, it is known as polymorphism.

6) Abstraction
Hiding internal details and showing functionality is known as abstraction. 

7) Encapsulation
Binding (or wrapping) code and data together into a single unit are known as encapsulation. For example capsule, it is wrapped with different medicines.



Java Naming Convention__

class name	should start with uppercase letter and be a noune.g 		String, Color, Button, System, Thread etc.

constants name	should be in uppercase letter. e.g. RED, YELLOW, 		MAX_PRIORITY etc.

interface name	should start with uppercase letter and be an adjective                 e.g. Runnable, Remote, ActionListener etc.

method name	should start with lowercase letter and be a verb e.g. 		actionPerformed(), main(), print(), println() etc.

variable name	should start with lowercase letter e.g. firstName, 		orderNumber etc.

package name	should be in lowercase letter e.g. java, lang, sql, util etc.


CamelCase in java Naming Convention__

Java follows camelcase syntex for naming the class,interface,method and variable.if name is combined with two words,second word will start with uppercase latter always

Eg - actionPerformed() , firstName , ActionEvent , ActionListener 





 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
                                                                                                        	 		CLASS AND OBJECTS
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

What is Object?
An object is an entity that has properties for identifying its state, methods or behaviour.
>Anything which is having state and behaviour is object
>Object is created to call non-static methods which are not present inside the main method but present inside the class

> The class is at the core of java .It is the logical construct upon which the entire java language is built because it define the shape and nature of an      object

> Class is template for an object and an object is the instance of an class
> A class is declared by the class keyword
> The data , or variable define within a class but outside the method are called instance variable.
> Collectiviely the methods and variable define within a class are called member of the class.

> Method Variable
   the variable that is declared inside a method that is called the method variable

> Instance Variable
    the variable that is declared inside the class but outside the method is consider as the instance(object) variable.


   class Box
   { 
      double width;
      double height;
      double length;
   }
 

Important =>
 
   > Box mybox=new Box()
   > After this statement execution mybox will be an instance of Box.
      Thus it will have physical reality.As mention earlier ,each time you create an instance of a class,you are creating an object that contains its own         copy of each instance variable defined by the class
  
   > Every Box object will contain its own copies of the instance variable width,height and length.

  =>     Box mybox=new Box
            >Box mybox;                //declare references to object
            >mybox=new Box();   //allocating a Box object
            >new  operator dynamically allocates the memory  for an object and return a reference to it. 
         
      > Thus,every Box object will contain its own copies of the instance variable  width , height and depth.To access these variable,you will use the  dot(.)
      > The dot(.) operator links the name of the object with the name of an instance variable.
 





                                                                               		---------------------:: CONSTRUCTOR ::----------------------
 

=> In Java , a constructor is a block of codes similar to the method. It is called when an instance of the class is created. At  the time of calling constructor memory of the object is allocated 
in the memory.

It is special type of method which is used to initialize the object.
Every time an object is created using the new() Keyword, at least one constructor is called.

=> It called a deafult constructor if there is no constructor available in the class. In such case Java compiler provides deafult  constructor.


=> A constructor initializes an object immediatly upon creation
=> the primary use of constructor is to initilize member of object instance variable
=> It has the same name as the class in which it resides and is syntactically similar to a method
=> Once define ,the constructor automatically called when the object is created
=> In constructor there is no return type, not even void

=>Two type of the constructor

  > Parametrized constructor
  > Non parametrized constructor



Ex=>
import java.util.Scanner;
class demo
{
    demo(int a,int b)
    {
        System.out.println("Yes i am Parametrized : ");
        System.out.println("Sum="+(a+b));
    }
    demo()
    {
        System.out.println("Yes i am Non Parametrized : ");
    }
    public static void main(String [] args)
    {
        Scanner sc=new Scanner(System.in);
        System.out.println("Enter Number : ");
        int a=sc.nextInt();
        int b=sc.nextInt();
        demo d=new demo();
        demo f=new demo(a,b);
        System.out.println("Program Finished");
        sc.close();
    }   
}


Rule :  If there is no constructor in the class than compiler automatically creates a default constructor by the compiler at the compile time
if class contain a constructor than compiler not going to provide the default constructor

(  just type javap <class_name>  )



=> Can you make a constructor final ?
Apply a final keyword to a method means you cannot override that method but by default in java no constructor can be overridden so there is no need to use final keyword with a constructor. A construtor can't inherited so can't overridden, so there is no use of making constructor final.



 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                                                                                 		POLYMORPHISM
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

Polymrophism is an important feature of an object oriented programming
Polymorphism means poly => many   and   morph =>form
When one task is performed by different ways that is known as polymorphism.

Two types of polymorphism

1) Method Overloading (static / Compile time polymorphism)
     
    ( When we have more than one method with same name and different signature that process is known as method Overloading ).


Example=>

import java.util.*;
class Demo
{
    public void sum1(int num1,int num2)
    {
        System.out.println("In Method 1");
        System.out.println("Sum = "+(num1+num2));
    }
    public void sum1(int num1,int num2,int num3)
    {
        System.out.println("In Method 2");
        System.out.println("Sum = "+(num1+num2+num3));
    }
    public static void main(String [] args)
    {
        Demo d = new Demo();
        Scanner sc = new Scanner(System.in);
        int a,b,c;
        System.out.println("Enter the number : ");
        a=sc.nextInt();
        b=sc.nextInt();
        c=sc.nextInt();
        d.sum1(a,b);
        d.sum1(a,b,c);

    }
}


=> Advantages of the Method Overloading:- 
     Method overloading increase the readability of the program.

=> Important Fact About the Method Overloading 
     1) Return type of the method is not the part of the signature
     2) Name of the Parameter is also not the part of the method overloading


    => Constructor Overloading
         when we have more than one constructor with different signature that is consider to be as the constructor overloading. 


Example=>

import java.util.*;
class demo
{
    String name,address;
    int age;
    demo(String name,int age)
    {
        this("Noida");                    //call to this must be first statement in constructor
        this.name=name;
        this.age=age;
    }
    demo(String address)
    {
        this.address=address;
    }
    public void display()
    {
        System.out.println("Name = "+name+" Address = "+address+" Age = "+age);
    }
    public static void main(String [] args)
    {
        Scanner sc=new Scanner(System.in);
        System.out.println("Enter the Name and Age");
        demo d=new demo(sc.nextLine(),sc.nextInt());
        d.display();
    }
}




=> IIB (Instance Initializer Block / Anonymous Block)

It is utility which is provided to java developer by the java compiler to define statements , it is common to all constructor. at the time of compilation.

     syntax
  
     {
       
       statements...
 
     }




=> what is the difference between the constructor and method


                                                     Constructor                                         |                                          Methods
                                                                                                                   |
						|
               it is used for initialize the state of an object                       |                       it is used to expose behaviour of object
					 	|
               it does not have the return type			|	    method must have return type
						|
               it invoke implicitly				|	    it invoke explicitly
						|
               compiler provide default constructor                                  |                      method is not provided by the compiler
						|
               constructor name must be same as the name	|	    method name may or may not be same
               of class                                                 



 

2) Method Overriding (Dynamic / Runtime polymorphism)
    
    ( when we have the same method in the parent class as well as in the child class that process in known as method overriding )
    ( Method overriding is a feature which we will get when we implement inheritance in program ) 

    This is also mentioned as Run - Time Polymorphism , Dynamic binding , Run-Time binding , Late Binding and Method overriding 

    IS-A Relationship

    It is also known as Inheritance
    when there is an extends or implements keyword in the class declaration in java then the specific class is said to be following the IS-A         Relationship.



Advatages of Polymorphism :-

1) Method overriding is used to provide specific implementation of a method that is already provided by the super class
2) Method overriding is used for runtime polymorphism


Example =>

class parent
{
    public void disp()
    {
        System.out.println("Black and white pic : ");
    }
}
class demo extends parent
{
    public void disp()
    {
        System.out.println("Colored Pic : ");
    }
    public static void main(String [] args)
    {
        parent p=new demo();
        p.disp();
    }
}


    Output =>  Colored pic :



Example => 2

//program for method overriding

import java.util.Scanner;
class demo
{
    public void display()
    {
        System.out.println("Yes i am in super class");
    }
}
class demo1 extends demo
{
    public void display()
    {
        super.display();
        System.out.println("Yes i am in derived class");
    }
    public static void main(String[] args) {
    demo1 d=new demo1();
    d.display();    
    }
}



output=>

D:\java program>javac demo.java

D:\java program>java demo1
Yes i am in super class
Yes i am in derived class





Method Hiding:-
if we are overriding the static method then that is treated as the Method Hiding




                             
 

				                ------------------: Final Keyword in java :--------------------

Final keyword are  used before the class , method and before the variable

1) final variable 
 u can't change the value of  final variable(it will be constant)
 we can't override the final method


2) Final method
    we cannot override the final method		

3) Final class  
     final class can't be inherited  		



=> Blank or Uninitilize Final Variable
      a final variable that is not initialized at the time of declaration is known as blank final variable.
      it can only initialilze in the constructor



Example=>

class demo
{
    final int fees;//blank final variable
    demo(int a)
    {
            fees=a;
            System.out.println("Your Fee : "+fees);
    }

    public static void main(String [] args)
    {
        demo d=new demo(4);
    }

}

output=>   4


=> static blank final variable
    a static final variable that is not initialized at the time of declaration is known as static blank final variable.

   it can only be initilized in static init block

Example=>
  
class demo
{
    static final int fees;//blank final variable
    static
    {
        fees=40;
    }
    public static void main(String [] args)
    {
        System.out.println(fees);
    }
}
 
 output=>  40





 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                                                               ABSTRACTION  & INTERFACE
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  

 Abstraction=>  

  Hiding internal details and showing functionality of an object is known as the abstraction.
  abstraction keyword can be used before the class and before the method but we can not used abstract keyword before the variable

 Abstraction Class =>
 abstraction class contains the partial implemention of the method
 abstraction method does not  have  body   they always followed  by semicolon ( ; )
 
 If any abstract method in the class then class must be abstract otherwise it would give a compile time error              //important

 Abstract class can not be called but it can be inherited (Extends).

Example=>

abstract class demo1
{
    public void disp()
    {
        System.out.println("i am in abstract class : ");
    }
    public abstract void disp1();
}
class demo extends demo1
{
        public void disp1()
        {
            System.out.println("I am in the main class but i am full implemented : ");
        }
    public static void main(String [] args)
    {
        
        demo d=new demo();
        d.disp();
        d.disp1();

    }
}


output=>
i am in abstract class :
I am in the main class but i am full implemented :










        					---------------: Interface :----------------


Interfaces are syntactically similar to class but they lack instance variable and their methods are declared without any body.


interface is blueprint of the class
inerface in java is a mechanism to achieve abstraction.
interface can have abstract method and variable
interface is a collection of implicit public abstract method and public static final variable


There are three main reason to use abstraction  :--
1) It is used to achieve abstraction
2) By interface we can support the functionality of multiple inheritance
3) It can be used to achieve loose coupling
4) Interface are used to implement abstraction so the question arises why use interface when we have abstract classes the reason is abstract      classes may contain non-final variable whereas variable in interface are final, public and static.




Example=>

interface printable
{
    public static final int FEES=300;
    public abstract void print();
}
class demo implements printable{
    public void print(){
        System.out.println("Main : ");
    }
    public static void main(String [] args{
        demo d=new demo();
        System.out.println(FEES);
        d.print();
    }
}


output=>
300
Main :




why we use interface
1) It is used to achieve full abstraction
2) by interface we can support multiple inheritence


Example=>

interface printable
{
    public void print();
}
interface showable
{
    public void print();
}
class demo implements printable,showable
{
    public void print()
    {
        System.out.println("Main : ");
    }
    public static void main(String [] args)
    {
        demo d=new demo();
        d.print();
    }
}


output=>

Main :





Example=>

import java.io.*;
interface vechile
{
    //all are abstract method
    void changeGear(int a);
    void speedUp(int a);
    void applyBrakes(int a);
}
class Bicycle implements vechile
{
    int speed;
    int gear;

    //change gear
    @Override
    public void changeGear(int newGear)
    {
        gear=newGear;
    }

    //to increase speed
    @Override
    public void speedUp(int increment)
    {
        speed=speed+increment;
    }

    ///decrease speed
    @Override
    public void applyBrakes(int decrement)
    {
        speed=speed+decrement;
    }

    public void printStates()
    {
        System.out.println("Speed : "+speed+" Gear: "+gear);
    }
}
class Bike implements vechile
{
    int speed;
    int gear;


    //change gear
    @Override
    public void changeGear(int newGear)
    {
        gear=newGear;
    }

    //to increase speed
    @Override
    public void speedUp(int increment)
    {
        speed=speed+increment;
    }

    ///decrease speed
    @Override
    public void applyBrakes(int decrement)
    {
        speed=speed+decrement;
    }

    public void printStates()
    {
        System.out.println("Speed : "+speed+" Gear: "+gear);
    }   
}

class GFG
{
    public static void main(String [] args)
    {
        Bicycle bicycle=new Bicycle();
        bicycle.changeGear(2);
        bicycle.speedUp(2);
        bicycle.applyBrakes(1);


        System.out.println("Bicycle present at state : ");
        bicycle.printStates();

        //create instance of bike

        Bike bike=new Bike();
        bike.changeGear(1);
        bike.speedUp(4);
        bike.applyBrakes(3);

        System.out.println("Bike present state: ");
        bike.printStates();
    }
}


What is tagged interface
an interface that have no any member is known as tagged inerface like Serializable, Cloneable, Remote etc.

Example=>

public interface Serializable
{


}




 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                                                        STATIC KEYWORD & JAVA STATIC METHOD  
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  

					        -----: Static Keyword :-----

=> The static keyword is used in java mainly for the memory management 
=> The static keyword belongs to the class and not to any particular instance ( object ) of the class.
=> Java static keyword is used to create a Class level variable in java. static variables and methods are part of the class, not the instance of the class.


=> static keyword can be used in five cases as show
      1) variable (also known as class variable / static variable)
      2) methods
      3) static inner class
      4) static block
      5) interface static method (Java 8 onward)

=> Advantage of the static variable
      it make ur program memory efficient 

Example =>

class demo
{
    static String name="ali hasan";
    public static void main(String [] args)
    {
        System.out.println("My name = "+name);
    }
}



Program of the counter without static variable :------------------------
Since instance variable gets the memory at the time of the object creation each object will have the copy of the instance variable.If it is increamented it won't reflect other object so each object will have the value 1 in the count variable.

class demo{
    int count=0;
    demo(){
        count++;
        System.out.println(count);
    }
    public static void main(String [] args){
        new demo();
        new demo();
        new demo();
    }
}

=> Now program of counter by static variable.
class demo{
    static int count=0;
    demo(){
        count++;
        System.out.println(count);
    }
    public static void main(String [] args){
        new demo();
        new demo();
        new demo();
    }
}




					-------: Java Static Method :------

=> Same as static variable , static method belongs to class and not to class instances.

    Static method can accesss only static variable of class and invoke only static methods of the class.



  Java static method program: static methods in Java can be called without creating an object of the class.
  Why we write static keyword when defining main method? Because a program execution begins from main and no object has been created yet. 

  Example:-
  import java.util.Scanner;
  class demo
  {
	static void display(int a,int b)
	{
		System.out.println("Hi I am Static block : ");
		System.out.println(a+b);
	}

	public static void main(String args[])
	{
		Scanner sc=new Scanner(System.in);
		System.out.println("Enter The Number : ");
		int a,b;
		a=sc.nextInt();
		b=sc.nextInt();
		display(a,b);
	}
  }



=> why main method is static
      
      Because object is not required to call static method, if it were non static method jvm create object first then call main()


=> Static block
Java static block is the group of statements that gets executed when the class is loaded into memory gets executed when the class is loadede into memory by Java ClassLoader.

1) Static block is used to initialize the static variables of the class.
2) we can't acess the non-static  variables in the static block.
3) Static block code is executed only once when the class is loaded into memory.






					------------: This Keyword in Java :-------------

There can be a lot of usage of java this keyword. In java this is a reference variable that refers to the current object.

Here is given the 6 usage of java this keyword.

=> this can be used to  refer current class instance variable.
=> this can be used to invoke current class constructor
=> this can be passed as an argument in method call.
=> this can be passed as argument in the constructor call.
=> this can be used as the current class instance from the method.








                                                                              ----------------:  Command Line Argument :-------------------

  The command line argument is the argument passed to a program at the time when you run it.
  To access the command-line argument inside a java program is quite easy, they are stored as string in String array passed to the args parameter    of main() method.


Example:-

class demo
{
    public static void main(String [] args)
    {
        System.out.println(args[0]);
        System.out.println(args[1]);
    }
}



// program for addition of two number without taking any variable

class demo
{
    public static void main(String [] args)
    {
        System.out.println("Sum = "+(Integer.parseInt(args[0])+Integer.parseInt(args[1])));
    }
}






 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                                                                     INHERITANCE IN JAVA  
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  

In the terminology of Java, a class that is inherited is called a superclass. The class that does the inheriting is called a subclass. Therefore, a subclass is a specialized version of a superclass. It inherits all of the instance variables and methods defined by the superclass and adds its own, unique elements.




Inherit data member(variable) and methods from another class to use the property of the inherited class

=> the class that inherits the data members and methods from another class known as subclasss (Derived Class).
=> the class from which the subclass inherites is known as superclass (Base class).

=> Inheritance represent the IS-A Relationship 
      IS-A Relationship is known as inheritance when there is an extends or implements keyword in the class declaration in java then the specific       class is said to be IS-A Relationship.



Example=>
//a simple example of inheritance
class A
{
    int i,j;

    void showij()
    {
        System.out.println("i and j : "+i+"  "+j);
    }
}

class B extends A
{
    int k;
    void showk()
    {
        System.out.println("K = "+k);
    }

    void sum()
    {
        System.out.println("i+j+k = "+(i+j+k));
    }
}

class SimpleInheritance
{
    public static void main(String [] args)
    {
        A superob=new A();
        B subob=new B();

        superob.i=10;
        superob.j=20;

        System.out.println("Content of superob : ");
        superob.showij();
        System.out.println();

        subob.i=7;
        subob.j=8;
        subob.k=9;
        System.out.println("Content of subob : ");
        subob.showij();
        subob.showk();

        System.out.println("sum of i j and k in subob : ");
        subob.sum();
    }
}


output=>

D:\java program>javac demo.java

D:\java program>java SimpleInheritance
Content of superob :
i and j : 10  20

Content of subob :
i and j : 7  8
K = 9
sum of i j and k in subob :
i+j+k = 24


As you can see, the subclass B includes all of the members of its superclass, A. This is why subOb can access i and j and call showij( ). Also, inside sum( ), i and j can be referred to directly, as if they were part of B.




	Member Access and Inheritance :--------------------

Although a subclass includes all of the members of its superclass, it cannot access those members of the superclass that have been declared as private. for example consider the following simple class hierarchy:

Example=>

class A
{
    int i;
    private int j;
     void setij(int x,int y)
     {
        i=x;
        j=y;
     }
}

class B extends A
{
    int total;
     void sum()
     {
        total=i+j;
     }
}

class Access
{
    public static void main(String [] args)
    {
        B subob=new B();
        subob.setij(10,12);

        subob.sum();

        System.out.println("Total is = "+subob.total);
    }
}


ouput=>

D:\java program>javac demo.java
demo.java:235: error: j has private access in A
        total=i+j;
                ^
1 error

explanation=>
This program will not compile because the reference to j inside the sum( ) method of B causes an access violation. Since j is declared as private, it is only accessible by other members of its own class.



Example=>

class Box
{
    double width;
    double height;
    double depth;

    Box(Box ob)//construct clone of object
    {
        width=ob.width;
        height=ob.height;
        depth=ob.depth;
    }

    Box(double w,double h,double d)
    {
        width=w;
        height=h;
        depth=d;
    }

    Box()
    {
        width=-1;
        height=-1;
        depth=-1;
    }


    Box(double len)//consructor used when cube is  created 
    {
        width=height=depth=len;
    }

    //computer and return volume
    public double volume()
    {
        return (width*height*depth);
    }
}


class Boxweight extends Box
{
    double weight;
    ///contructor for Boxweight
    Boxweight(double w, double h,double d, double m)
    {
        width=w;
        height=h;
        depth=d;
        weight=m;
    }
}

class demoboxweight
{
    public static void main(String [] args)
    {
        Boxweight mybox1=new Boxweight(10,20,15,34.3);
        Boxweight mybox2=new Boxweight(2,3,4,0.076);
        double vol;

        vol=mybox1.volume();
        System.out.println("Volume of mybox1 is  : "+vol);
        System.out.println("Volume of mybox1 is  : "+mybox1.weight);

        vol=mybox2.volume();
        System.out.println("Volume of mybox2 is "+vol);
        System.out.println("Volume of mybox2 is "+mybox2.weight);
    }
}

output=>
D:\java program>javac demo.java

D:\java program>java demoboxweight
Volume of mybox1 is  : 3000.0
Volume of mybox1 is  : 34.3
Volume of mybox2 is 24.0
Volume of mybox2 is 0.076





	using super :----------------

super has two general forms. the first calls the superclass constructor and second is used to access member of the superclass that has been hidden by a member of a subclass

=> using super to call superclass constructor
a subclass can call a constructor by its superclass by use of the following forms of super :

	super(arg-list):
super must be always be the first statement executed inside a subclass constructor

// BoxWeight now uses super to initialize its Box attributes.

class BoxWeight extends Box {
double weight; // weight of box
// initialize width, height, and depth using super()
BoxWeight(double w, double h, double d, double m) 
{
super(w, h, d); // call superclass constructor
weight = m;
}
}


Example=>
class Box {
private double width;
private double height;
private double depth;
// construct clone of an object
Box(Box ob) { // pass object to constructor
width = ob.width;
height = ob.height;
depth = ob.depth;
}
// constructor used when all dimensions specified
Box(double w, double h, double d) {
width = w;
height = h;
depth = d;
}
// constructor used when no dimensions specified
Box() {
width = -1; // use -1 to indicate
height = -1; // an uninitialized
depth = -1; // box
}
// constructor used when cube is created
Box(double len) {
width = height = depth = len;
}
// compute and return volume
double volume() {
return width * height * depth;
}
}
// BoxWeight now fully implements all constructors.
class BoxWeight extends Box {
double weight; // weight of box
// construct clone of an object
BoxWeight(BoxWeight ob) { // pass object to constructor
super(ob);
weight = ob.weight;
}
// constructor when all parameters are specified
BoxWeight(double w, double h, double d, double m) {
    super(w, h, d); // call superclass constructor
weight = m;
}
// default constructor
BoxWeight() {
super();
weight = -1;
}
// constructor used when cube is created
BoxWeight(double len, double m) {
super(len);
weight = m;
}
}
class DemoSuper {
public static void main(String args[]) {
BoxWeight mybox1 = new BoxWeight(10, 20, 15, 34.3);
BoxWeight mybox2 = new BoxWeight(2, 3, 4, 0.076);
BoxWeight mybox3 = new BoxWeight(); // default
BoxWeight mycube = new BoxWeight(3, 2);
BoxWeight myclone = new BoxWeight(mybox1);
double vol;
vol = mybox1.volume();
System.out.println("Volume of mybox1 is " + vol);
System.out.println("Weight of mybox1 is " + mybox1.weight);
System.out.println();
vol = mybox2.volume();
System.out.println("Volume of mybox2 is " + vol);
System.out.println("Weight of mybox2 is " + mybox2.weight);
System.out.println();
vol = mybox3.volume();
System.out.println("Volume of mybox3 is " + vol);
System.out.println("Weight of mybox3 is " + mybox3.weight);
System.out.println();
vol = myclone.volume();
System.out.println("Volume of myclone is " + vol);
System.out.println("Weight of myclone is " + myclone.weight);
System.out.println();
vol = mycube.volume();
System.out.println("Volume of mycube is " + vol);
System.out.println("Weight of mycube is " + mycube.weight);
System.out.println();
}
}


output=>


D:\java program>java DemoSuper
Volume of mybox1 is 3000.0
Weight of mybox1 is 34.3

Volume of mybox2 is 24.0
Weight of mybox2 is 0.076

Volume of mybox3 is -1.0
Weight of mybox3 is -1.0

Volume of myclone is 3000.0
Weight of myclone is 34.3

Volume of mycube is 27.0
Weight of mycube is 2.0



=> why Inheritance?
      for Method overriding (Runtime polymorphism)

In a class hierarchy when a method in a subclass has the same name and type signature as a method in its super then the method in the subclass is said to override the method in the super class

Example=>
class A
{
    int i,j;
    A(int a,int b)
    {
        i=a;
        j=b;
    }

    public void display()
    {
        System.out.println(" i and j : "+i+" "+j);
    }
}
class B extends A
{
    int k;
    B(int a,int b,int c)
    {
        super(a,b);
        k=c;
    }

    public void display()
    {
        super.display();
        System.out.println("k = "+k);
    }
}

class override
{
    public static void main(String [] args)
    {
        B subob=new B(1,2,3);
        subob.display();
    }
}


When show( ) is invoked on an object of type B, the version of show( ) defined within B is used.

output=>

D:\java program>javac demo.java

D:\java program>java override
 i and j : 1 2
k = 3


If you wish to access the superclass version of an overridden method, you can do so by using super. overridden methods allow Java to support run-time polymorphism.



      for code reusability

Types of Inheritance

1) Single Inheritance
2) Hierarchical Inheritance
3) Multi-level Inheritance
4) Hybrid Inheritance

1) Single Inheritance
when a single subclass is inherited from the single super class is known as single inheritance

2) Hierarchical Inheritance
when more than one subclass is inherited from a single super class is known as Hierarchical Inheritance 

3) Multi-level Inheritance
when a subclass is inherited from another subclass is known as the Multi-level Inheritance


Example=>

class Box
{
    private double width;
    private double height;
    private double depth;

    Box(Box ob)
    {
        width=ob.width;
        height=ob.height;
        depth=ob.depth;
    }

    Box(double w,double h,double d)
    {
        width=w;
        height=h;
        depth=d;
    }

    Box()
    {
        width=-1;
        height=-1;
        depth=-1;
    }

    Box(double len)
    {
        width=height=depth=len;
    }


    double volume()
    {
        return (width*height*depth);
    }
}

class BoxWeight extends Box
{
    double weight;

    BoxWeight(BoxWeight ob)
    {
        super(ob);
        weight=ob.weight;
    }

    BoxWeight(double w,double h,double d,double m)
    {
        super(w,h,d);
        weight=m;
    }

    BoxWeight()
    {
        super();
        weight=-1;
    }

    BoxWeight(double len, double m)
    {
        super(len);
        weight=m;
    }
}

class Shipment extends BoxWeight
{
    double cost;

    Shipment(Shipment ob)
    {
        super(ob);
        cost=ob.cost;
    }


    Shipment(double w,double h, double d,double m,double c)
    {
        super(w,h,d,m);
        cost=c;
    }

    Shipment()
    {
        super();
        cost=-1;
    }

    Shipment(double len, double m, double c)
    {
        super(len,m);
        cost=c;
    }
}

class DemoShipment
{
    public static void main(String [] args)
    {
        Shipment shipment=new Shipment(10,20,15,10,3.41);
        Shipment shipment1=new Shipment(2,3,4,0.76,1.28);

        double vol;

        vol=shipment.volume();

        System.out.println("Volume of Shipment is = "+vol);
        System.out.println("Weight of Shipment is = "+shipment.weight);

        System.out.println("Shipment cost : $"+shipment.cost);
        System.out.println();

        vol=shipment1.volume();

        System.out.println("Volume of Shipment is = "+vol);
        System.out.println("Weight of Shipment is = "+shipment1.weight);

        System.out.println("Shipment cost : $"+shipment1.cost);
        System.out.println();


    }
}

output=>


D:\java program>javac demo.java

D:\java program>java DemoShipment
Volume of Shipment is = 3000.0
Weight of Shipment is = 10.0
Shipment cost : $3.41

Volume of Shipment is = 24.0
Weight of Shipment is = 0.76
Shipment cost : $1.28



4)Hybrid Inheritance
when a more than one subclass is inherited from a single subclass is known as the Hybrid Inheritance

Note:- Multiple Inheritance is not applicable at class level



class A
{
    public void display()
    {
        System.out.println("Main");
    }
}
class B extends A
{
    public void display()
    {
        System.out.println("Child");
    }
}
class demo
{
    public static void main(String [] args)
    {
        A a=new A();
        a.display();
    }
}

output          =>         Main




class A
{
    public void display()
    {
        System.out.println("Main");
    }
}
class B extends A
{
    public void display()
    {
        System.out.println("Child");
    }
}
class demo
{
    public static void main(String [] args)
    {
        A a=new B();
        a.display();
    }
}

output           =>  Child





 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                                                                              Encapsulation
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  
> Encapsulation
   * It is the mechanism that  binds together code and the data it manipulate and keep both safe from outside interface and misuse

    Encapsulation is the act of wrapping up of attributes (represented by data members) and operations (represented by functions) under one                single unit (represented by class)   

	
    Taking real world example :---------------
    
    Suppose you go to an automatic cola machine and request for a cola. The cola machine process your request and give the cola
    Here automatic cola vending machine is a class .It contains both data Cola can and operation service machanism and they are        wrapping/integrated under a single unit Cola Vending Machine. This is called Encapsulatsion

    We need not know how the machine is working. This is called Abstraction.
    We can say that Encapsulation is the way of implementing Abstraction.


=> Technically in encapsulation, the variables or data of a class is hidden from any other class and can be accessed only through any 	      member function of own class in which they are declared.
=> As in encapsulation the data in a class is hidden from other classes , so it is also known as data-hidding
=> Encapsulation can be achieved by declaring all the variable in the class as private and writing public methods in the class to set and get the values of variables.



import java.util.Scanner;
class demo
{
    private String name;
    private int age;
    public void set_name(String name)
    {
        this.name=name;
    }
    public void set_age(int age)
    {
        this.age=age;
    }
    public String get_name()
    {
        return name;
    } 
    public int get_age()
    {
        return age;
    }
    public static void main(String [] args)
    {
        Scanner sc=new Scanner(System.in);
        demo d=new demo();
        System.out.println("Enter name : ");
        String name=sc.nextLine();
        System.out.println("Enter age : ");
        int age=sc.nextInt();
        d.set_name(name);
        d.set_age(age);
        System.out.println("Name : "+d.get_name()+" Age : "+d.get_age());

    }
} 


Advantages of Encapsulation:

=> Data Hiding
The user will have no idea about the inner implementation of the class. It will not be visible to the user that allow the class is storing values in the variable.
=>Reusability
Encapsulation also improve the re-usability and easy to change with new requirements.




 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                                             GARBAGE COLLECTION AND MEMORY MANAGEMENT
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  

=> In java methods and method variable (Local variable/stack variable) are always gets executed in the stack memory. Whereas instance(object) and instance variable(object variable) is always created in Heap.


Java has a automatically memory management, a nice and quite garbage collector that works in the background to clean up the unused objects and free up some memory.
			so knowing how memory actually works in java is important as it gives you the advantage of writing high-performance and optimized applications that will never ever crash with an  [ OutOfMemoryError ].

Generally memory is divided into two big parts the stack and the heap. The heap is a huge amount of memory compared to the stack.


=> Memory is  a key resource an application requires to run efficiently and like any resource it is scare. As such it allocate abd deallocate to and form application or different parts of an application require a lot of care of cosideration.




=> What are the disadvatage of the Garbage Collection?

Yes, Whenever the a garbage collector runs it has an effect on the application performance. this is because all other thread in the application have to be stopped to allow the garbage collector thread to effectively do its work.
								Depending on the requirement of the application this can be real problem that is unaccepted by the client . However this problem can be greatly reduce or even elimited through skilful optimization and garbage  collector tuning and using different GC algorithm. 
		 



Java takes a different approach to deallocating the memory  it handles deallocation for u automatically the techniques that accomplishes     this is called garbage collection (  it works like when no reference to an object exist,that object is assumed to be  no longer needed and     the memory occupied by the object can be reclaimed )

=> In java garbage means unreferenced object
     In other word  it is a way to destroy the unused objects.
    To do so ,we are using free() function in C language and delete in C++.
    in java it is performed automatically 
 
-: Advantage of Garbage Collection :-
=> it makes java memory efficient because garbage collector removes the unreferenced object from heap memory.
=> it is automatically done by the garbage collector (a part of JVM) so we don't need to make extra efforts.

How can an object be referenced?
There are many ways:-
=> by nulling the reference
=> by assigning a reference to another
=> by annonymous object 

How to delete an object in Java?

1) If you want to make your object eligible for Garbage Collection, assign its reference variable to null.

2) Primitive types are not objects. They cannot be assigned null.

Example =>
                       int count=null;    //CTE

Example =>

                     Integer i=new Integer(4);
	  // the new Integer object is reachable  via the reference in 'i' 
                     i = null;
	  // the Integer object is no longer reachable.

Example =>

class Student{
int a;
int b;

  public void setData(int c,int d){
    a=c;
    b=d;
  }
  public void showData(){
    System.out.println("Value of a = "+a);
    System.out.println("Value of b = "+b);
  }
  public static void main(String args[]){
    Student s1 = new Student();
    Student s2 = new Student();
    s1.setData(1,2);
    s2.setData(3,4);
    s1.showData();
    s2.showData();
    //Student s3;
    //s3=s2;
    //s3.showData();
    //s2=null;
    //s3.showData();
    //s3=null;
    //s3.showData();
  }
}


The finalize() method is never invoked more than once for any given object.


=> How to ensure that unused object is released from memory?

finalized() method
this method belongs to the object class invoked each time before the object is garbage collected. the method can be used for cleanup process

//we can not force JVM to call Garbage Collector

class Simple
{
	public void finalize()
	{
		System.out.println("Object is garbage collected");
	}
	public static void main(String [] args)
	{
		Simple s1=new Simple();
		Simple s2=new Simple();
		s1=null;
		s2=null;
	}
}

NOTE => Garbage collector of JVM collects(release) only those objects that are created by new Keyword so if you have created any object without
new , u can use finalize() method to perform cleanup operation (Destroying remaining object).



gc() method
it is used to request to invoked(called) the garbage collector to perform cleanup operation. the method is available in two classes that are:-
1)System
2)Runtime



				--------------: Overloading Methods :------------------

In java it is possible to define two or more methods  within the same class that share the same name,this is the case the methods are said to be overloaded and the process is refered to as method overloading..

> Overloading methods must differ in the type and/or number of their parameters
> While different return type alone is insufficient to distinguish two version of method.

> using object as the parameters

Argument passing
two types:---
1) Call by value           :- this copies the values of an argument into the formal parameter  of the subroutine
2) Call by reference   :- reference to an argument can be passed to the parameter



				   --------------: Overridding Methods :------------------

 => RUNTIME  POLYMORPHISM
 What is Runtime polymorphism ?
 

    In any object-oriented programming language, Overriding is a feature that allows a subclass or child class to provide a specific implementation    of a method that is already provided by one of its super-classes or parent classes. 

    When a method in a subclass has the same name, same parameters or signature and same return type(or sub-type) as a method in its super -    class, then the method in the subclass is said to override the method in the super-class.

    Method overriding is one of the way by which java achieve Run Time Polymorphism.

    Example

// Base Class
class Parent
{
    void show() { System.out.println("Parent's show()"); }
}
 
// Inherited class
class Child extends Parent
{
    // This method overrides show() of Parent
    @Override
    void show() { System.out.println("Child's show()"); }
}
 
// Driver class
class Main
{
    public static void main(String[] args)
    {
        // If a Parent type reference refers
        // to a Parent object, then Parent's
        // show is called
        Parent obj1 = new Parent();
        obj1.show();
 
        // If a Parent type reference refers
        // to a Child object Child's show()
        // is called. This is called RUN TIME
        // POLYMORPHISM.
        Parent obj2 = new Child();
        obj2.show();
    }
}




 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                                                                     			EXCEPTION  HANDLING
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


=> What is Exception in Java ?
     Exception means Abnormal Condition
     In Java, an exception is an event that disrupts the normal flow of the program.

=> What is Exception Handling ?
     Exception Handling is a mechanism to handle runtime errors such as ClassNotFound, IO, SQL, Remote etc.

=> Advantage of the Exceptional Handling ?
     The core advantage of exception handling is to maintain the normal flow of the application. An exception normally disrupts the normal flow of the      application that is why we use exception handling.



                                                                         		--------------: Hierarchy of Java Exception classes :------------

The java.lang.Throwable class is the root class of Java Exception hierarchy which is inherited by two subclasses: Exception and Error. 

Types of Java Exceptions:

1) Checked Exception      => Checked exceptions are checked at compile-time.
     eg => IOException, SQLException ClassNot FoundException etc.

2) UnChecked Exception => Unchecked exceptions are checked at Runtime.
     eg => ArithmeticException, NullPointerException, ArrayIndexOutOfBoundsException etc. 


=> Java is Robust 
it means in java fail proof robustness is given by the exception handler.
because

it is highly supported language. It is portable across many Operating systems. Java also has feature of Automatic memory management and garbage collection. Strong type checking mechanism of Java also helps in making Java Robust.




                                                                              		------------------: Java Exception Keywords :-----------------

Java exception handling is managed via five keywords:
There are 5 keywords which are used in handling exceptions in Java.
1) try
2) catch
3) throw
4) throws
5) finally


This is the general form of an exception handling block:

try
{
//block of code to monitor for error
}
catch(ExceptionType exob)
{
//exception handler for exception type1
}
catch(ExceptionType2 exob)
{
//exception handler for ExceptionType2
}
//.....
finally
{
//block of code to be executed after try block ends
}


	Throwable :----------
Throwable is at the top of the exception class hierarchy . Immediatelt below Throwable are two subclasses that partition exception into two distinct branches:
1) Exception

2) Error
which defines exceptions that are not excepted to be caught under normal circumstances by your program. Exception of type Error are used by the java run-time system to indicate error having to do with the run-time environment itself.

	Stackoverflow is an example of such an error


1) try

Program statement that you want to monitor for exceptions are contained within a try block. If exception occurs with in the try block.
 The "try" keyword is used to specify a block where we should place exception code. The try block must be followed by either catch or finally. It      means, we can't use try block alone.
=> one try  cannot have multiple finally.
=> we cannot write anything between try and catch.
=> a single try block can have many catch block. this is necessary when the try block has statements that raise different type of Exception.


2) catch
  The "catch" block is used to handle the exception. It must be preceded by try block which means we can't use catch block alone. It can be              followed by finally block later.
=>catch is conditional it means it is only exceuted when exception is raised otherwise not.  


3) throw
   The "throw" keyword is used to throw an exception.

4) throws
  The "throws" keyword is used to declare exceptions. It doesn't throw an exception. It specifies that there may occur an exception in the method.     It is always used with method signature.                                                                             

5) finally
   The "finally" block is used to execute the important code of the program. It is executed whether an exception is handled or not.



Example =>

ArithmeticException

import java.util.Scanner;
class demo
{
    public static void main(String [] args)
    {
        Scanner sc = new Scanner(System.in);
        System.out.println("Enter the two number ; ");
        int a = sc.nextInt();
        int b = sc.nextInt();

        try
        {
            int c = a/b;
            System.out.println("Operation performded Successfully : ");
        }
        catch(ArithmeticException e)
        {
          //System.out.println("Can't be Divided by Zero : ");  
          System.out.println(e.getMessage());
        }
    }
}

Notice that the call to println() inside the try block is never executed. Once an exception is thrown program control transfer out of the try block into the catch block. Put differently catch is not "called" so execution never "returns" to the try block from a catch. thus the line "This will not be printed" is not displayed. Once the catch statement has executed progam control continues with the next line in the program following the entire try/catch mechanism.

			A catch statement cannot catch an exception thrown by another try statement (except in the case of nested try statements, described shortly).



	ArrayIndexOutOfBoundException :-------------------- 

If a request for a negative or an index greater than or equal to size of array is made, then the JAVA throws a ArrayIndexOutOfBoundsException. 

import java.util.Scanner;
class demo
{
	public static void main(String [] args)
	{
		Scanner sc=new Scanner(System.in);
		int n=5;
		int a[]=new int[5];
		try
		{
			for(int i=0;i<=5;i++)
				a[i]=sc.nextInt();
			
			for(int i=0;i<5;i++)
				System.out.println(a[i]+" ");
		}
		catch(ArrayIndexOutOfBoundsException ae)
		{
			System.out.println(ae);
		}
	}
}



	Multiple catch :--------------

In some case more than one exception could be raised by a single piece of code. To handle this type of exception you can specify two or more catch claused each catching a different type of 
exception.
After one catch statement executes the other are bypassed and execution continues after the try/catch block. the following example traps two different exception types:



Example=>


class demo
{
    public static void main(String [] args)
    {
        try
        {
            int a=args.length;
            System.out.println("a = "+a);
            int b=42/a;
            int c[]={1};
            c[42]=99;
        }
        catch(ArithmeticException e)
        {
            System.out.println("Divide by 0 : "+e);
        }
        catch(ArrayIndexOutOfBoundsException e)
        {
            System.out.println("Array index oob : "+e);
        }

        System.out.println("After try/catch Exception  : ");
    }
}



Output=>

D:\VS>javac caller.java

D:\VS>java demo
a = 0
Divide by 0 : java.lang.ArithmeticException: / by zero
After try/catch Exception  :

D:\VS>java demo 1
a = 1
Array index oob : java.lang.ArrayIndexOutOfBoundsException: 42
After try/catch Exception  :						



This program will cause a division by zero exception if it is started with no command line argument since a will equal zero. It will survive the division if you provide a command line argument 
setting a to something larger than zero. But it will cause an ArrayIndexOutOfBoundException since the int array c has a lebgth of 1 yet the program attempts to assign a value to c[42]


                                                                                           		-------------: Throwing an Exception  :--------------


=> Throw
     throw is used to explicit exception throwing. it means the throw statement  causes termination of the normal flow of control of the java code and stop the execution of the subsequent 
statement if an exception is thrown when throw statement is executed.

Example=>

import java.util.Scanner;
class demo
{
    public static void main(String [] args)
    {
        Scanner sc = new Scanner(System.in);
        System.out.println("Enter your Age : ");
        int age = sc.nextInt();
        try
        {
            if(age<18)
            {
                throw new ArithmeticException("Invalid Age : ");
            }
            else
            {
                System.out.println("Welcome to Vote : ");
            }
        }
        catch(ArithmeticException ae)
        {
            System.out.println(ae.getMessage());
        }
    }
}



So far you have only been catching exception that are thrown by the java run-time system. However it is possible for your program to throw an exception explicitly using the throw statement.
The general form of throw is shown here:

	throw ThrowableInstance

Here ThrowableInstance must be an object of type Throwable or subclass of Throwable.


Example=>

class demo
{
    static void demoproc()
    {
        try
        {
            throw new NullPointerException("demo");
        }
        catch(NullPointerException e)
        {
            System.out.println("caught inside demoproc");
            throw e;
        }
    }
    public static void main(String [] args)
    {
        try
        {
            demoproc();
        }
        catch(NullPointerException e)
        {
            System.out.println("Recaught  : "+e);
        }
    }
}


Output=>
D:\VS>javac caller.java

D:\VS>java demo
caught inside demoproc
Recaught  : java.lang.NullPointerException: demo



=> Throws
      throws keyword is used to describe (declare) the exception that can be thrown by the method


Example =>

import java.io.*;
class demo
{
    public static void main(String [] args)throws IOException
    {
        BufferedReader b = new BufferedReader(new InputStreamReader(System.in));
        System.out.println("Enter The Number : ");
        int a = Integer.parseInt(b.readLine());
        int c = Integer.parseInt(b.readLine());
        System.out.println("Sum = "+(a+c));
    }
}








 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                                                                          			PACKAGES IN JAVA
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  

Packages are container for classes that are allow you to create a class names List , which you can store in your own package without concern that it will collide with some other class named 
List stored elsewhere. Packages are stored in hierarchical manner and are explicitily imported into new class definitions.

The packages in both a naming and a visibility control mechanism you can define classes inside a package that are not accessible by code outside that packages. you can also define class 
members that are only expose to other members of the same packages.



What is Package?
A Package is a set of classes and interfaces. it use to organize the classes and interfaces

Two types of Packages in java.
1) Pre-define Package
2) User-define Package

Commonly used Pre-define package are as follow:-
1) java.lang
2) java.io
3) java.net
4) java .awt
5) java.util
6) java.awt.event

Note:- java.lang is the default package so there  is no need to import it because it gets automatically imported.

Pre-define package:-
The Math class

1) abs()
    Accepts a parameters of data type such as int, long, float, or double and return the absolute value of that parameter
   
    public static double abs(double x)
    public static float abs(double x)
    public static int abs(double x)

2) ceil()
    Return the smallest double value of the next higher integer.
   
    public static double ceil(double x)

3) floor()
     Return the largest double value of the next smaller integer
     
     public static double floor(double x)

4) max()
     Accepts two arguments and return the largest of the two values of the arguments. the two argument should be of same type

     public static double max(double x,double y)

5) min()
     Accepts two arguments and return the smallest of the two values of the arguments. the two argument should be of same type

     public static double min(double x,double y)

6) round()
     Accepts one arguments and return the integer value closest to the parameter

     public static long round(double x)
	
     public static int round(float x)

7) sqrt()
     Accepts one parameter of data type double and return the positive square root of that parameter
    
    public static void sqrt(double x)







                                                                                              		---------: var Args (Variable Length Argument):---------


This concept was introduced from the jdk 1.5 . The var args allows the method to accept zero or multiple argument.
if we don't know how many argments we will have to pass in the method , var args is the better approach.

Example=>

import java.util.Scanner;
class demo
{
	void sum(int...num)
	{
	   int total=0;
	   for(int result:num)
	   {
	      total+=result;
	   }
	  System.out.println("the sum of number is"+total);
	}
	public static void main(String [] args)
	{
   	    demo obj=new demo();
                       obj.sum();                         //zero argument
                       obj.sum(10,20,30,40);
                    }
}

=> Scanner Class :----------------------
Scanner class in java is found in the java.util.package. Java provides various ways to read input from the keyboard the java.util.Scanner class is one of them. The Java Scanner class breaks the input into tokens using delimeter which is whitesapce by default. It provides many method to read and various primitive values.

The Java Scanner class is widely used to parse text for string and primitive types using a regular expression. It is the simplest way to get input in Java.BY help of Scanner in Java we can get input from the user in primitive types such as int,long double,byte float,short etc.

The Java Scanner class extends Object and implements Iterator and Closable interfaces.

The Java Scanner class Provides nextXXX() methods to return the type of the value such as nextInt(), nextbyte(), next(), nextLine(), nextDouble(), nextFloat(), nextBoolean() etc. To get a single Character  we can call next().charAt(0) method which returns  single character.

Java Scanner Class Declaration :------------

public final class Scanner extends Object implements Iterator<String>

=> How to get Java Scanner
To get the instance of Java Scanner which reads from the user we need to pass the input stream(System.in) in constructor of the Scanner class.

Scanner sc=new Scanner(System.in);


=> Java Scanner class Constructors

Scanner(File Source)	it constrcut a new Scanner that produces values scanned from the specific file.
Scanner(Readable source)	it construct a new Scanner that produces values scanned from the specidfied source.
Scanner(String source)	it constructs a new Scanner that produces values scanned from the specified string.
Scanner(Path source)	it constructs a new Scanner that produces values scanned from the specified file.


=> Use of Delimiter in Scanner class

import java.util.Scanner;
class demo{
    public static void main(String [] args) {
        String input = "1    fish   2    fish red   fish blue fish blue fish";
        Scanner s = new Scanner(input).useDelimiter("\\s*fish\\s*");
        System.out.println(s.nextInt());
        System.out.println(s.nextInt());
        System.out.println(s.next());
        System.out.println(s.next());
        System.out.println(s.next());
        s.close();
    }
}

output=>

D:\Repo\Data_Structure>javac demo.java

D:\Repo\Data_Structure>java demo
1
2
red
blue
blue



import java.io.FileNotFoundException;
import java.util.Scanner;
import java.io.File;
class demo{
    public static void main(String [] args)throws FileNotFoundException {
        File txt=new File("New Text Document.txt");
        Scanner sc=new Scanner(txt);
    
        while(sc.hasNext()){
            System.out.print(sc.next());
        }
        sc.close();
    }
}











           					
                                                                                   		--------: User Define Package / Custom Package :--------



A package which is created by programmer(User) is known as user define package
to create the user define package we use the package keyword whereas to use a package we use the import keyword.

Example=>

package calculator;				//save as demo.java
public class demo
{
   public void add(int num1,int num2)
    {
        int result;
        result=num1+num2;
       System.out.println("sum = "+result);
    }
}					// javac -d . demo.java  ( for comiplation of the package )


import calculator.demo;
public class demo1
{
  public static void main(String [] args)
  {
    demo d=new demo();
    d.add(12,12);
  }
}				             // javac demo1.java  for compile the demo1.java file
              				            // java demo1              for execution

This is general form of the package statement

	package pkg;
Here pkg is the name of the package 

you can create a hierarchy of package . to do so simply separate each package name from the one above it by use of period . the general form of a multileveled package statement is shown 
here:

	package pkg1[.pkg2[.pkg3]]


	Finding package and CLASSPATH :---------------------
How does the java run-time system know where to look for package that you create?

The Answer has three parts:
1) by default the java run-time system used the current working directory as its starting point if your package is in a subdirectory of the current 
directory ot will be found
2) you can specify a directory path or path by setting the CLASSPATH environment variable
3) you can use the -classpath option with java and javac to specify the path to your classes.



	Importing Package :---------------------

Java includes the import statement to bring certain classes, or entire packages, into visibility. Once imported, a class
can be referred to directly, using only its name. The import statement is a convenience to the programmer and is not technically needed to write a complete Java program. If you are going to 
refer to a few dozen classes in your application, however, the import statement will save a lot of typing.

the general form of the import statement:

	import pkg1[.pgk2].(classname|*);

Here pkg1 is the name of a top level package and pkg2 is the name of a subordinate package inside the outer package separated by dot(.) There is no practical limit on the depth of a package
hierarchy except that imposed by the file system.




	Executing the package with more than two class in the same package and java file :---------------------------------------

Example=>

package mypack;
class Balance
{
    String name;
    double bal;

    Balance(String n,double d)
    {
        name=n;
        bal=d;
    }
    void show()
    {
        if(bal<0){
            System.out.println("Zero Balance : ");
        }
        else {
            System.out.println(name+" : $ "+bal);
        }
    }
}
class AccountBal
{
    public static void main(String [] args)
    {
        Balance current[]=new Balance[3];			// creating the balance object using array

        current[0]=new Balance("Ali",123.54);
        current[1]=new Balance("Hasan",432.54);
        current[2]=new Balance("Stark",-123.54);

        for(int i=0;i<3;i++){current[i].show();}
    }
}



Output=>

(base) D:\VS>javac -d . caller.java	// compilation of the package 

(base) D:\VS>javac -d .. caller.java	// compilation of the class file in the package

(base) D:\VS>java mypack.AccountBal	// execution of the main class in package
Ali : $ 123.54
Hasan : $ 432.54
Zero Balance :






                                                   
                                                                                   		----------: Access Specifier / Access Modifier :-----------


Access Specifier defines the scope of type (class and interface) and type member (variable and method)

There are four access specifier
1) private
2) protected
3) public
4) default (no access specifier)/Friendly


1) Private
=> private thing can only accessible only within a class

Example

class demo
{
	private int var=10;
	private void disp()
	{
		System.out.println("Hi");
	}
}
class Tester
{
	public static void main(String [] args)
	{
		demo d=new demo();
		System.out.println(d.var);
		d.disp();
	}
}


2) Default Access Specifier
when we don't use any access specifier that time defult access specifier is automatically used.
Default thing can be accessible anywhere only in the same package.

Example =>
package p1;
class First{
	void display(){
		System.out.println("Package First");
	}
}

package p2;
import p1.*;
class MainClass{
	public static void main(String[] args){
		First obj = new First(); 
		obj.display(); 
	}
} 

//Will get Compile Time Error Because Default Access Specifier can only be accessed in same package.



3)Protected Access Specifier
protected thing is accessible in the same package and outside the package also but outside the package it is accessible only through inheritence



4)public
public thing can be accessible anywhere (except final)





 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                                                                                      		FILE HANDING
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

In java input and output is stream based.

What is stream?
a stream represents sequence of bytes or characters. Stream is just a carrier
Stream is categorized in to two categories
1) Input Stream
2) Output Stream


Input Stream is used to read data
output stream is used to write the data.

In java we have two types of the input and output stream
1) Byte Oriented   (Streams are Byte Oriented)
Byte stream process data byte by byte (8 bits)
A byte stream is suitable for processing raw data like binary files.

2) Character Oriented (Readers are Character Oriented)
In java character are stored using Unicode conventions. Character stream automatically allow us to read/write data character by character. When we want to process text files. These text files 
canbe processed character by character. A character size is typically 16 bit


Commonly used Byte Oriented Stream are:-
1) InputStream
2) OutputStream
3) ByteArrayInputStream
4) ByteArrayOutputStream
5) FileInputStream
6) FileOutputStream
7) BufferedInputStream
8) BufferedOutputStream


Example
import java.io.*;
class demo
{
	public static void main(String [] args)
	{
		try
		{
			FileInputStream fin=new FileInputStream("Raj.txt");
			int ch;
			while(true)
			{
				ch=fin.read();
				if(ch!=-1)
				{
					System.out.print((char)ch);
				{
			}
		}
		catch(Exception e)
		{
			System.out.println(e);
		}
	}
}


 



Commonly used Character oriented stream are:-

Reader	:-   is an abstract class that is extended by all the character oriented InputStream
Write	:-   is an abstract class that is extended by all the character oriented OutputStream

1) CharArrayReader
2) CharArrayWriter
3) BufferedReader
4) BufferedWriter
5) FileReader
6) FileWriter
7) InputStreamReader	// it is used to convert byte oriented stream into character oriented stream
8) OutputStreamWriter	// it is used to convert character oriented stream into byte oriented stream
9) PrintWriter		// it is used as a character oriented version of PrintStream



Example
import java.io.*;
class demo
{
	public static void main(String [] args)
	{
		try
		{
			FileReader fin=new FileReader("Raj.txt");
			int ch;
			while((ch=fin.read())!=-1)
			{
				System.out.print((char)ch);	
			}
		}
		catch(Exception e)
		{
			System.out.println(e);
		}
	}
}




SequenceInputStream
=> SequenceInputStream class is used to read data from multiple file



Enumeration
if we need to read the data from more than two files in that case we need to have these information in the Enumeration
Enumeration is a interface


import java.util.*;
import java.io.*;
class readfile
{
	public static void main(String [] args)
	{
		FileInputStream fin1=new FileInputStream("ali1.txt");
		FileInputStream fin2=new FileInputStream("ali2.txt");
		FileInputStream fin3=new FileInputStream("ali3.txt");
		FileInputStream fin4=new FileInputStream("ali4.txt");

		//creating vector object to all the stream

		Vector v=new Vector();	//Dynamic Array
		v.add(fin1);
		v.add(fin2);
		v.add(fin3);
		v.add(fin4);

		Enumeration e=v.elements();
		SequenceInputStream sis=new SequenceInputStream(e);
		int i;
		while((i=sis.read())!=-1)
		{
			System.out.print((char)i);
		}
	}
}



Serialization



//Java program to access the File

import java.io.*;
class demo
{
    public static void main(String [] args)
    {
        
        File f1=new File("F://MOVIE");
        String[] s1=f1.list();
        int count=0;
        for(String s2:s1)
        {
            count++;
            System.out.println(s2);
        }

        System.out.println("\nTotal Number of Movies = "+count);
    }
}





 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                                                                               		toString Method
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Every println() method always call the toString() method whether we call it or not

toString() => toString() method belongs to the object class

Syntax =>
                   public String toString()


Example =>

class demo
{
    public String toString()
    {
        return "Ali Hasan";
    }
    public static void main(String [] args)
    {
        demo d=new demo();
        System.out.println(d);
    }
}


Example =>

import java.util.Scanner;
class demo
{
    Scanner sc=new Scanner(System.in);
    public String toString()
    {
        System.out.println("Enter the String : ");
        String name=sc.nextLine();
        return "Ali Hasan";
    }
    public static void main(String [] args)
    {
        demo d=new demo();
        System.out.println(d);
    }
}



 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                                                                        			ASSERTION IN JAVA
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

=> Assertion are statement in java that enable you to test the assumptions made in a program during program execution
=> Assertion are used during testing of a program to ensure that the specified condition is ture
=> Assertion concept was introduced  in jdk 1.4

Example =>

import java.util.*;
class demo
{
    public static void main(String [] args)
    {
        Scanner sc=new Scanner(System.in);
        System.out.println("Enter your Age : ");
        int age=sc.nextInt();
        assert(age>0):"Please Enter the Positive Age";
        if(age<18)
        {
            System.out.println("You are not Adult : ");
        }
        else
        {
            System.out.println("You are Adult : ");
        }
    }
}


=> by default assertion is disable at the time of program execution to enable the assertion ( at compile time  write  java -ea <class_name> )







 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                                                                             		THREAD IN JAVA
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  

=> What is a thread?

     It's a flow of execution.
     for every flow of execution a separate job is there.
     Thread consumes CPU in best possible manner, hence enables multi processing . Multi threading reduces idle time of CPU which improves performance of application
     
     A mutithreaded program contains two or more parts that can run concurrently.
     Each part of such a program is called a thread and each thread defines a separate path of execution.
     Multithreading is a specialized form of multitasking.

     Thread are light-weigth process.
     A thread class belongs to java.lang package.
     Thread have their own stack.


	Multitasking thread require less overhead than multitasking process. process are heavyweight task that require their own separate address spaces.
	Interprocess communication is expensive and limited.
	Context switching from one process to another is also costly.
	Thread on the other hand , are lightweight.
	They share the same process space and cooperatively share the same heavyweight process.



	The Thread class defines several methods that help manage threads. The ones that will be used in this chapter are shown here:

		Method			Meaning

		getName			Obtain a thread's name
		getPriority		Obtain a thread's priority
		isAlive			Determine if a thread is still running
		join			Wait for a thread to terminate
		run			Entry point for the thread
		sleep			Suspend a thread for a period of time
		start			Start a thread by calling its run method.


Q=>  How to implement Thread in java?
         Thread can be created in two ways by implementing java.lang.Runnable interface or extending java.lang.Thread class and then extending run method

Q=> Does thread implmenting their own stack,if yes how?
         yes, Thread have their own stack, thread internally maintains their own stack


        class demo extends Thread
        {
           public void run()
           {
               for(int i=0;i<5;i++)
               {
	System.out.println("Child");
               }
            }
         }

         class demo1
         {
            public static void main(String [] args)
            {					//when we enter main() method as soon as main is called JVM it is pushed on stack
              System.out.println("In main() method");
              method1();				//when main() calls method1() as soon as main calls method1() pushed on stack
            }
            static void method1()
            {
             demo d=new demo();
              d.start();				//when method1() calls thread.start() create new thread by calling thread.start() as 
            }                                                                                     thread have their own stack new stack created.
         }



Q=> Difference between implementing Runnable interface extending Thread class

Multiple inheritance is not allowed in java: When we implement Runnable interface we can extends another class as well but if we extends           Thread class we can't extends any other class because java does not allow multiple inheritance  so same work is done by implementing                 Runnable and extending Thread.

when we are going for multithreading ?
when there is two independent job are there?       if there in dependency than not go for multithreading

Multitasking :- Executing several task simultanusly is a concept of multitasking.

there are two type of multitasking
1) Process based multitaking 
2) Thread based multitasking

=> Process based multitasking :: 
Executing several task simultaneously where each task is a separate independent program(process) , is called process based multitasking.

ex=> While typing a java program in the editor we can listen audio songs from same system at the same time we can download a file from internet. all these task will be executed simultaneously and independent of each other hence it is process based multitasking.

Process Based multitasking is best suitable at OS (Operating System )level.


=> Thread Based Multitasking ::
Executing several task simultaneously where each task is a separeate independent part of the same program is called thread based multitasking and each independent part is called a thread.

Thread based multitasking is best suitable at programatic level.


Ques :- What is the different between the process based and thread based threading?

whether it is process based and thread based the main objective of multitasking is to reduce the response time of the system and to improve performance

=>Various application area where we can use the mutithreading concept

the main important applications areas are:-
1) to develop the multimedia graphics , to develop animation ,  to develop video games , to develop web  server and application servers etc.


Example:-

class MyThread extends Thread
{
   public void run()
    {
      for(int i=0;i<10;i++)
       {
          System.out.println("Child Thread");  //executed by child thread
       }
    }
}

class ThreadDemo
{
   public static void main(String [] args)
    {
            MyThread  t = new MyThread();          //Thread initiation
             t.start(); 			 //starting of thread
            
             for(int i=0;i<10;i++)
              {
                System.out.println("Main Thread");   //executed by main thread
              }
    }
}

Explanation:-

First creating class which extends the thread class and we are overriding the run method( because run method already available in thread class)
this total process is called defining  thread every java program contain one thread default main thread but internally contain more than one  demon thread. main thread creates child thread 
object main thread start child thread

Demon Thread => It is a low prioroty thread that run in the background  to perform task such as grabage collection.


Thread Schedular:-
if multiple thread are there in which order they are going to execute that is decided by the thread schedular

but in which order the thread are going to execute we can't say because what is the algorithm followed by schedular we can't say some schedular follow FCFS some follow SJF and some 
follow Round Robin  it vary from jvm to jvm .

it is the part of jvm it is responsible to schedule threads if multiple threads are waiting to get the chance of execution than in which order thread will be executed is decided by thread shedular

we can't except thread execution order and exact output hence whenever situation come to multithreading there is no guarntee for exact output but we can provide several possible outputs.

case 2
difference between t.start() and t.run()

if i call t.start() a separeate flow(a new thread) will be created that thread is responsible to execute our run method
if i call t.run() the run method will be executed just like a general method called by main thread.

case 3
importance of  thread  class start method 
thread class start method is responsible for register the thread with thread schedular and other mandatory activity hence without executing thread class start method there is no chance of 
starting a new thread  in java due to this thread class start method is consider as heart of multithreading

start()
{
  1.register this thread with thread schedular 
   2.perform all other mandatory activity 
   3.invoke run method
}

case 4
overloading of run method
overloading of run method is always possible but thread class start method can invoke no args run method the other overloaded method we have to call explicitily like a normal method call 

class MyThread extends Thread
{
   public void run()
    {
      System.out.println("no-args ");
     }
    public void run(int i)
    {
        System.out.println("int agrs run")
    }
}
class threadDemo
{
   public static void main(String [] args)
   {
    MyThread t=new MyThread();
     t.start();
   }
}

Example=>

class demo extends Thread
{
    public void run()
    {
        System.out.println("Hello :");
    }
    public void run(int i)
    {
        System.out.println("Bye :");
    }
}
class caller
{
    public static void main(String [] agrs)
    {
        demo d=new demo();
        d.start();
        d.run(12);
    }
}


case 5:
if we are not overridding run method  than thread class run method will be executed which has empty implementation hence we will not get any output

Example
class MyThread extends Thread
{
}
class ThreadDemo
{
  public static void main(String [] args)
  {

   MyThread t=new MyThread();
    t.start();
   }
}

output=> no output



Note=> it is highly recommanded to override run  method otherwise don't go for multithreading concept

case 6:
overriding of start method
if we override a start method than our start  method will be executed just like a normal method call and new thread will not be created

class MyThread extends Thread
{
  public void start()
   {
     System.out.println("start method");
   }
   public void run()
   {
     System.out.println("Run method");
    }
}
class ThreadDemo extends Thread
{
  public static void main(String [] args)
  {
    MyThread   t=new MyThread();
      t.start()
    System.out.println("main Method");
   }
}

Note:- it is not recommended to override the start method otherwise don't go for multithreading concept

class MyThread extends Thread
{
  public void start()
   {
     super.start();
     System.out.println("start methods");
    }
   public void run()
   {
    System.out.println("run methods")
   }
}
class ThreadDemo
{
  public static void main(String [] args)
  {
    MyThread t=new MyThread();
    t.start();
    System.out.println("main method");
   }
}


Thread LifeCycle

new/born  ==(t.start();)==>  ready/running    ==(if T.S allocate procedure)==>    running   ==(if run() method complete)==>   dead

=>when a thread is already started we can't restart the same thread otherwise we will get the runtime exception (IllegalThreadStateException)

  Example=>
class demo extends Thread
{
    public void run()
    {
        for(int i=0;i<10;i++)
        System.out.println("Ali :");
    }
}
class caller
{
    public static void main(String [] args)
    {
        demo d=new demo();
        d.start();
        System.out.println("Main method : ");
        d.start();
    }
}



                                                         	------------------:  Defining a Thread by implementing Runnable Interface :------------------


 We can define a thread by implementing runnable interface 
 runnable interface present in java.lang package and it contain only one method run method ( public void run() )

Example=>

class myRunnable implements Runnable
{
  public void run()
  {
     for(int i=0;i<10;i++)
     {
       System.out.println("Child Thread" );
     }
  }
}     
class ThreadDemo
{
  public static void main(String [] args)
  {
   myRunnable r = new myRunnable();
   Thread t = new Thread(r);
    t.start();
    for(int i=0;i<10;i++)
    {
      System.out.println("Main Thread : ");
    }
  }
}

we will get  mixed output and we can't tell exact output.

Case Study :---
myRunnable r=new myRunnable();
Thread t1 = new Thread();
Thread t2 = new Thread(r);

case 1:-  t1.start()
a new thread will be created and which is responsible for the execution of thread class run method,which has empty implementation

case 2:-  t1.run()
no new thread will be created and thread class run method will be executed just like a normal method call

case 3:-  t2.start()
a new thread will be created which is responsible for the execution of my runnable class run method

case 4:-  t2.run()
a new thread will not be created and my runnable and method will be executed just like a normal method call

case 5:- r.start();     //CE: can't find symbol: method start() location class myRunnable

case 6:- r.run();       //
no new  thead  will be created and myRunnable run method will be executed like normal method call

Example=>
//create a second thread

class NewThread implements Runnable
{
	Thread t;
	NewThread()
	{
		t=new thread(this,"Demo Thread");
		System.out.println("Child thread : "+t);
		t.start();
	}
	public void run()
	{
		try
		{
			for(int i=5;i>0;i++)
			{
				System.out.println("Child Thread : "+i);
				Thread.sleep(500);
			}
		}
		catch(InterruptedException e)
		{
			System.out.println("Child Interrupted : ");
		}
		System.out.println("Exiting child thread : ");
		
	}
}
class ThreadDemo
{
	public static void main(String [] args)
	{
		new NewThread();
		try
		{
			for(int i=5;i>0;i--)
			{
				System.out.println("Main Thread : "+i);
				Thread.sleep(1000);
			}
		}
		catch(InterruptedException e)
		{
			System.out.println("Main thread Interrupted : ");
		}
		System.out.println("Main thread exiting : ");
	}
}


//Creating multiple Thread

class NewThread implements Runnable
{
	String name;
	Thread t;
	
	NewThread(String threadname)
	{
		name=threadname;
		t=new Thread(this,name);
		System.out.println("New Thread " +t);
		t.start();
	}
	public void run()
	{
		try
		{
			for(int i=5;i>0;i--)
			{
				System.out.println(name+" : "+i);
				Thread.sleep(1000);
			}	
		}
		catch(InterruptedException e)
		{
			System.out.println(name+"Interrupted");
		}
		System.out.println(name+"exiting");
	}
}
class MultipleThreadDemo
{
	public static void main(String [] args)
	{
		new NewThread("one");
		new NewThread("two");
		new NewThread("three");

		try
		{
			Thread.sleep(10000);
		{
		catch(InterruptedException e)
		{
			System.out.println("Main thead Interrupted ");
		}
	}
}			

                                                                 			----------------: Which approache is best to define a thread :---------------


Among two ways to defining a thread implements runnable approache is recommanded
in the first approache our class always extends Thread class ,there is no chance of extending any other class hence we are missing inheritence benefits

but in the second approache while implementing runnable interface we can extends any other class hence we will not miss any inheritence benefit.
because of above reason implementing runnable interface approache recommanding then extending thread class



                                                                         		----------------------: Thread class Constructor :----------------------


1) Thread t = new Thread( );
2) Thread t = new Thread( Runnable r );
3) Thread t = new Thread( String name );
4) Thread t = new Thread( Runnable r,String name );
5) Thread t = new Thread( ThreadGroup g,String name );
6) Thread t = new Thread( ThreadGroup g,Runnable r );
7) Thread t = new Thread( ThreadGroup g,Runnable r,String name );
8) Thread t = new Thread( ThreadGroup g,Runnable r,String name,long stacksize );


DurgaApproach to Define a Thread (Not Recommanded to Use)

class myThread extends Thread
{
  public void run()
  {
   System.out.println("Child Thread");
  }
}
class ThreadDemo
{
  public static void main(String [] args)
  {
   myThread t=new myThread();
   Thread t1=new Thread(t);
    t1.start();
    System.out.println("main Thread");
  }
}




                                                                          		-----------: Getting and Setting Name of Thread :------------


Every Thread in java has some name it may be explicitly provided by programmer or default name generated by JVM
We can get and set name of a thread  by using the following two method of thread class
1) public final String getName()
2) public final void setName(String name)

class myThread extends Thread
{
 
}
class Test
{
  public static void main(String [] args)
  {
    System.out.println(Thread.currentThread().getName());
    myThread t=new myThread();
    System.out.println(t.getName());
    Thread.currentThread().setName("Ali Hasan");
    System.out.println(Thread.currentThread().getName());
    System.out.println(10/0);
  }
}

Output ==>
main
Thread-0
Ali Hasan
Exception in thread "Ali Hasan" java.lang.ArithmeticException: / by zero
        at Test.main(demo.java:35)



to get current executing thread < Thread.currentThread() > method can be used


class MyThread extends Thread
{
  public void run()
  {
    System.out.println("this line executed by Thread"+Thread.currentThread().getName()); 
  }
}
class Test
{
  public static void main(String [] args)
  {
    MyThread t=new MyThread();
    t.start();
    System.out.println("this line executed by Thread"+Thread.currentThread().getName());
  }
}


				            -----------: Thread isAlive() and join()  :---------

How can one thread know when another thread has ended?
Two ways exist to determine whether a thread has finished.
First you can call isAlive() on the thread.  this method is defined by Thread and its general form is shown here:

	final boolean isAlive()

the isAlive() method return true if the thread upon which it is called is still running it return false otherwise.


Second you can call join() on thread this method is defined by Thread and its general form is shown here:

	final void join() throws InterruptedException
this methods waits until the thread on which it is called terminates.





                                                                                               -----------: Thread Priorities :---------


Every thread in java has some priority it may be default priority ganerated by jvm or custmize priority provided by programmer

The valid range of thread priority in 1 to 10

Where 1 is minimum priority and 10 in maximum priority

Thread class define the following constant to represent some standard priority
1) Thread.MIN_PRIORITY        -> 1
2) Thread.NORM_PRIORITY   ->  5
3) Thread.MAX_PRIORITY       -> 10


Thread schedular will use priority while allocating processor
the Thread which is having highest priority will get chance first
if two thread having same priority then we can't expect exact execution order it depend on thread schedular

Thread class define the following methods to get and set priority of a thread
1) public final int getPriority()
2) public final void setPriority(int p)
allowed value range : 1 to 10 otherwise RE: IllegalArgumentException

ex=>
             t.setpriority(7);      //valid
             t.setpriority(17);    //invalid  RE



				            				---------:  Default Priority  :--------


The default priority only for the main thread is 5.
but for all remining thread default priority will be inherited  from parent to child i,e whatever priority parent thread has the same priority will be there for the child thread

Example=>
     
class myThread extends Thread
{
}
class Test
{
  public static void main(String [] args)
  {
    System.out.println(Thread.currentThread().getPriority());
    //Thread.currentThread().setPriority(15);                                         //RE: IllegalArgumentException                          
    Thread.currentThread().setPriority(7);
     myThread t=new myThread();
     System.out.println(t.getPriority());
  }
}



   Thread   <--- parent class ---- myThread t=new myThread()   --------- parent Thread  ----------->main Thread


Example =>

class myThread extends Thread
{
  public void run()
  {
    for(int i=0;i<10;i++)
    {
      System.out.println("Child Thread");
    }
  }
}
class ThreadPriorityDemo
{
  public static void main(String [] args)
  {
    myThread t=new myThread();
    //t.setPriority(10);   ---(1)
    t.start();
    for(int i=0;i<10;i++)
    {
      System.out.println("main Thread" );
    }
  }
}


if we are commenting line 1 then  both main and child thread have the same priority 5 and hence we can't except execution order and exact output
if we are not commenting line then main thread has a priority 5 and child thread has the priority 10 hence child thread will get the chance first followed by the main thread.

Note:- some platform will not provide proper support for thread priority.




					        --------: Daemon Thread :--------

The Daemon thread is a service provider thread
it provide services to the user thread
common thing about daemon thread
1) daemon thread is service provider thread
2) they always run in backgroud
3) they never show any output
4) they always provide service to another thread
5) they will dead automatically if a thread is dead for whom they are giving the service
6) it perform task such as garbage collection.

Methods for daemon thread
=> thread class provide two methods to daemon 

1) public void setDaemon(boolean status)
    =>it is used to make the current thread as daemon thread or user thread if we pass true in that case it is Daemon otherwise it is user thread.
         if i have a user thread tu then tu.setDaemon(true) would make it Daemon thread. On the other hand if i have a Daemon thread td then by          calling td.setDaemon(false) would make it user thread.

2) public boolean isDaemon()
     => is used to check that current thread is daemon thread or not


Example=>


class Daemonthread extends Thread
{
	public void run()
	{
		if(Thread.currentThread().isDaemon())
		{
			System.out.println("Daemon Thread Work");
		}
		else
		{
			System.out.println("User Thread Work");
		}
	}

	public static void main(String [] args)
	{
		Daemonthread d=new Daemonthread();
		Daemonthread d1=new Daemonthread();
		Daemonthread d2=new Daemonthread();

		d.setDaemon(true);
		d.start();
		d1.start();
		d2.start();
	}
}


output=>

D:\java program>javac sublime_new.java

D:\java program>java Daemonthread
Daemon Thread Work
User Thread Work
User Thread Work





=> Exception in Daemon Thread
      if you call setDaemon() method after starting the thread it would throw IllegalThreadStateException


class Daemonthread extends Thread
{
	public void run()
	{
		System.out.println("Thread Name : "+Thread.currentThread().getName());
		System.out.println("Check if the Daemon Thread : "+Thread.currentThread().isDaemon());
	}

	public static void main(String [] args)
	{
		Daemonthread d=new Daemonthread();
		Daemonthread d1=new Daemonthread();

		d.start();
		d.setDaemon(true);
		d1.start();
	}
}



D:\java program>java Daemonthread
Exception in thread "main" java.lang.IllegalThreadStateException
        at java.base/java.lang.Thread.setDaemon(Thread.java:1458)
        at Daemonthread.main(sublime_new.java:428)
Thread Name : Thread-0




					---------: Factory Method :--------

the method that return the instance of a class is known as factory method.


					---------: Synchronization :--------

Synchronization is the capability of control the access of multiple thread  and make sure that only one thread can access the resource at a given point in time. this is implemented using 
concept of monitor.

synchronization is better in case we want only one thread can access the shared reasources at a time.

When two or more threads need access to a shared resourse, they need some way to ensure that the resource will be  used by only one thread at a time. The process by which this is achieved is called synchronization.

=> Why use Synchronization
The Synchronization is mainly used to
1) to prevent thread interference
2) to prevent consistency problem


=> Types of Synchronization
There are two types of synchronization
1) Process Synchronization
2) Thread Synchronization


=> Thread Synchronization
There are two types of Thread Synchronization mutual exclusion and inter-thread Communication.
1) Mutual Exclusion
2) Inter-Thread Communication



=> Mutual Exclusion
1) Synchronization method
2) Synchronization block
3) static Synchronization


				               ---------: Java synchronized method :---------

If you declare any method as synchronized, it is known as synchronized method.
Synchronized method is used to lock an object for any shared resource.
When a thread invokes a synchronized method, it automatically acquires the lock for that object and releases it when the thread completes its task.


Example=>
//example of java synchronized method  
class Table{  
 synchronized void printTable(int n){//synchronized method  
   for(int i=1;i<=5;i++){  
     System.out.println(n*i);  
     try{  
      Thread.sleep(400);  
     }catch(Exception e){System.out.println(e);}  
   }  
 }  
}  
  
class MyThread1 extends Thread{  
Table t;  
MyThread1(Table t){  
this.t=t;  
}  
public void run(){  
t.printTable(5);  
}  
  
}  
class MyThread2 extends Thread{  
Table t;  
MyThread2(Table t){  
this.t=t;  
}  
public void run(){  
t.printTable(100);  
}  
}  
  
public class TestSynchronization2{  
public static void main(String args[]){  
Table obj = new Table();//only one object  
MyThread1 t1=new MyThread1(obj);  
MyThread2 t2=new MyThread2(obj);  
t1.start();  
t2.start();  
}  
}  


Output=>
Output: 5
       10
       15
       20
       25
       100
       200
       300
       400
       500
       



					----------: Synchronized block in java :----------

Synchronized block can be used to perform synchronization on any specific resource of the method.
Suppose you have 50 lines of code in your method, but you want to synchronize only 5 lines, you can use synchronized block.

If you put all the codes of the method in the synchronized block, it will work same as the synchronized method.



	Points to remember for Synchronized block :-------

Synchronized block is used to lock an object for any shared resource.
Scope of synchronized block is smaller than the method.


Example=>
class Table{  
  
 void printTable(int n){  
   synchronized(this){//synchronized block  
     for(int i=1;i<=5;i++){  
      System.out.println(n*i);  
      try{  
       Thread.sleep(400);  
      }catch(Exception e){System.out.println(e);}  
     }  
   }  
 }//end of the method  
}  
  
class MyThread1 extends Thread{  
Table t;  
MyThread1(Table t){  
this.t=t;  
}  
public void run(){  
t.printTable(5);  
}  
  
}  
class MyThread2 extends Thread{  
Table t;  
MyThread2(Table t){  
this.t=t;  
}  
public void run(){  
t.printTable(100);  
}  
}  
  
public class TestSynchronizedBlock1{  
public static void main(String args[]){  
Table obj = new Table();//only one object  
MyThread1 t1=new MyThread1(obj);  
MyThread2 t2=new MyThread2(obj);  
t1.start();  
t2.start();  
}  
}  


Output=>	
        5
       10
       15
       20
       25
       100
       200
       300
       400
       500



       

=> Concept of Lock in java
Synchronization is built around an internal entity known as the lock and monitor. Every object has an lock associated with it by convention, a thread that needs consistent access to an object's fields has to acquire the object'c lock before accessing them, and then release the lock when it's done with them.



					---------: Inter-thread communication :-------

Inter thread communication is all about making synchronized thread communication with each other.  cooperation is a mechanism in which a thread is paused  running in its critical section and another thread is allowed to enter in the same critical section to be executed it is implemented by following methods:-

1) wait()
2) notify()
3) notifyAll()


wait()
=> it tells calling thread to give up lock and go to pause untill some other thread enters the same Lock.
=> causes current thread to release the lock and wait until either another thread invoke the notify() method or notifyAll() method for this object

Syntex=>
		public final void wait()throws InterruptedException

		public final void wait(long timeout)throws InterrutedException

notify()
=>wake a thread that called wait() on same object.  It wake up a single thread object

Syntex=>
		public final void notify()

notifyAll()
=> wake up all the thread that called wait() on same object

syntex=>
		public final notifyAll()



			
		
					-----------: Thread LifeCycle :----------


Life cycle of a thread starts when we create  an object of the thread class and end when the thread task (run() method)is completed

commonly used states are as follows:-
1) New (unstarted state)
2) Runnable (Ready)
3) Running
4) Not-Runnable (Blocked, Sleeping, Waiting)
5) Terminated(Dead)


1) New 
When we create an object of the Thread class that state is known as New State

2) Runnable
When we call start() method on thread that state is known as Runnable state

3) Running 
when run method is getting executed which is known as running state.

4) Not Runnable State
when we call wait() sleep() and yeild() method on thread which is known as Not Runnable state

5) Dead
when run method is finished that state is known as dead state 
 

 

					--------: Thread Deadlock :---------

Deadlock can occur in a situation when a thread is waiting for an object that is acquire by another thread and second thread is waiting for an object that is acquire by first thread






- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                                                                                   			Generic In Java
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Through the use of generic it is possible to create classes,interfaces and methods that will work in a type-safe manner with various kinds of data. Many algorithm are logically the same no 
metter what type of data they are being applied to.

The mechanism that supports a stack is the same whether that stack is storing items of type Integer, String, Object or Thread. With generic you can define an algorithm once independently of 
any specific type of data and then apply that algorithm to a wide variety of data types without any additional efforts.


Generic means parametrized types. Parametrized types are important because they enable you to create classes, interfaces and methods in which the type of data upon which they operate is 
specified as a parameter.


Example=>

class Gen<T>
{
    T ob;  //declare an object of type T
    
    Gen(T o)  // pass the constructor a reference to an object of type T
    {
        ob=o;
    }

    T getob()//return ob
    {
        return ob;
    }

    //show type of T
    void showType()
    {
        System.out.println("Type of T is "+ob.getClass().getName());
    }
}
class GenDemo//Demonstrate the generic class
{
    public static void main(String [] args)
    {
        Gen<Integer> iob;

        iob=new Gen<Integer>(88);

        //show the type of data used by iob

        iob.showType();

        //get the value in iob 

        int v=iob.getob();
        System.out.println("value : "+v);
        System.out.println();

        //create a Gen object for string

        Gen<String> strob = new Gen<String>("Generics Test");

        //show the type of data send by strob
        strob.showType();

        String str=strob.getob();
        System.out.println("value : "+str);
    }
}


Output=>
D:\VS>javac caller.java

D:\VS>java GenDemo
Type of T is java.lang.Integer
value : 88
Type of T is java.lang.String
value : Generics Test



First Notice how Gen is declared by the following line

	class Gen<T>{

Here T is the name of a parameter. This name is used as a placeholder for the actual type that will passed to gen when an object is creted. Thus T is used within Gen whenever the type parameter is needed. Notice that T is contined within < >. This syntex can be generalized. whenever a type parameter Gen is a Generic class which is also called a parametrized type.


Next T is used to declare an object called ob as shown here
	
	T ob;	// declare an object of type T
	
As explained T is placeholder for the actual type that will be specified when Gen object is created . Thus ob will be object of the type passed to T if type String is passed to T then in that instance ob will be of type String.

	Now consider Gen's constructor
	
	Gen(T o){
	     ob=o
	}
	
Notice that its parameter o is of type T. This means that the actual type of o is determined by the type passed to T when a Gen object is created. Also because both the parameter o and the 
member variable ob are of type T they will both be of the same actual type when a Gen object is created

The type parameter T can also be used to specify the return type of a method as is the case with the getob() method shown here:

	T getob(){
	return ob;
	}

Because ob is also of type T, its type is compatible with the return type specified by getob( ). The showType( ) method displays the type of T by calling getName( ) on the Class object returned by the call to getClass( ) on ob. The getClass( ) method is defined by Object and is thus a member of all class types. It returns a Class object that corresponds to the type of the class of the object on which it is called. Class defines the getName( ) method, which returns a string representation of the class name.




	Generic Work Only With Object :------------

When declaring an instance of a generic type the type argument passed to the type parameter must be a class type. You cannot use a primitive type such as int or char. For example with Gen it is possible to pass any class type to T but you cannot pass a primitive type to a type parameter.Therefore the following declaration is illegal:

	Gen<int> strOb=new Gen<int>(53);	//Error can't use primitive type




	Generic Types Differ Based on Thier Type Arguments:------------------

A key point to understand about generic type is that a reference of one specific version a generic type is not type compatible with another version of the same generic type. For example, assuming the program just shown the following line of code is in error and will not compile:

	iob=strOb;	//wrong




	How Generics Improve Type Safety :-----------------------

What is the benefit of making Gen generic? 

The answer is that generics automatically ensure the type safety of all operations involving Gen. In the process, they eliminate the need for you to enter casts and to type-check code by hand.

To understand the benefits of generics, first consider the following program that creates a non-generic equivalent of Gen:

// NonGen is functionally equivalent to Gen
// but does not use generics.

class NonGen
{
Object ob; // ob is now of type Object

// Pass the constructor a reference to
// an object of type Object
NonGen(Object o)
{
ob = o;
}

// Return type Object.
Object getob() {
return ob;
}
// Show type of ob.
void showType() {
System.out.println("Type of ob is " +
ob.getClass().getName());
}
}
// Demonstrate the non-generic class.
class NonGenDemo 
{
public static void main(String args[])
{

NonGen iOb;

// Create NonGen Object and store
// an Integer in it. Autoboxing still occurs.
iOb = new NonGen(88);

// Show the type of data used by iOb.
iOb.showType();

// Get the value of iOb.
// This time, a cast is necessary.
int v = (Integer) iOb.getob();
System.out.println("value: " + v);
System.out.println();

// Create another NonGen object and
// store a String in it.
NonGen strOb = new NonGen("Non-Generics Test");

// Show the type of data used by strOb.
strOb.showType();

// Get the value of strOb.
// Again, notice that a cast is necessary.
String str = (String) strOb.getob();
System.out.println("value: " + str);

// This compiles, but is conceptually wrong!
iOb = strOb;
v = (Integer) iOb.getob(); // run-time error!

}
}






				   ---------: A Generic Class with Two Type Parameter :---------

You can declare more than one parameter in a generic type.
To specify two or more type parameter simply use a comma-separated list.


Example:-


// A simple generic class with two type
// parameters: T and V.
class TwoGen<T, V>
{
    T ob1;
    V ob2;
    // Pass the constructor a reference to
    // an object of type T and an object of type V.
    TwoGen(T o1, V o2)
    {
        ob1 = o1;
        ob2 = o2;
    }
    // Show types of T and V.
    void showTypes() 
    {
        System.out.println("Type of T is " +
        ob1.getClass().getName());
        System.out.println("Type of V is " +
        ob2.getClass().getName());
    }

    T getob1()
    {
        return ob1;
    }

    V getob2()
    {
        return ob2;
    }
}
    // Demonstrate TwoGen.
class demo
{
    public static void main(String args[])
    {
        TwoGen<Integer, String> tgObj =
        new TwoGen<Integer, String>(88, "Generics");
        // Show the types.
        tgObj.showTypes();
        // Obtain and show values.
        int v = tgObj.getob1();
        System.out.println("value: " + v);
        String str = tgObj.getob2();
        System.out.println("value: " + str);
    }
}




Note:-

Although the two type arguments differ in this example, it is possible for both types to be the same. For example, the following line of code is valid:
		TwoGen<String, String> x = new TwoGen<String, String>("A", "B");

In this case, both T and V would be of type String. Of course, if the type arguments were always the same, then two type parameters would be unnecessary.





			   	----------------: The General Form of a Generic Class :---------------------

The generics syntax shown in the preceding examples can be generalized. Here is the syntax for declaring a generic class:

	class class-name<type-param-list> { // ...
		Here is the syntax for declaring a reference to a generic class:
		class-name<type-arg-list> var-name =
			new class-name<type-arg-list>(cons-arg-list);





					        -------------: Bounded Type :------------

For example, assume that you want to create a generic class that contains a method that returns the average of an array of numbers. Furthermore, you want to use the class to obtain the average of an array of any type of number, including integers, floats, and doubles. Thus, you want to specify the type of the numbers generically, using a type parameter. To create such a class, you might try something like this:


Example=>

// Stats attempts (unsuccessfully) to
// create a generic class that can compute
// the average of an array of numbers of
// any given type.
//
// The class contains an error!

class Stats<T>
{
T[] nums; 
// nums is an array of type T
// Pass the constructor a reference to
// an array of type T.

Stats(T[] o)
{
nums = o;
}

// Return type double in all cases.
double average() 
{
double sum = 0.0;

for(int i=0; i < nums.length; i++)
sum += nums[i].doubleValue(); // Error!!!

return sum / nums.length;
}
}





Example=>

// In this version of Stats, the type argument for
// T must be either Number, or a class derived
// from Number.
class Stats<T extends Number>
{
    T[] nums; // array of Number or subclass
    // Pass the constructor a reference to
    // an array of type Number or subclass.
    Stats(T[] o)
    {
        nums = o;
    }
    // Return type double in all cases.
    double average()
    {
        double sum = 0.0;
        for(int i=0; i < nums.length; i++)
        sum += nums[i].doubleValue();
        return sum / nums.length;
    }
}

// Demonstrate Stats.
class demo
{
    public static void main(String args[])
    {
        Integer inums[] = { 1, 2, 3, 4, 5 };
        Stats<Integer> iob = new Stats<Integer>(inums);
        double v = iob.average();
        System.out.println("iob average is " + v);
        Double dnums[] = { 1.1, 2.2, 3.3, 4.4, 5.5 };
        Stats<Double> dob = new Stats<Double>(dnums);
        double w = dob.average();
        System.out.println("dob average is " + w);
        // This won't compile because String is not a
        // subclass of Number.
        // String strs[] = { "1", "2", "3", "4", "5" };
        // Stats<String> strob = new Stats<String>(strs);
        // double x = strob.average();
        // System.out.println("strob average is " + v);
    }
}


Output=>
(base) D:\VS>javac caller.java

(base) D:\VS>java demo
iob average is 3.0
dob average is 3.3




					--------------: Using Wildcard Argument :-------------
To create a generic sameAvg() method you must use another feature of Java generics: the wildcard argument is specified by the ? and it represent an unknown type. Using a wildcard here is one way to write the sameAvg() method:

// Determine if two averages are the same.
// Notice the use of the wildcard.
boolean sameAvg(Stats<?> ob) {
if(average() == ob.average())
return true;
return false;
}

Here, Stats<?> matches any Stats object, allowing any two Stats objects to have their averages compared. The following program demonstrates this:


Example=>


// Use a wildcard.
class Stats<T extends Number>
{
    T[] nums; // array of Number or subclass
    // Pass the constructor a reference to
    // an array of type Number or subclass.
    Stats(T[] o)
    {
        nums = o;
    }
    // Return type double in all cases.
    double average()
    {
        double sum = 0.0;
        for(int i=0; i < nums.length; i++)
        sum += nums[i].doubleValue();
        return sum / nums.length;
    }
    // Determine if two averages are the same.
    // Notice the use of the wildcard.
    boolean sameAvg(Stats<?> ob)
    {
        if(average() == ob.average())
        return true;
        return false;
    }
}
// Demonstrate wildcard.
class demo
{
    public static void main(String args[])
    {
        Integer inums[] = { 1, 2, 3, 4, 5 };
        Stats<Integer> iob = new Stats<Integer>(inums);
        double v = iob.average();
        System.out.println("iob average is " + v);
        Double dnums[] = { 1.1, 2.2, 3.3, 4.4, 5.5 };
        Stats<Double> dob = new Stats<Double>(dnums);
        double w = dob.average();
        System.out.println("dob average is " + w);
        Float fnums[] = { 1.0F, 2.0F, 3.0F, 4.0F, 5.0F };
        Stats<Float> fob = new Stats<Float>(fnums);
        double x = fob.average();
        System.out.println("fob average is " + x);
        // See which arrays have same average.
        System.out.print("Averages of iob and dob ");
        if(iob.sameAvg(dob))
        System.out.println("are the same.");
        else
        System.out.println("differ.");
        System.out.print("Averages of iob and fob ");
        if(iob.sameAvg(fob))
        System.out.println("are the same.");
        else
        System.out.println("differ.");
    }
}


Output=>
base) D:\VS>javac caller.java

(base) D:\VS>java demo
iob average is 3.0
dob average is 3.3
fob average is 3.0
Averages of iob and dob differ.
Averages of iob and fob are the same.








 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                                                                      			COLLECTION  FRAMEWORK
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  

The Collection Framework is a sophisticated hierarchy of interfaces and classes that provides state-of-the-art technology for mapping groups of objects. It merits close attention by all programmer
Collection is a group of object.
Collection is container object it is used for storing multiple homogeneous and hetrogeneous,unique and duplicate object without size limitation.
Collection is used for storing multiple object as a single object.


Because java.util contains a wide array of functionality it is quite large.
Here is a list of its classes:

		AbstractCollection			EventObject		Random
		AbstractList			FormattableFlags		ResourceBundle
		AbstractMap			Formatter			Scanner
		AbstractQueue			GregorianCalender		ServiceLoader
		AbstractSequentialList		HashMap			SimpleTimeZone
		AbstractSet			HashSet			Stack
		ArrayDeque			HashTable		StringTokenizer
		ArrayList				IdentityHashMap		Timer
		Arrays				LinkedHashMap		TimeTask
		BitSet				LinkedHashSet		TimeZone
		Calender				LinkedList			TreeMap
		Collections			ListResourceBundle		TreeSet
		Currency				Locale			UUID
		Date				Observable		Vector
		Dictonary				PriorityQueue		WeakHashMap
		EnumMap				Properties
		EnumSet				PropertyPermission
		EventListenerProxy			PropertyResourceBundle



The Interfaces defined by java.util are shown :-

	Collection				List			Queue
	Comparator			ListIterator		RandomAccess
	Dqeue				Map			Set
	Enum eration			Map.Entry		SortedMap
	EventListener			NevigableMap		SortedSet
	Formattable			NevigableSet
	Iterator				Observer



The Collection Framework was design to meet several goals:-
the framework had to be high-performance . The Impelmentations for the fundamental collections(Dynamic Arrays, Linked List, Tree and Stack, HashTables) are highly efficient.

Another item closely associated with the Collections Framework is the Iterator interface.
An Iterator offer a general-purpose standardized way of accessing the elements within a collections one at a time.


In addition to collections the framework defines several map interface and classes
Map store Key/Value pairs


=> Autoboxing Facilities the Use of Primitive Types
Autoboxing / unboxing facilities the storing of primitive types in collections. As you will see a collection can store only references not primitive values. In the past if you wanted to store a 
primitive value such as an int in a collections you had to manually box it into its type wrapper.



		
			                                  			----------: Collection Interfaces :----------

The Collections Framework define several interfaces. This section provides an overview of each interface.


	Collection		Enables you to work with groups objects; it is at the top of the collections hierarchy
	Dqeue		Extends Queue to handle a double-ended queue
	List		Extends Collections to handle sequence
	NevigableSet	Extends SortedSet to handle retrieval of elements based on closest-match searches
	Queue		Extends Collections to handle special types of lists in which elements are removed only from the head
	Set		Extends Collections to handle sets which must contain unique elements
	SortedSet		Extends Set to handle sorted sets.


	Collection declaration :-------------

	Interface Collection <E>
Here E specifies the type of object that the collection will hold.
Collection extends the Iterable interface.

Several of these methods can throw an UnsupportedOperationException. As explained, this occurs if a collection cannot be modified. 
=> AClassCastException is generated when one object is incompatible with another, such as when an attempt is made to add an incompatible object to a collection. 

=> A NullPointerException is thrown if an attempt is made to store a null object and null elements are not allowed in the collection. An 
=> IllegalArgumentException is thrown if an invalid argument is used. An IllegalStateException is thrown if an attempt is made to add an element to a fixed-length collection that is full.



In addition to the Collection interfaces collections also use the
1) Comparator		// define how two objects are compared
2) RandomAccess		// list indicates that it supports efficient random access to its elements
3) Iterator			// enumerate the object within a collection
4) ListIterator		// enumerate the object within a collection


To provide the greatest flexibility in their use the collection interface allow some methods to be optional. the optional methods enable you to modify the contents of a collection.
	Collection that support these methods are called modifiable.
Collection that do not allow their contents to be changes are called unmodifiable.



				                			---------: Some method of Collection :---------

	add()		Objects are added to a collection
	addAll()		add the entire contents of one collection to another 
	remove()		it can remove an object 
	removeAll()	to remove a group of object 
	clear()		to empty a collection
	contains()		to determine whether a collection contains a specific object
	containsAll()	to determine whether one collection contains all the members of another
	isEmpty()		to determine whether a collection is Empty
	size()		to determine the number of elements currently held in collection
	toArray()		return an array of that contains the elements stored in the invoking collections
	equals()		two collections can be compared for equality




				                       		------------: List Interface :----------

The List Interface extends the Collection Interface and declares the behaviour of a collection that stores a sequence of elements.
A List may contain duplicate elements.

List contains different classes:

	ArrayList<E> 		it implements the List interface
	Vector<E>		it implements the List interface		Stack<E>		it extends Vector class
	LinkedList<E>		it implements the List interface



	ArrayList Classes :---------------------


The ArrayList class extends AbstractList and implements the List Interface
ArrayList is a generic class that has this declaration:

	class ArrayList<E>
	Here, E specifies the type of object that the list will hold

ArrayList supports dynamic arrays that can be grow as needed
ArrayList is a variable-length array of object reference
ArrayList can dynamically increase or decrease in size
ArrayList size exceeded collection automatically enlarged when added and object are removed the array can be shrunk.
ArrayList is a sequential list. So, insertion and retrieval order is the same


ArrayList has the constructor shown here:

ArrayList()			builds an empty array list
ArrayList(Collection<? extends E>c)	builds an arraylist that is initilized with the elements of the collection c
ArrayList(int capacity)		builds an arraylist that has the specified initial capacity

Example:-
	import java.util.*;
	class arraylist
	{
		public static void main(String [] args)
		{
			ArrayList<String> al=new ArrayList<String>();
			System.out.println("Initial size of  al = "+al.size());
			//add elements in the array list
			al.add("C");
			al.add("A");
			al.add("E");
			al.add("B");
			al.add("D");
			al.add("F");
			al.add(1,"A2");//add the element at the particular position
			System.out.println("Printing the Arraylist : "+al);
			System.out.println("Size of al after addition : "+al.size());//find the size of array list
			al.remove("F");//removing element form arraylist
			al.remove(2);
			System.out.println("Array list after removing : "+al);
			System.out.println("Size after removing array : "+al.size());
		
			//sorting operatoin in collection framework by the using of the collection.sort(<arraylist object>)
			Collections.sort(al);
			System.out.println(al);
		}
	}



output =>
		D:\Hacker\collectionframework>java arraylist
		Initial size of  al = 0
		Printing the Arraylist : [C, A2, A, E, B, D, F]
		Size of al after addition : 7
		Array list after removing : [C, A2, E, B, D]
		Size after removing array : 5
		[A2, B, C, D, E]


Example 2 =>
	import java.util.*;
	class demo
	{
    		public static void main(String [] args)
    		{
    		    	Scanner sc = new Scanner(System.in);
    		    	ArrayList<Integer> list = new ArrayList<Integer>();
    		    	ArrayList<Integer> list1 = new ArrayList<Integer>();
    		    	System.out.println("Enter Size : ");
    		    	int list_size = sc.nextInt();
    		    	System.out.println("Enter Element in the list : ");
    		    	for(int i=0;i<list_size;i++)
    		    	{
    		    	    list.add(sc.nextInt());
    		    	}
			
			System.out.println(list);
			Collections.sort(list);
			System.out.println(list);
			
        			list1.addAll(list);     // adding all element of list to list1 using addAll() method
        			System.out.println("It is Second List = "+list1);
	
        			if(list1.isEmpty())3{
        			    System.out.println("List is Empty");
        			}
        			else{
        			    System.out.println("List is not Empty");
        			}
		
	   	}
	}


Output=>
Enter Size :
5
Enter Element in the list :
4
1
6
5
8
[4, 1, 6, 5, 8]
[1, 4, 5, 6, 8]
It is Second List = [1, 4, 5, 6, 8]
List is not Empty




	Obtaining an Array from an ArrayList :-------------

When working with ArrayList you will Sometimes want to obtain an actual array that contains the contents of the list.
you can do this by calling toArray() which is defined by Collection.

Example =>
		import java.util.*;
		class arraylist
		{
			public static void main(String [] args)
			{
				ArrayList<String> al=new ArrayList<String>();//it means arraylist is created for object of type string
				System.out.println("Initial size of  al = "+al.size());
				//add elements in the array list
				al.add("C");
				al.add("A");
				al.add("E");
				al.add("B");
				al.add("D");
				al.add("F");
				System.out.println("Printing the Arraylist : "+al);
				System.out.println("Size of al after addition : "+al.size());//find the size of array list
				Collections.sort(al);

				//get the array
				String s[]=new String[al.size()];
				s=al.toArray(s);
				for(String str:s)
					System.out.print(str+" ");
			}
		}


output =>
	D:\Hacker\collectionframework>java arraylist
	Initial size of  al = 0
	Printing the Arraylist : [C, A, E, B, D, F]
	Size of al after addition : 6
	A B C D E F



=> Different method to convert the List to Array

1) Using Object[] toArray() method
2) Manual Method
3) Using List stream() and mapToInt().toArray() method in List




	LinkedList Classes :--------------


The LinkedList class extends AbstractSequenceList and implements the List, Deque and Queue interfaces.
It provides a Linked-list data structure.
LinkedList is a generic class that has this declaration

	class LinkedList<E>
	Here E specifies the type of object that the list will hold.

LinkedList has the two constructors:-
1) LinkedList()			// it builds an empty linked list
2) LinkedList(Collection<? extends E>c)	// it builds a linked list that is initialized with the elements of the collection c.

Some important methods of the LinkedList
	
	addFirst()		add elements to the start of a list
	offerFirst()	add elements to the start of a list
	addLast()		add elements to the end of the list
	offerLast()	add elements to the end of the list
	getFirst()		to obtain the first element
	peekFirst()	to obtain the first element
	getLast()		to obtain the last element
	peekLast()	to obtain the last element
	removeFirst()	to remove the first element
	pollFirst()		to remove the first element
	removeLast()	to remove the Last element
	pollLast()		to remove the Last element


Because LinkedList implements the Deque interface, you have access to the methods defined by Deque. For example, to add elements to the start of a list you can use addFirst( ) or offerFirst( ). To add elements to the end of the list, use addLast( ) or offerLast( ). To obtain the first element, you can use getFirst( ) or peekFirst( ). To obtain the last element, use getLast( ) or peekLast( ). To remove the first element, use removeFirst( ) or pollFirst( ). To remove the last element, use removeLast( ) or pollLast( ).

Example =>
		import java.util.*;
		class linkedlist
		{
			public static void main(String [] args)
			{
				LinkedList<String> list=new LinkedList<String>();
				//Addind the element in the list
				System.out.println("Plz Enter the Element in the  Array: ");
				list.add("Z");
				list.add("B");
				list.add("D");
				list.add("E");
				list.add("C");
				list.addLast("Z");
				list.addFirst("A");
				System.out.println("Original content of List : "+list);
				//Removing the element form the list
				list.remove("F");
				list.remove(2);
				System.out.println("List After Rmoving : "+list);
		
			}
		}
	

output=>
D:\Hacker\collectionframework>java linkedlist
Plz Enter the Element in the  Array:
Original content of List : [A, Z, B, D, E, C, Z]
List After Rmoving : [A, Z, D, E, C, Z]





					----------: Set Interface :----------

The Set Interface defines a set. It extends Collection Interface
It does not allow duplicate elements therefore add() method returns false if an attempt is made to add duplicate elements.


	HashSet Classes :----------

HashSet extends AbstractSet and implements the Set interface.
It creates a collection that uses a hash table for storage.
HashSet is a generic class that has this declaration:-

=> Insertion order is not preserved.  (it can insert any memory location it does not depent on the insertion order)
	
	class HashSet<E>
	E specified the type of objects that 

As the most readers likely know a hash  table store information by using a mechanism called hashing. In Hashing the information content of a key is used to determine a unique value called its hash code. The hash code is then used as the index at which the data associate with the key is stored. the transformation of the key intoits hash code is performed automatically you never see the hash code itself.

The advantage of hashing is that it allows the execution time of add(), contains(). remove(), and size() to remain constant even for large sets.

The following constructor are defined:
1) HashSet()			// contructs a default Hash Set
2) HashSet(Collection<? extendsE>c)	// initializes the Hash set by using the elements of c
3) HashSet(int capacity)		// initialize the capacityof the Hash Set to capacity
4) HashSet(int capacity,float fillRatio)	// initialize both the capacity and fill ratio of the hash set from its argument

HashSet does not Guarantee the order of its elements because the process of hashing does not usually lend itself to the creation of sorted sets.


Example=>

		import java.util.*;
		class Hashset
		{
			public static void main(String [] args)
			{
				HashSet<String> h=new HashSet<String>();
				h.add("Beta");
				h.add("Alpha");
				h.add("Eta");
				h.add("Gamma");
				h.add("Epsilon");
				h.add("Omega");
				System.out.println(h);
				//insertion order in not preseve in hashset
			}
		}


output =>

D:\Hacker\collectionframework>javac Hashset.java

D:\Hacker\collectionframework>java Hashset
[Gamma, Eta, Alpha, Epsilon, Omega, Beta]

D:\Hacker\collectionframework>



	LinkedHashSet :---------

The LinkedHashSet class extends HashSet and adds no member of its own.
It is a generic class that has this declaration:-
	class LinkedHashSet<E>
	E specify the type of object that the set will hold.

LinkedHashSet maintains a linked list of the entries in the set in the order in which they were inserted.
LinkedHashSet using an iterator the elements will be returned in the order in which they were inserted.

Example =>
		import java.util.*;
		class linkedhashset
		{
			public static void main(String [] args)
			{
				LinkedHashSet<String> lh=new LinkedHashSet<String>();
				lh.add("Beta");
				lh.add("Alpha");
				lh.add("Eta");
				lh.add("Gamma");
				lh.add("Epsilon");
				lh.add("Omega");
				System.out.println(lh);
				//insertion order preserve in LinkedHashSet
			}
		}

output =>
D:\Hacker\collectionframework>javac LinkedHashset.java

D:\Hacker\collectionframework>java linkedhashset
[Beta, Alpha, Eta, Gamma, Epsilon, Omega]




	TreeSet :---------


TreeSet extends AbstractSet and implements the NavigableSet interface.
It created a collection that uses a tree for storage.
Object are stored in sorted, ascending order.
Access and retrieval time are quite fast which makes TreeSet an excellent choice when storing large amount of sorted information.

TreeSet is a generic class that has this declaration
	class TreeSet<E>
	Here E specifies the type of objects that the set will hold

TreeSet has following constructors :-
	TreeSet()				// construct as empty tree set that will be sorted in ascending order
	TreeSet(Collection<? extends E>c)	// builds a tree set that contains the elements of c
	TreeSet(Comparator<? super E>comp)	// construct an empty tree set that will be sorted accordingly to the comparator
	TreeSet(SortedSet<E>ss)		// builds a tree set that contains the element of ss



Example =>
		import java.util.*;
		class treeset
		{
			public static void main(String [] args)
			{
				TreeSet<String> ts=new TreeSet<String>();
				ts.add("C");
				ts.add("A");
				ts.add("B");
				ts.add("F");
				ts.add("E");
				ts.add("D");
				System.out.println(ts);
			}
		}

output =>
D:\Hacker\collectionframework>javac tressset.java

D:\Hacker\collectionframework>java treeset
[A, B, C, D, E, F]



				              -------------: Queue Interface :-----------


The Queue interface extends Collections and declares the behavior of a queue.
which is often a First-In First-Out list there are types of queues in which the ordering is based upon other criteria.
Queue is a generic interface that has this declaration
	interface Queue<E>

Despite its simplicity Queue offers several points of interest
First, elements can only be removed from the head of the queue
Second there are two method that obtain and remove elements:
1) remove()	// throw an exception if the queue is empty
2) poll()		// return null if the queue is empty

there are two methods element() and peak(), that obtain but don't remove the element at the head of the queue
3) element()	// throw an exception if the queue is empty
4) peek()		// return null if the queue is empty




	PriorityQueue Class :-----------


PriorityQueue extends AbstractQueue and implements the Queue interface.
It creates a queue that is prioritized based on the queue's comparator.
PriorityQueue is a generic class that has this declaration
	class PriorityQueue<E>
	E specifies the type of object stored in the queue.

PriorityQueue defines the six constructors shown here:-
1) PriorityQueue()					// build an empty queue
2) PriorityQueue(int capacity)				// build an empty queue that has the specified initial capacity
3) PriorityQueue(int capacity, Comparator<?super E>comp)	// build a queue with the specfied capacity and comparator
4) PriorityQueue(Collection<? extends E>c)		// create a queue that are initialized with the elements of the collection c
5) PriorityQueue(PriorityQueue<? extends E>c)		// create a queue that are initialized with the elements of the collection c
6) PriorityQueue(SortedSet<? extends E>c)		// create a queue that are initialized with the elements of the collection c





Example:-




	ArrayDeque :------------

Java SE6 added the ArrayDeque class which extends AbstractCollection and implements the Deque interface.
It adds no methods of its own.
ArrayDeque creates a Dynamic Array and has no capacity restriction.
ArrayDeque is a generic class that has this declaration.

	class ArrayDeque<E>
	Here, E specifies the type of object stored in the collection
	
	ArrayDeque defines the following constructors:
	1) ArrayDeque()				// builds an empty deque its starting capacity is 16
	2) ArrayDeque(int size)			// builds a deque that has the specified initial capacity
	3) ArrayDeque(Collection<? extends E>c)		// create a deque that is initialized with elements of the collection passed in c

Example=>

import java.util.*;
class demo
{
	public static void main(String [] args)
	{
		ArrayDeque<String> adq=new ArrayDeque<String>();

		adq.push("A");
		adq.push("B");
		adq.push("D");
		adq.push("E");
		adq.push("F");

		System.out.println("Poping the Stack : ");
		while(adq.peek()!=null)
		{
			System.out.print(adq.pop()+" ");
			System.out.println();
		}

	}
}


output=>
Popping the stack : F E D B A



	Using an Iterator :----------------

Before you can access a collection through an iterator you must obtain one. Each of the collection classes provides an iterator() method that return to the start of the collection . by using iterator object you can access each element in the collection one element at a time . In general to use an iterator to cycle through the contents of a collection follow these steps:


1) Obtains an iterator to the start of the collection of the collection by calling the collectio's iterator()
2) Set up look that makes a call to hasNext() hace the loop iterator as hasNext() returns true.
3) within the loop obtain each element by calling next().


=>You can also obtain an iterator by calling listIterator( ). As explained, a list iterator gives you the ability to access the collection in either the forward or backward direction and lets you modify an element. Otherwise, ListIterator is used just like Iterator.





					         --------------: Map :---------------

A Map is an object that stores associations between keys and values or key/value pairs. Given a key you can find its value.
Both keys and values are objects.
The keys must be unique but the values may be duplicate.
some map can accept a null key and null values other cannot.
Map interface maps unique keys to values.
A keys an object that you use to retrieve a value at a later date.
Given a key and a value you can store the value in a Map object.
After the value is stored you can retrieve it by using its key.



There is one key point about maps that is important to mention at all the outset they don't implement the iterable interface. this means that you cannot cycle through a map using a for-each style for loop . Furthermore you can't obtain an iterator to a map. However as you will son see you can obtain a collection view of a map which does allow the use of either the for loop or an iterator.
 
Following Interfaces support maps:

	Interface			Description

	Map			Maps unique Keys to values
	Map.Entry			Describe an element(a key/value pair) in a map
	NevigableMap		Extends SortedMap to handle the reterival of entries based on closet match
	SortedMap		Extends Map so that the Keys are maintained in ascending order



	The Map Interface:-----------
The Map interface maps unique keys to value .A key is an object that you use to reterive a value at a later data. Given a key and value you can store the value in a Map object. After the value is stored you can reterive it by using its key.

	Map is generic and is declared as shown here:
	interface Map<K, V>

	Here K specifies the type of key and V specifies the type of value.


Operation in Map:---
	
	1) put() 		// to put a value into a map
	2) get()		// to obtain a value from the map passing key as a argument



As mention earlier although part of the collection Framework maps are not themselves collection because they do not implement the collection interface.





	SortedMap Interface :----------

The SortedMap interface extends Map.
It ensure that the entries are maintain in ascending order based on the keys


	interface SortedMap<K, V>
	Here K specifies the type of keys and V specifies the type of values

Sorted maps allow very efficient manipulations of submaps (in other words subsets of a map)
To obtain a submap use   headMap()  tailMap()  subMap()  
to get first key in the set call firstKey()
to get last key use lastKey()







	NevigableMap Interface :-------------

The NevigableMap interface was added by java SE6
It extends SortedMap and declares the behavior of a map that supports the retrieval of entries based on the closest match to a given key or keys.
NevigableMap is a generic interface that has this declaration:

	interface NevigableMap<K,V>
Here K specify the type of the keys and V specifies the types of the values associated with keys.



	
	 Hashtable :-----------

Hashtable was part of the original java.util and is concrete implementation of a Dictionary.
However with the advent of collections Hashtable was reengineered to also implements the Map Interface.
Hashtable is now integrated into the Collections Framework
It is similar to HashMap but is synchronized.

HashMap, HashTable store key/value pairs in a hash table.
Neither key nor value can be null.
When using a HashTable you specify an object that is used as a key and the value that you want linked to the key.
The key is then hashed and the resulting hash code is used as the index at which the value is stored with the code.


=> It is similar to HashMap but is synchronized
=> Hashtable stores key / value pair in hash table that has initial size specified by size.
=> in Hashtable we specify an object that is used as a key and the value we want to associate to that key



Constructor:-

1) Hashtable() 			this is default constructor
2) Hashtable(int size)		this creates a hash table that has initial size specified by size
3) Hashtable(int size,float fillratio)	this version creates a table that has initial size specified by size and fill ratio specified by fillratio




Methods:---

1) void clear()	 methods clears the hashtable so that it contains no keys	
	
	syntax:  public void clear()
	return:	NA
	Execption: NA


2) Object clone()	used to create shallow copy of this hashtable

	syntex:	public Object clone()
	Returns	method call returns a clone of the hashtable
	Exception	NA



Example=>

import java.util.*;
class demo
{
    public static void main(String [] args)
    {
        Hashtable<Integer,String> h=new Hashtable<Integer,String>();
        Hashtable<Integer,String> h1=new Hashtable<Integer,String>();


        h.put(3,"Ali");
        h.put(2,"Hasan");
        h.put(1,"Khan");
        System.out.println("Value in Original Hash table : "+h);
        h1=(Hashtable<Integer,String>)h.clone();

        System.out.println("Value in Clone : "+h1);
        h.clear();
        System.out.println("Value in Original Hash table : "+h);    // now it is null

    }
}




Output=>
D:\VS>javac caller.java
Note: caller.java uses unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.

D:\VS>java demo
Value in Original Hash table : {3=Ali, 2=Hasan, 1=Khan}
Value in Clone : {3=Ali, 2=Hasan, 1=Khan}
Value in Original Hash table : {}








	 


	The Map.Entry Interface :--------------

The Map>entry interface enables you to work with a map entry. Recall that the entrySet() method declared by the Map interface returns a Set containing the map entries . Each of these set elements is a Map>Entry object

	Map.Entry is generic and is declared like this:

	interface Map>entry<K,V>
Here,K specifies the  type of keys and V specifies the type of values the method declared by Map>entry





	The Map Classes:---------

Several classes provide implementation of the map interfaces. The classes that can be used for map are summerized here:----

	Classes		Description

	AbstractMap	Implement method of the Map interface
	EnumMap		Extends AbstractMap for use with enum keys
	HashMap		Extends AbstractMap to use a hash table
	TreeMap		Extends AbstractMap to use a tree
	WeakHashMap	Extends AbstractMap to use a hash table with weak keys.
	LinkedHashMap	Extends AbstractMap to allow insertion-order iterations
	IdentityHashMap	Extends AbstractMap and uses reference equality when comparing documents.




	HashMap Class :--------

The HashMap class extends AbstractMap and implements the Map interface.
It uses Hash table to store the map.
this allow the execution time of get() and put() to remain constant even for large set.
HashMap is generic classe that has this declaration

	class HashMap<K,V>
	Here, K specifies the type of keys and V specifies the type of values

Following constructor:-
	HashMap()				// default hash map
	HashMap(Map<?extends K,?extends V>m)	// initializes hash map by using the element of m
	HashMap(int capacity)			// initialize the capacityof hash map
	HashMap(int capacity, float fillRatio)		// initilize both capacity and fill ratio

HashMap implements Map and extends AbstractMap. It doesn't add any methods of its own.
It should not guarantee the order of its elements.

Example
	
	import java.util.*;
	class demo
	{
	    public static void main(String [] args)
	    {
	        HashMap<String,Double> hm=new HashMap<String,Double>();
	        //put element to the map

	        hm.put("Jhon Doe",new Double(3434.34));
	        hm.put("Tom Smith",new Double(123.22));
	        hm.put("Jane Baker",new Double(1378.00));
	        hm.put("Tod Hall",new Double(99.22));
	        hm.put("Ralph Smith",new Double(-19.08));

	        //Get a set of the entries
	        Set<Map.Entry<String,Double>> set=hm.entrySet();

	        //Display the Set
	        for(Map.Entry<String,Double>me:set)
	        {
	            System.out.print(me.getKey()+": ");
	            System.out.println(me.getValue());
	        }
	        System.out.println();
	        //deposite 1000 into Jhon Doe account
	        double balance=hm.get("Jhon Doe");
	        hm.put("Jhon Doe",balance+1000);

	        System.out.println("John Doe's new balance : "+hm.get("Jhon Doe"));
	    }
	}


output=>
D:\VS>java demo
Tod Hall: 99.22
Jhon Doe: 3434.34
Ralph Smith: -19.08
Tom Smith: 123.22
Jane Baker: 1378.0

John Doe's new balance : 4434.34

After Jhon Doe account is updated the hash map will still contain just one "Jhon Doe" account.



	TreeMap Class :------------

TreeMap class extends AbstractMap and implements the NevigableMap interface.
It create maps sorted in a tree structure
A TreeMap provides an efficient means of storing key/value pairs in sorted order and allow rapid reterival.
TreeMap guarantees that its elements will be sorted in ascending key order

	TreeMap is generic class that has this declaration
	class TreeMap<K,V>
	Here, K specifies the type of Keys, and V specifies the type of values.
	
	The following TreeMap constructors are defined:
	TreeMap()					// an empty tree map that will be sorted	
	TreeMap(Comparator<?super K>comp)		// an empty tree based map that will be sorted by using the comparator
	TreeMap(Map<?extends K,?extends V>m)		// initialize a tree map with the entries from m
	TreeMap(SortedMap<K,?extends V>sm)		// initialize a tree map with the entries from sm

Example=>
	import java.util.*;
	class demo
	{
	    public static void main(String [] args)
	    {
	        TreeMap<String,Double> hm=new TreeMap<String,Double>();
	        //put element to the map

	        tm.put("Jhon Doe",new Double(3434.34));
	        tm.put("Tom Smith",new Double(123.22));
	        tm.put("Jane Baker",new Double(1378.00));
	        tm.put("Tod Hall",new Double(99.22));
	        tm.put("Ralph Smith",new Double(-19.08));

	        //Get a set of the entries
	        Set<Map.Entry<String,Double>> set=tm.entrySet();

	        //Display the Set
	        for(Map.Entry<String,Double>me:set)
	        {
	            System.out.print(me.getKey()+": ");
	            System.out.println(me.getValue());
	        }
	        System.out.println();
	        //deposite 1000 into Jhon Doe account
	        double balance=tm.get("Jhon Doe");
	        tm.put("Jhon Doe",balance+1000);

	        System.out.println("John Doe's new balance : "+tm.get("Jhon Doe"));
	    }
	}


output=>
D:\VS>java demo
Jane Baker: 1378.0
Jhon Doe: 3434.34
Ralph Smith: -19.08
Tod Hall: 99.22
Tom Smith: 123.22

John Doe's new balance : 4434.34



	LinkedHashMap Classes:----------

LinkedHashMap extends HashMap
It maintains a linked list of the entries in the map, in the order in which they were inserted.
it allow insertion order iteration over the map.
Element will be returned in the order in which they were inserted

LinkedHashMap is a generic class that has this declaration:-

	class LinkedHashMap<K,V>
	Here, K specifies the type of Keys and V specifies the type of values.
	

LinkedHashMap defines the following constructor:
	
	LinkedHashMap()					// default constructs a LinkedHashMap
	LinkedHashMap(Map<?extends K,?extends V>m)		// initializes the LinkedHashMap with element from m
	LinkedHashMap(int capacity)				// initialize the capacity
	LinkedHashMap(int capacity,float fillratio)			// initialize both fill ratio and capacity
	LinkedHashMap(int capacity,float fillratio,boolean Order)	// 



	IdentityHashMap Classes:---------

IdentityHashMap extends AbstractMap and implements the Map interface.
It is similar to HashMap except that it uses reference equality when compared elements.

IdentityHashMap is a generic class that has this declaration:
	class IdentityHashMap<K,V>
	here Kspecifies the type of keys and v specifies the type of value.
 



	EnumMap Classes:---------

EnumMap extends AbstractMap and implements the Map interface.
It is specifically for use with keys of an enum type 

EnumMap is a generic class that has this declaration:
	class EnumMap<K extends Enum<K>,V>
	here K specifies the type of keys and V specifies the type of value.


	EnumMap defines the following Constructor:
	
	Enummap<Class <K> ktype>
	EnumMap<Map<K,?extends V>m>
	EnumMap(EnumMap<K,?extends V>em) 




	Comparators :-----------

Both TreeSet and TreeMap store elements in sorted order. However it is the comparator that defines precisely what "sorted order" means.
By default these classes store their elements by using what java refers to as "natural ordering" which is usually the ordering that you would except(A before B, 1 before 2, and so forth).
if you want to order elements a different way then speciy a comparator when you construct the set or map.

	Comparator is a generic interface that has this declaration:
	interface Comparator<T>
	Here T specifies the type of object being compared

The Comparator interface defines two methods
1) compare()
2) equals()

The compare() method shown here compare two element for order:
  	int compare(T obj1,T obj2)
	obj1 and obj2 are the object to be compared
	these method return zero if the objects are equal
	it return positive value if obj1 is greater than obj2 otherwise megative value is returned

	By overriding compare() you can alter the way that object are ordered

The equals() method show here tests whether an object equals the invoking comparator:
	
	boolean equals(Object obj)
	Here obj is the object to be tested for equality. the method returnn true if obj and the invoking object are both Comparator object and 	use the same ordering.Otherwise ,it return false 




                                                               ------------------------:Legacy Classes and Interface:--------------------------

>The early version of java.util did not include the  collection framework instead  it define several classes and an interface that provided an ad hoc method of storing object.when collection were added (by JSE 1.2) several of the original classes were reengineered to support the collection framework interface.


one other point : none of the collection classes are synchronized but all the legacy classes are synchronized.
we can easily synchronized collection too by using one of the algoeithm provided by collections.



>The Legacy classes define by java.util are shown here.
                       >Dictonary       >Hashtable       >Properties      >Stack      >Vector


	Enumeration Interface :-------------------
There is one legacy interface Enumeration

 this interface define the methods by which u can enumerate (obtain one at a time) the element is a collection of object however it is used by       several methods define by the legacy classes(such as Vector and Properties) an d used by several other API classes.

it has this declaration:

	interface Enumeration<E>
where E specifies the type of element being enumerated.

Enumeration specifies the following two methods:
1) boolean hasMoreElements()
2) E nextElement()


When implemented, hasMoreElements( ) must return true while there are still more elements to extract, and false when all the elements have been enumerated. nextElement( ) returns the next object in the enumeration. That is, each call to nextElement( ) obtains the next object in
the enumeration. It throws NoSuchElementException when the enumeration is complete.
 

	Vector :----------------

Vector implements a dynamic array.it is similer to Arraylist but two difference

 1)Vector is synchronized
  2)it contains many legacy methods that duplicate the functionality of  the methods define by the collection framework

Vector is declared like this:

	class Vector<E>
	Here E specifies the type of element that will be stored
	Here are the vector constructors:

	Vector()				// it create a default vector
	Vector(int size)			// create a vector whose initial capacity is specified by size
	Vector(int size,int incr)		// create a vector whose initial capacity is specified by size and increment is specied by 
	Vector(Collection<?extends E>c)	//create a vector that contains the elements of collection c

vector can have its contains iterated by the enhance for loop




Because Vector implements List, you can use a vector just like you use an ArrayList instance. You can also manipulate one using its legacy methods. For example, after you instantiate a Vector, you can add an element to it by calling addElement( ). To obtain the element at a specific location, call elementAt( ). To obtain the first element in the vector, call firstElement( ). To retrieve the last element, call lastElement( ). You can obtain the index of an element by using indexOf( ) and lastIndexOf( ). To remove an element, call removeElement( ) or removeElementAt( ).


Example=>
	import java.util.*;
	class vector_class
	{
	    public static void main(String [] args)
	    {
	        Vector<Integer> v=new Vector<Integer>(3,2);
	        System.out.println("Initial Size : "+v.size()+" Initial Capacity : "+v.capacity());

	        v.addElement(1);
	        v.addElement(2);
	        v.addElement(3);
	        v.addElement(4);
	        System.out.println("Capacity after four additions : "+v.capacity());
	        v.addElement(5);
	        System.out.println("Current Capacity : "+v.capacity());
	        v.addElement(6);
	        v.addElement(7);
	        System.out.println("Current Capacity : "+v.capacity());

	        v.addElement(9);
	        v.addElement(10);
	        System.out.println("Current Capacity : "+v.capacity());
	
	        v.addElement(11);
	        v.addElement(12);
	        System.out.println("First Element : "+v.firstElement());
	        System.out.println("Last Element : "+v.lastElement());

	        if(v.contains(3))
	        {
	            System.out.println("Vector contains 3");
	        }
        
	        Enumeration vEnum=v.elements();
	        System.out.println("\nElements in Vector : ");
	        while(vEnum.hasMoreElements())
	        {
	            System.out.print(vEnum.nextElement()+" ");
	            System.out.println();
	        }
	    }
	}


output=>

D:\VS>java vector_class
Initial Size : 0 Initial Capacity : 3
Capacity after four additions : 5
Current Capacity : 5
Current Capacity : 7
Current Capacity : 9
First Element : 1
Last Element : 12
Vector contains 3

Elements in Vector :
1
2
3
4
5
6
7
9
10
11
12




	Stack :----------

Stack is a subclass of vector that implements a standard last-in, first out stack.
Stack only defines the default construcor which create an empty stack.

	class Stack<E>
	Here E specifies the type of the element stored in the stack

Stack includes all the methods defines by vector and adds several of its own,
To put an object on the top of the stack call push()
to remove and return the top element call pop()


Example=>

import java.util.*;
class demo
{
	static void showpush(Stack<Integer> st,int a)
	{
		st.push(a);
		System.out.println("push("+a+")");
		System.out.println("stack : "+st);
	}

	static void showpop(Stack<Integer> st)
	{
		System.out.print("pop -> ");
		Integer a=st.pop();
		System.out.println(a);
		System.out.println("stack : "+st);
	}

	public static void main(String [] args)
	{
		Stack<Integer> st=new Stack<Integer>();
		System.out.println("stack : "+st);
		showpush(st,42);
		showpush(st,66);
		showpush(st,99);
		showpop(st);
		showpop(st);
		showpop(st);

		try
		{
			showpop(st);
		}
		catch(EmptyStackException e)
		{
			System.out.println("Empty stack");
		}
	}
}



Output=>


D:\Hacker\collectionframework>javac demo.java

D:\Hacker\collectionframework>java demo
stack : []
push(42)
stack : [42]
push(66)
stack : [42, 66]
push(99)
stack : [42, 66, 99]
pop -> 99
stack : [42, 66]
pop -> 66
stack : [42]
pop -> 42
stack : []
pop -> Empty stack



>Hashtable was a part of the original java.util.
and is concrete implementation of a Dictonary

>Properties is subclass of Hashtable it is used t maintain lists os values in which the key is a string and value is also is string.
properties also contain one deprecated method  save() this was replace by store() because save() did not handle error correctly.

>StringTokenizer
parsing-->it is the division of text into set of discrete part or tokens..
->stringtokenizer provides the parsing alsoo called lexer (lexical analysier)
->to use stringtokenizer we  specify a input string and string that contains deliminators(charcter that separate tokens )like (,:;)
->as we create StringTokenizer object the<<<<<  nextToken()  >>>>method is usedd to extract consecutive tokens.
->   <<<  hasMoreTokens()    >> methods return true while there are more tokens to  be extracted...

Constructer of StringTokenizer
1)StringTokenizer(String str)
2)StringTokenizer(String str,String delimiters)
3)StringTokenizer(String str,String delimiters,boolean delimAsToken)


--: Java program for converting the list in to the Array :--

import java.util.*;
class demo
{
	public static void main(String [] args)
	{
		ArrayList<Integer> al=new ArrayList<Integer>();
		Scanner sc=new Scanner(System.in);
		System.out.println("Enter The Element in the list");
		al.add(12);
		
		for(int i=0;i<5;i++)
			al.add(sc.nextInt());  //taking the input from user in the List
		
		System.out.println(al);
		Integer s[]=new Integer[al.size()];
		s=al.toArray(s);
		for(Integer str:s)
			System.out.println(str);
		
	}
}

Note that the there is an array parameter and array return value. The main purpose of passed array is to tell the type of array. The returned array is of same type as passed array.

If the passed array has enough space, then elements are stored in this array itself.
If the passed array doesn’t have enough space, a new array is created with same type and size of given list.
If the passed array has more space, the array is first filled with list elements, then null values are filled.
It throws ArrayStoreException if the runtime type of a is not a supertype of the runtime type of every element in this list.




=> Second method for converting list to Array


import java.util.*;
class demo
{
	public static void main(String [] args)
	{
		Scanner sc=new Scanner(System.in);
		ArrayList<Integer> list=new ArrayList<Integer>();
		System.out.println("Enter Size of the List : ");
		int list_size=sc.nextInt();
		System.out.println("Enter Element in List : ");
		for(int i=0;i<list_size;i++)
		{
			list.add(sc.nextInt());
		}

		System.out.println("Element in ArrayList : \n"+list);

		int a[]=new int[list.size()];
		int new_length=list.size();
		for(int i=0;i<new_length;i++)
		{
			a[i]=list.get(i);
		}

		System.out.println("Element in the Array : ");
		for(int i=0;i<new_length;i++)
		{
			System.out.print(a[i]+" ");
		}

	}
}


Output=>
D:\Hacker\collectionframework>javac demo.java

D:\Hacker\collectionframework>java demo
Enter Size of the List :
5
Enter Element in List :
6
9
4
1
5
Element in ArrayList :
[6, 9, 4, 1, 5]
Element in the Array :
6 9 4 1 5




//java program Collections class to sort the list
import java.util.*;

class demo
{
    public static void main(String [] args)
    {
        Scanner sc = new Scanner(System.in);
        ArrayList<Integer> list = new ArrayList<Integer>();
        System.out.println("Enter the Size : ");
        int n=sc.nextInt();

        System.out.println("Enter the Element in the Array List : ");
        for(int i=0;i<n;i++)
        list.add(sc.nextInt());

        System.out.println(list);

        Collections.sort(list);
        
        System.out.println(list);
    }
}




 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                                                                     Input and Output in Java
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  
                                                                  
In java there are three different ways for reading input from the user in the command line environment (console) :------

1) Using BufferedReader class
2) Using Scanner class
3) Using Console class



	Using BufferedReader class :---------------

this is the java classical method to take input
Introduced in JDK1.0
this method is used by wrapping the System.in (standard input stream) in an InputStreamReader which is wrapped in a BufferedReader we can read input from the user in the command line


Note=>
1) the BufferedReader always throw IOException
2) It always take input inform of String (so to get input in Integer we will have to convert it into Integer using parseInt() method )

Example=>

import java.io.*;
class demo
{
    public static void main(String [] args)
    {
        try
        {
            BufferedReader b=new BufferedReader(new InputStreamReader(System.in));
            System.out.println("Enter First Number : ");
            int first_number=Integer.parseInt(b.readLine());
            System.out.println("Enter Second Number : ");
            int second_number=Integer.parseInt(b.readLine());
            System.out.println("Summation of First and Second Number = "+(first_number+second_number));
        }
        catch(Exception e)
        {
            System.out.println(e);
        }
    }
}


Output=>


D:\java program>javac demo.java

D:\java program>java demo
Enter First Number :
12
Enter Second Number :
32
Summation of First and Second Number = 44




	
	Using Scanner class :---------------

This method is probably the most  preferred method to take input. the main purpose of the Scanner class is to parse primitive type and string using regular expressions, however it is also 
can be used to  read  input from the user in the combined line.

	Advantages

=> convenient methods for parsing primitives (nextInt() , nextFloat(),.......) from the tokenized input 
=> Regular expression can be used to find tokens.


	Drawback

=>the reading method are not synchronized


Example=>
import java.util.Scanner;
class demo
{
    public static void main(String [] args)
    {
        Scanner sc=new Scanner(System.in);
        System.out.println("Enter First Number : ");
        int first_number=sc.nextInt();
        System.out.println("Enter Second Number : ");
        int second_number=sc.nextInt();

        System.out.println("Summation of First and Second Number = "+(first_number+second_number));
    }
}


Output=>

D:\java program>javac demo.java

D:\java program>java demo
Enter First Number :
12
Enter Second Number :
32
Summation of First and Second Number = 44





	Using Console class :--------------

It has been becoming a preferred way for reading user's input from the command line. In addition it can be used for reading password like input without echoing the character entered by the user.


	Advantages

=> Reading password without echoing the entered characters
=> Reading method are synchronized
=> Format string syntax can be used


	Drawback
=>Doesn't  work in non-interactive environment (such as in an IDE)


Example=>

class demo
{
    public static void main(String [] args)
    {
        String name=System.console().readLine();
        System.out.println(name);
    }
}


Output=>


D:\java program>javac demo.java

D:\java program>java demo
ali hasan
ali hasan




	Using Command Line :----------------

we can also get the input form user by the command line

Example=>

class demo
{
    public static void main(String [] args)
    {
        int first_number=Integer.parseInt(args[0]);
        int second_number=Integer.parseInt(args[1]);

        System.out.println("Summation of First and Second Number = "+(first_number+second_number));
    }
}


output=>

D:\java program>javac demo.java

D:\java program>java demo 12 32
Summation of First and Second Number = 44




	Java Output :-----------

you can simply use System.out.println(), System.out.print() or System.out.printf() to send output to standard output (screen)

System is a class and out is a public static field which accepts output data




Java's stream-based I/O is built upon four abstract classes: InputStream, OutputStream, Reader and Writer

=>InputStream and OutputStream are designed for bytes stream .Reader and Writer are designed for charcter stream.
we should use charcter stream classes when working with charcters or string
use byte stream classes when working with bytes or other binary objects.

::::::::::;---Byte Stream::::::::;;;-----
=> the byte stream classes are topped by inputstream and output stream our discussion begins with them
=>  InputStream   is an abstract class that defines java's model of streaming input
=>  OutStream      is an abstract class that defines streaming byte output.

ByteStream throw IOException.s

=> FileInputStream  class creates an inputStream that u can use to read bytes from a file.

it having two constructor 
=> FileInputStream(String filepath)
=> FileInputStream(File path)

=> FileOutputStream create an OutputStream that you can use to write bytes to a file

it has four constructor
> FileOutputStream(String filepath)
> FileOutputStream(File fileobj)
> FileOutputStream(String filepath,boolean append)
> FileOutputStream(File fileobj,boolean append)




	OPERATOR OVERLOADING IN JAVA :---------------------

NO, Java doesn't support user-define operator overloading.the  only aspect of java which comes close to custom operator overloading is the handling of + for string which either result in compile time concatination of constants or execution time concatination using String Builder/String Buffer.
internally java overloads operator for example + is overloading for concatination.

these can be the observation about why java not support operator overloading :-

1) Simplicity and Cleanliness
2) Avoid Programming Error
3) JVM Complexity
4) Easy Development of tools 


 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                                                                          			Java Networking
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

One of the most important reasons that java is the premier language for the network programming are the classes defined in the java.net
package.

Networking is a concept of connecting two or more computing device together so that we can share resources.

Advantage:-
1) Sharing of Resources
2) Sharing of Information


At the core of java's networking support is the concept of a socket.
A socket indentifies an endpoint in a networking.

Socket communication takes place via a protocol. 
Internet Protocol (IP) is a low-level routing protocol that breaks data into small packets and sends them to an address across a network, which doesnot guarantee to deliver said packets to the destination


Transmission Control Protocol (TCP) is a higher-level protocol that manage to robustly string together these packets, sorting and retransmitting them as necessary to reliably transmit data.


User Datagram Protocol (UDP) sits next to TCP and can be used directly to support fast connectionless unreliable transport of packets.

Once a connection has been established a higher level protocol euuses which is dependent on which port you are using. TCP/IP reseves the lower 1-24 ports for specific protocol. Many of these will seem familier to you have spent any time surfing the Internet. Port number 21 is for FTP; 23 is for Telnet; 25 is for e-mail; 43 is for whois; 79 is for finger; 80 for HTTP.

HTTP is the protocol that web browser and servers use to transfer hypertext pages and images. It is quite simple protocol for a basic page browsing web server. Here's  how it work. When a client request a file from an HTTP server an action Known as a hit it simply sends the name of the file in a special format to predefined port and reads back the contents of the file. The server also responds with a status code tell the client whether or not the request can be fulfilled and why.


A key component of the internet is the address. Every computer on the internet has one address. An Internet address is a number that uniquely identifies each computer on the Internet.
		Originally all Internet address consistd of 32bit values organized as four 8-bit values. This address type was specifies by IPv4 (Internet Protocol version 4).
	However a new addressing scheme called IPv6 (Internet Protocol version ) has come into play. IPv6 uses a 128bit value to represent an address, organized into eight 16-bit chunks.


Just as the numbers of an IP address describe a network hierarchy the name of an Internet address called its domain name, describes a machine's location in a name space. For example www.osborne.com is in the COM domain (reserved for U.S commercial sites) it is called osborne (after the company name ), and www identifies the server for web request. An Internet domain name is mapped to an IP address by the Domain Naming Service (DNS). This enables users to work with domain names, but the Internet operates on IP addresses.



 
	Networking Classes and Interfaces :---------------
Java supports TCP/IP both by extending the already established stream I/O interface introduced and by adding the features required to build I/O object across the network. Java support both the TCP and UDP protocol families. TCP is used for reliable stream-based I/O across the network. UDP support a simpler hence faster point-to-point datagram-orinted model.

The classes contained in the java.net package are shown here:

	Authenticator	 		Inet6Address 			ServerSocket
	CacheRequest 			InetAddress 			Socket
	CacheResponse 			InetSocketAddress 			SocketAddress
	ContentHandler 			InterfaceAddress (Added byJava SE 6.)	SocketImpl
	CookieHandler 			JarURLConnection 			SocketPermission
	CookieManager (Added byJava SE 6.)	MulticastSocket 			URI
	DatagramPacket 			NetPermission 			URL
	DatagramSocket 			NetworkInterface 			URLClassLoader
	DatagramSocketImpl 		PasswordAuthentication 		URLConnection
	HttpCookie (Added byJava SE 6.)	Proxy 				URLDecoder
	HttpURLConnection 			ProxySelector 			URLEncoder
	IDN (Added by Java SE 6.) 		ResponseCache 			URLStreamHandler
	Inet4Address 			SecureCacheResponse



=> java.net package's interface  are listed here:


	ContentHandlerFactory 		DatagramSocketImplFactory 		SocketOptions
	CookiePolicy (Added by Java SE 6.) 	FileNameMap 			URLStreamHandlerFactory
	CookieStore (Added by Java SE 6.) 	SocketImplFactory




	InetAddress :-------------------

The InetAddress class is used to encapsulate both the numerical IP address and the domain name for that address. You interact with this class by using the name of an IP host, which is more convenient and understandable that its IP address. The InetAssress class hide the number inside .InetAddress can handle both IPv4 and IPv6 addresses.

	Factory Methods
The InetAddress class has no visible constructors. To create an InetAddress object you have to use one of the availabe factory methods. Factory methods are merely convention whereby static methods in a class return aninstance of that class.
Three commonly used InetAddress factory methods are shown here:

	static InetAddress getLocalHost()
		throws UnknownHostException
	
	static InetAddress getByName(String hostName)
		throws UnknownHostException

	static InetAddress[] getAllByName(String hostName)
		throows UnknownHostException


The getLocalHost() methods simply returns the InetAddress object that represent the local host.
The getByName() method return an InetAddress for host name passed to it. if these methods are uanle to resolve the host name they throw an UnknownHostException.




	TCP / IP Client Sockets :--------------
TCP/IP socket are used to implement reliable bidirectional presistent point-to-point stream based connections between hosts on the internet.
A Socket can be used to connect Java's I/O system to other programs that may reside either on the local machine or on any other machine on the internet.

There are two kind of TCP socket in java. One is for server and the other is for client .
The ServerSocket  class is designed to be a "listener" which waits for client to connect before doing anything. Thus ServerSocket is for Server.
The Socket class is for clients . It is designed to connect to server socket and initiate protocol exchanges. Because client socket are most commonly used by java application they are examined here.

The creation of scoket object implcitly established a connection between the client and server. There are no methods or constructors that explicitly expose the details of establishing that connection. 
	Here are two constructor used to create client sockets:


	

	Socket(String hostName, int port)		Creates a socket connected to the named host and port.
	throws UnknownHostException,
		IOException


	Socket(InetAddress ipAddress, int port)			Creates a socket using a preexisting InetAddress object and a port.
	throws IOException



Socket defines several instance methods. For example a Socket can be examined at  any time for the address and port information associated with it, by use of the following methods:


	InetAddress getInetAddress( ) 					Returns the InetAddress associated with the Socket
								object. It returns null if the socket is not connected.

	int getPort( ) 						Returns the remote port to which the invoking Socket
								object is connected. It returns 0 if the socket is not 								connected.

	int getLocalPort( ) 						Returns the local port to which the invoking Socket
								object is bound. It returns –1 if the socket is not bound.




Socket use  getInputStream() and getOutputStream() methods. Each can throw an IOException if the socket has been invalidated by a loss of connection. These stream are used to send and receive data.


	InputStream getInputStream( )			Returns the InputStream associated with the invoking socket.
	throws IOException

	OutputStream getOutputStream( )		Returns the OutputStream associated with the invoking socket.
	throws IOException



Several other methods are available including connect() which allows you to specify a new connection isConnected() which returns true if the socket is connected to server isBound() which returns true if the socket is bound to an address and isClosed() which returns true if the socket is closed.



	URL (Uniform Resource Locator) :-
Once you an reliably name anything and everything it become a very powerful paradigms. The Uniform Resource Locator (URL) does exactly that.
	The URL provides reasonably intelligible form to uniquely identify or address information on the Internet. URLs are ubiquitous every browser uses them to identify information on the web. Within java's network class library the URL class provides a simple concise API to access information across the Internet using URLs.




Java’s URL class has several constructors; each can throw a MalformedURLException. One commonly used form specifies the URL with a string that is identical to what you see displayed in a browser:

	URL(String urlSpecifier) throws MalformedURLException

The next two forms of the constructor allow you to break up the URL into its component parts:

	URL(String protocolName, String hostName, int port, String path) throws MalformedURLException

	URL(String protocolName, String hostName, String path) throws MalformedURLException

Another frequently used constructor allows you to use an existing URL as a reference context and then create a new URL from that context. Although this sounds a little contorted, it’s really quite easy and useful.

	URL(URL urlObj, String urlSpecifier) throws MalformedURLException





Basic Concept of Networking
1) IP Address
2) Protocol
3) Port Number
4) Connection oriented and connectionless protocol
5) Socket


Internet Protocol(IP)
it is a low level routing protocol that break data into small packets and send them to an address across a network, which doesn't guarantee to deliver said packets to the destination

Transmission Control Protocol(TCP)
it is a higher level protocol that manages to robustly string together these packets, storing and retransmitting them as necessary to reliably transmit data.

User Datagram Protocol (UDP)
it sits next to TCP and can be used directly to support fast connectionless unreliable transport of packets.

Port
					----------: Java Mail :----------



The JavaMail is an API that is used to compose ,write and read electronic message(emails).

The JavaMail API provides protocol-independent and plateform-independent framework for sending and receiving mails.

The javax.mail and javax.mail.activation packages contains the core classes of JavaMail API.

Protocols used in JavaMail API
There are some protocols that are used in JavaMail API.
SMTP ( It provides a mechanism to deliver the email )
POP    ( It provides a mechanism to receive the email. )
IMAP   ( It provides support for multiple mail box for each user ,in addition to, mailbox can be shared by multiple users.)
MIME   ( Multiple Internet Mail Extension (MIME) tells the browser what is being sent e.g. attachment, format of the messages etc. It is not known as mail transfer protocol but it is used by your mail program.)

Java mail Architecture:
the java application uses javamail api to compose send and receive emails.the java mail api uses SPI(Service Provider interface) that provides the intermediatory service to the java application to deal with the different protocol.



JavaMail Architecture

The java application uses JavaMail API to compose, send and receive emails. The JavaMail API uses SPI (Service Provider Interfaces) that provides the intermediatory services to the java application to deal with the different protocols.


There are two packages that are used in Java Mail API: javax.mail and javax.mail.internet package. These packages contains many classes for Java Mail API. They are:

javax.mail.Session class
javax.mail.Message class
javax.mail.internet.MimeMessage class
javax.mail.Address class
javax.mail.internet.InternetAddress class
javax.mail.Authenticator class
javax.mail.PasswordAuthentication class
javax.mail.Transport class
javax.mail.Store class
javax.mail.Folder class 



NNTP and others




 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                                                                           JAVA Applet and Swing
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  

The Applet class is contained in the java.applet pagkage.
Applet contain several methods that give you details control over the execution of your applet.

java.applet also define three interfaces 

1)	AppletContext
2)	AudioClip
3)	AppletStub


Two types of applet:-

1)
 First are based directly on the applet class described in this chapter. This uses the Abstract Window Toolkit (AWT) to provide the graphics  user interface

2)
The second type of applet are those based on the swing class JApplet. Swing Applet use the swing classes to provide the GUI Swing classes
 to provide the GUI.


=> They run within either a web browser or an applet viwer called appletviewer
=> Execution of an applet does not begin at main(). Actually few applet even have main() methods .
=> Output to your applet's window is not performed by System.out.println() Rather in non-swing applet output is handled with various AWT                methods such as drawString() which outputs a string to s specified X,Y location

=> to use an applet it is specified in an Html file

	/*
		<applet code="MyApplet" width=200 height=60></applet>
	*/




	
				        ------------: Applet Initialization and Termination :----------

It is important to understand the order in which the various methods showns in the skeleton are called. When an applet start the following methods are called in this sequence

1) init()
2) start()
3) paint()

when applet is terminated the following sequence of methods calls take palce
1) stop()
2) destroy()


1) init()

This method is the first method to be called.
The init method is the first method to be called. This is when you should initialize variables.
This method is called only once during the run time of your applet.


2) start()

the start() method is called after init() it is also called to restart an applet after it has been stopped . Whereas init() is called once the first time an applet is loaded start() is called each time an applet's HTML document is displayed onscreen.


3) paint()

The paint() method is called each time your applet's output must be redrawn. this situation can occur for several reason
example- the window in which the applet is running may be overwritten by several another window and then uncovered. or applet window may be minimized and then restored
paint() is also called when the applet begin execution
whenever the applet must redraw its output paint() is called
paint method has one parameter of type Graphics.

Invoked immediately after the start() method and also any time the applet needs to repaint itself in the browser the paint() method is actually inherited from the java.awt.




java.applet.Applet;
java.awt.Graphics;

Without those import statement the java compiler would not recognize the classes Applet and Graphics which the applet class refer to.


4) stop()

The stop() method is called when a web browser leaves the HTML document containing the applet when it goes to another page for example.
when stop() is called the applet is probably running.
you should use stop() to suspend thread that don't need to run when the applet is not visible.
you can restart when start() is called.


5) destroy()
The destroy() method is called when the enviroment determine that your applet needs to removed completely from memory

Overriding update()
In some situation your applet may need to override another method defined by the AWT called update().
This method is called when your applet has requested  that portion of its window be redrawn.
The default version of update() simply calls paint().t


To output a string to an applet use drawString() which is a member of the Graphics class.
Typically it is called from within either update() or paint() it has the following general form.

	void drawString(String message, int x int y)


To set the back ground color of an applet's window use setBackground()
To set the fore ground color of text in window use setForeground()

to set color for the text or background
	Color.black
	Color.blue
	Color.cyan
	Color.darkGray
	Color.magenta
	Color.orange
	Color.pink
	Color.red



Example=>

import java.awt.*;
import java.applet.*;
/*
<applet code="caller" width=300 height=50></applet>
*/
public class caller extends Applet
{
    String msg;
    public void init()
    {
        setBackground(Color.pink);
        setForeground(Color.red);
        msg="Ali Hasan";
    }
    public void start()
    {
        msg+="Ali Hasan";
    }
    public void paint(Graphics g)
    {
        msg+="Ali Hasan";
        g.drawString(msg, 10, 30);
    }
} 





=>There are two standard ways in which you can run an applet:
1) Execution the  applet with in a java-compatiable web browser
2) Using an applet viewer such as standard tool appleiviewer An appletviewer executes your applet in a window . This is generally the fastet and easiest way to test your applet.



=> Using java enable web browser: To execute an applet in a web browser we have to write a whort HTML text file coutains a tag that load  the applet . we can use applet or object tag for this purpose.




					------------: Status Window :---------

In addition to displaying information in its window, an applet can also output a message to the status window of the browser or applet viewer on which it is running.
		to do so call 	showStatus() with string that you want to display.


Example=:
		import java.applet.*;
		import java.awt.*;
		public class caller extends Applet
		{
		    public void init()
		    {
		        setBackground(Color.pink);
		        setFont(new Font("TimesRoman",Font.BOLD | Font.ITALIC,20));
		    }
		    public void paint(Graphics g)
		    {
		        g.drawString("This is in the Applet",12,12);
		        showStatus("This is the status of window");
		    }
		}




					--------------: HTML APPLET Tag :-------------

As mentioned earlier sun currently recommended that the APPLET tag be used to start an applet from both an HTML document and from an applet viewer.

An Applet viewer will execute each APPLET tag that it finds in a separeate windows while

web browser will allow many applet an a single page.


Fuller form of HTML

<APPLET
	[CODEBASE=codeURL]
	CODE=appletFile
	[ALT=alternateText]
	[NAME=appletInstanceName]
	WIDTH=pixels
	HEIGTH=pixels
	[ALIGN=alignment]
	[VSPACE=pixels]
	[HSPACE=pixels]
>
[<PARAM NAME=AttributeName VALUE=attributeValue>]
[<PARAM NAME=AttributeName2 VALUE=attributeValue>]
...
[HTML Displayed in the absence of java]
</APPLET>



=> CODEBASE

=>PRAM NAME & VALUE
The PARAM tag allow you to specify applet specify argument in an HTML page.
APPLET access their attribute with the  getParameter()  method.




				                --------: Passing Parameters to Applet :-------

getParameter() method return the value of the specified parameter in the form of a string object.

Example=>
	/*
	<applet code="caller" width=300 height=50>
	<param name=fontName value=Courier>
	<param name=fontSize value=14>
	<param name=leading value=2>
	<param name=accountEnable value=true>
	</applet>
	*/
	public class caller extends Applet
	{
	    String fontName;
	    int fontSize;
	    float leading;
	    boolean active;
	
	    public void start()
	    {
	        String param;
	        fontName=getParameter("fontName");
	        if(fontName==null)
	        {
	            fontName="Not Found";
	        }
	        param=getParameter("fontSize");
	        try
	        {
	            if(param!=null)
	            {
	                fontSize=Integer.parseInt(param);
	            }
	            else
	            {
	                fontSize=0;
	            }
	        }
	        catch(NumberFormatException e)
	        {
	            fontSize=-1;
	        }
	
	        param=getParameter("leading");
	        try
	        {
	            if(param!=null)
	            {
	                leading=Float.valueOf(param).floatValue();
	            }
	            else
	            {
	                leading=0;
	            }
	        }
	        catch(NumberFormatException e)
	        {
	            leading=-1;
	        }
		
	        param=getParameter("accountEnabled");
	        if(param!=null)
	        {
	            active=Boolean.valueOf(param).booleanValue();
	        }
	
	    }
	        public void paint(Graphics g)
	        {
	            g.drawString("Font name: "+fontName,0,12);
	            g.drawString("Font size: "+fontSize,0,25);
	            g.drawString("Leading: "+leading,0,40);
	            g.drawString("Account Active: "+active,0,58);
	        }
	}



				               -------------: Displaying Image in Applet :----------

Applet is mostly used in games and animation . For this purpose image is required to be displayes. the java.awt.Graphics alss provide a methods drawImage() to display an image.


	Syntex of drawImage() method:

	1) public abstract boolean drawImage(Image img,intx,int y,ImageObserver observer) is uaed to draw the specified image.



	Hpw to get the object of Image :---------------

The java.applet.Applet class provide getImage() method that returns the object of Image

	public Image getImage(URL u,String image)

	


	Other required methods of Applet class to display image :--------------------

1) public URL getDocumentBase()  is used to return the URL of the document in which applet is embedded.
2) public URL getCodebase() is used to return the base URL.









					 ------------: Event Handling :------------

An event is an object that describes a state change in a source.
Some of the activities that cause events to be generated are pressing a button , entering a character via the keyboard, selecting an item in a list, and clicking the mouse.

Events may also occurs that are not directly caused by interaction with a user interface.
example=> an event may be generated when a timer expire a counter exceeds a value etc.



	Event Sources:---------

A source is an object that generate an event.
this occurs when the internat state of the object chanegs in some way.

General Form of an Event:
			public void addListener(TypeListener el)
Here,
	Type is the name of event
	el is a reference to the event listener

KeyboardListener 		addKeyListener()
mouse motion listener	addMouseListener()




	EventListener :--------

A listener is an object that is notified when an object event occurs.
It has two major requirement.

First =>
it must have been registered with one or more sourde to receive notification about specific type of events

Second =>
it must implements methods to recieve and process these notification

The methods that receive and process events are defined in a set of interfaces found in java.awt.event.
MouseMotionListener interface define teo methods to receive notifications when the mouse is dragged or moved.
Object may receive and process one or both of these events if it provides an implemention of this interface.

	EventClasses :---------
At the root f the event class hierarchy is EventObject, which is in java.util It is the superclass for all events.
Its one constructor is shown here:

	EventObject(Object src)
Here src is the object that generates this event.
EventObject contains two methods: getSource() and toString().

get Source() methods returns the source of the event. Its general form is shown here:
	Object getSource()

	toString() returns the string equivalent of the event.




	ActionEvent Class :-------------

An ActionnEvent is generated when a button is pressed, a list item is double-clicked or a menu item is selected.
ActionEvent class define four integer constants that can be used to identify any modification associated with an event:
ALT_MASK, ATRL_MASK, META_MASK and SHIFT_MASK

ActionEvent has three constructor:
1) ActionEvent(Object src,int type,String cmd)
2) ActionEvent(Object src,int type,String cmd,int modifiers)
3) ActionEvent(Object src, int type, String cmd, long when, int modifiers)

Here src is a reference to the object that generated this event
the type of the event is specified by type and its command string is cmd.
the argument modifier indicate which modifier keys(ALT,CTRL,META and/or SHIFT) were pressed when the event was generated.
when parameter specifiy when the event occur.









					-----------------: Java Swing  :------------------


Java Swing is a part of Java Foundation class(JFC) that is used to create window based application. It is built on the top of AWT(Abstract window tool kit) API and entirely written in java.

Unlike AWT.. Swing provide platform independent and lightweight components.
Java swing package provides classes for java swing API such as JButton, JTextField, JTextArea, JRadioButton, JCheckbox, JMenu, JColorChooser etc.



Example=>


import javax.swing.*;
public class Applet_Demo
{
	public static void main(String [] args)
	{
		JFrame JF=new JFrame();
		JButton b=new JButton("Click");
		b.setBounds(130, 100, 100, 40);
		
		JF.add(b);
		JF.setSize(400,500);
		JF.setLayout(null);
		JF.setVisible(true);
	}
}




	We can also write all the codes of creating JFrame, JButton and methods call inside the java constructor.


import javax.swing.*;
public class Applet_Demo
{
	JFrame JF;
	Applet_Demo()
	{
		JF=new JFrame();
		JButton b=new JButton("Click");
		b.setBounds(130, 100, 100, 40);
		
		JF.add(b);
		JF.setSize(400,500);
		JF.setLayout(null);
		JF.setVisible(true);
	}

	public static void main(String [] args)
	{
		new Applet_Demo();
	}
}





	Simple example of swing by inheritane :-----------------

we can also inherit the JFrame class so there is no create the instance of JFrame class explicitly.

import javax.swing.*;
public class Applet_Demo extends JFrame
{
	JFrame JF;
	Applet_Demo()
	{
		JButton b=new JButton("Click");
		b.setBounds(130,100,100,40);
		add(b);
		setSize(300,300);
		setLayout(null);
		setVisible(true);
	}

	public static void main(String [] args)
	{
		new Applet_Demo();
	}
}






	=> Java Button :-------------

The JButton class is used to create a labeled button that has plateform independent implementation  application result in some action when the button is pushed . It inherits AbstractButton class.


	JButton class declaration:

	public class JButton extends AbstractButton implements Accessible

	

	Commonly used Constructor:-

1) JButton()		it create a button with no text and icon.
2) JButton(String s)		it create a button with the specified text.
3) JButton(Icon i)		it create a button with the specified icon



	Commonly used Methods of AbstractButton class :-----------

1) void setText(String s)		it is used to set specified text on button
2) String getText()			it is used to return the text of the button
3) void setEnabled(boolean b)		it is used to enable or disable the button
4) void setIcon(Icon b)		it is used to set the psecified icon on the button
5) Icon getIcon()			it is used to get the icon of the button
6) void setMnemonic(int a)		it is used to set the mnemonic on the button
7) void addActionListener(ActionListener a)it is used to add the actionlistener to this object.




	Java JButton Example:---------------

import javax.swing.*;
public class Applet_Demo 
{
	public static void main(String[] args)
	
	{
	JFrame j=new JFrame("Button Example");
	JButton jb=new JButton("Click");
	jb.setBounds(50,100,95,30);
	j.add(jb);
	j.setSize(400,400);
	j.setLayout(null);
	j.setVisible(true);
	}

}




	Example Java JButton with ActionListener :----------------

import javax.swing.*;
import java.awt.event.*;
public class Applet_Demo 
{
	public static void main(String [] args)
	{
		JFrame f=new JFrame("Button Example");
		JTextField tf=new JTextField();
		tf.setBounds(50,50,150,20);
		
		JButton b=new JButton("Click Here");
		b.setBounds(50,100,95,30);
		
		b.addActionListener(new ActionListener()
		{
		
		public void actionPerformed(ActionEvent e)
		{
			tf.setText("Welcome to Ali Hasan Area : ");
		}
		});
		
		f.add(b);
		f.add(tf);
		f.setSize(400, 400);
		f.setLayout(null);
		f.setVisible(true);
		
	}
}





	Example of displaying image on the button :-----------




import javax.swing.*;
class demo
{
    public static void main(String [] args)
    {
        JFrame jf=new JFrame("Button Example");
        JButton jb=new JButton("bg.jpg");
        jb.setBounds(100,100,100,40);
        jf.setSize(300,400);
        jf.add(jb);
        jf.setLayout(null);
        jf.setVisible(true);
        jf.setResizeable(false);
        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    }
}





	Java JLabel :------------------

The object of JLabel class is a component for placing text in a container it is used to display  a single line of read only text. The text can be changed by an application but a user cannot edit it directly. It inherits JComponent class.


	JLable class declaration :-
Let's see the declaration for javax.swing.JLable class.

	public class JLabel extends JComponent implements SwingConstants, Accessible


	Commonly used Constructor :------------

1) JLabel()				create a JLabel instance with no image with an empty string for the site
2) JLabel(String s)				create a JLabel instance with the specified text
3) JLabel(Icon i)				create a JLabel instance with the specified image
4) JLabel(String s,Icon i,int horizontalAlignment)	create a JLabel instance with the specified text image end horizontal alignment



	Commonly used Methods :----------------

1) String getText()				return the text string that a label displays
2) void setText(String text)			it defines the signal line of text this component will display
3) void setHorizontalAlignment(int alignment)	it set the alignment of the label content along the x-axis
4) Icon getIcon()				it return the graphics image that the label display
5) int getHorizontalAlignment			it return  the alignment of the label containts along the x-axis




	Java JLabel Example :-

import javax.swing.*;
class demo
{
    public static void main(String [] args)
    {
        JFrame jf=new JFrame("Label Example");
        JLabel l1,l2;
        l1=new JLabel("First Label");
        l1.setBounds(50,50,100,30);
        l2=new JLabel("Second Label");
        l2.setBounds(50,100,100,30);
        jf.add(l1);
        jf.add(l2);
        jf.setLayout(null);
        jf.setVisible(true);
        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    }
}




	
	Java JTextField :-----------

The object of a JTextField class is a text component that allows the editing of a single line text. It inherits JTextComponent class.

	JTextField class declaration

	public class JTextField extends JTextComponent inplements SwingConstants


	
Commonly used constructor :---

1) JTextField()			creates a new TextField.
2) JTextField(String text)		creates a new TextField initialized with the specified text.
3) JTextFielf(String text,int columns)	create a new TextField initialized with the specified text and columns.
4) JTextField(int columns)		create a new empty TextField with the specified number of columns.




	Commonly used Methods :-----------
1) void addActionListener(ActionListener l)	it is used to add the specified action listener to recieve action evevnts from this textfield.
2) Action getAction()				it return the currently set action for this ActionEvent source or null if no Action is set.
3) void setFont(Font f)			it is used to set the current font.





Example=>

import javax.swing.*;
class demo
{
    public static void main(String [] args)
    {

        JFrame j=new JFrame("JTextArea");
        JTextField f1,f2;
        f1=new JTextField("Welcome to Javapoint");// that is going to be the default text on the textfeild
        f2=new JTextField("AET Tutorial");
        f1.setBounds(50,100,200,30);
        f2.setBounds(50,150,200,30);
        j.add(f1);
        j.add(f2);
        j.setSize(400,400);
        j.setLayout(null);
        j.setVisible(true);
        j.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

    }
}




	Addition of Two Number using Swing :-----

Example:-

import javax.swing.*;
import java.awt.event.*;
class demo implements ActionListener
{
    JFrame jf;
    JTextField f1,f2,f3;
    demo()
    {
        jf=new JFrame("Ali Hasan Calculator");
        JLabel l1=new JLabel("First Number");
        JLabel l2=new JLabel("Second Number");
        JLabel l3=new JLabel("Summation");
        
        JButton b;
        f1=new JTextField();
        f2=new JTextField();
        f3=new JTextField();
        b=new JButton("Sum");
        l1.setBounds(50,100,100,25);
        l2.setBounds(50, 150, 100, 25);
        f1.setBounds(200,100,100,25);
        f2.setBounds(200,150,100,25);
        l3.setBounds(50,200,100,25);
        f3.setBounds(200,200,100,25);
        b.setBounds(150, 270, 80,25);
        b.addActionListener(this);
        jf.add(l1);
        jf.add(f1);
        jf.add(l2);
        jf.add(f2);
        jf.add(l3);
        jf.add(f3);
        jf.add(b);
        jf.setLayout(null);
        jf.setSize(400,400);
        jf.setVisible(true);
        jf.setResizable(false);
        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);        
    }

    public void actionPerformed(ActionEvent e)
    {
            int number1=Integer.parseInt(f1.getText());
            int number2=Integer.parseInt(f2.getText());

                int result=number1+number2;

                f3.setText(String.valueOf(result));
    }

    public static void main(String [] args)
    {
        new demo();
    }

}



	Getting the source of an ActionEvent in Calculator :----------------


import javax.swing.*;
import java.awt.event.*;
class demo implements ActionListener
{
    JFrame jf;
    JTextField f1,f2,f3;
    JButton b,b1,b2;
    demo()
    {
        jf=new JFrame("Ali Hasan Calculator");
        JLabel l1=new JLabel("First Number");
        JLabel l2=new JLabel("Second Number");
        JLabel l3=new JLabel("Result");
        
        f1=new JTextField();
        f2=new JTextField();
        f3=new JTextField();
        b=new JButton("+");
        b1=new JButton("-");
        b2=new JButton("x");
        l1.setBounds(50,50,100,25);
        l2.setBounds(50,100,100,25);
        f1.setBounds(200,50,100,25);
        f2.setBounds(200,100,100,25);
        l3.setBounds(50,200,100,25);
        f3.setBounds(200,200,100,25);
        b.setBounds(70,150,50,25);
        b1.setBounds(130,150,50,25);
        b2.setBounds(190,150,50,25);
        b.addActionListener(this);
        b1.addActionListener(this);
        b2.addActionListener(this);
        jf.add(l1);
        jf.add(f1);
        jf.add(l2);
        jf.add(f2);
        jf.add(l3);
        jf.add(f3);
        jf.add(b);
        jf.add(b1);
        jf.add(b2);
        jf.setLayout(null);
        jf.setSize(400,400);
        jf.setVisible(true);
        jf.setResizable(false);
        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);        
    }

    public void actionPerformed(ActionEvent e)
    {
        if(e.getSource()==b)
        {
            int number1=Integer.parseInt(f1.getText());
            int number2=Integer.parseInt(f2.getText());
            f3.setText(String.valueOf(number1+number2));
        }
        else if(e.getSource()==b1)
        {
            int number1=Integer.parseInt(f1.getText());
            int number2=Integer.parseInt(f2.getText());

            if(number1>number2)
            f3.setText(String.valueOf(number1-number2));
            else
            f3.setText(String.valueOf(number2-number1));
        }
        else if(e.getSource()==b2)
        {
            int number1=Integer.parseInt(f1.getText());
            int number2=Integer.parseInt(f2.getText());
            f3.setText(String.valueOf(number1*number2));
        }

    }

    public static void main(String [] args)
    {
        new demo();
    }

}






	Java JTextArea :-----------------

The object of a JTextArea class is a multiple line region that display text. It allows the editing of multiple line text.
It inherits JTextComponent class.

	JTextArea class declaration:-

	public class JTextArea extends JTextComponent


	Commonly used Constructor :

1) JTextArea()			create a text area that display no text initially
2) JTextArea(String s)		create a text that display specified text initially
3) JTextArea(int row,int column)	create a text area with the specified number of rows and column that display
4) JTextArea(String s,int row,int column)	create a text area with the specified number of rows and colums that display specfied text


	Commonly used Methods:--------------
1) void setRows(int rows)		it is used to set specified number of rows
2) void setColumns(int cols)		it is used to set specified number of columns
3) void setFont(Font f)		it is used to set the specified font
4) void insert(String s,int position)	it is used to insert the specified text on the specified position	
5) void append(String s)		it is used to append the given text the end of the document





	Java JTextArea Example:-

import javax.swing.*;
class demo
{
    JFrame jf;
    JTextArea jt;
    demo()
    {
        jf=new JFrame("JTextArea");
        jt=new JTextArea("Welcome");
        jt.setBounds(10,30,200,200);
        jf.add(jt);
        jf.setSize(400,400);
        jf.setLayout(null);
        jf.setVisible(true);
        jf.setResizable(false);
        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    }
    public static void main(String [] args)
    {
        new demo();
    }
}




	Java JTextArea Example withh ActionListener :-----------------


import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.*;
class demo implements ActionListener
{
    JFrame jf;
    JTextArea jt;
    JLabel l1,l2;
    JButton jb;
    demo()
    {
        jf=new JFrame("JTextArea");
        jt=new JTextArea("Welcome");
        jb=new JButton("Count");
        l1=new JLabel();
        l2=new JLabel();
        l1.setBounds(50,25,100,30);
        l2.setBounds(160,25,100,30);
        jt.setBounds(20,75,250,200);
        jb.setBounds(100,300,120,30);
        jb.addActionListener(this);
        jf.add(jt);
        jf.add(l1);
        jf.add(l2);
        jf.add(jb);
        jf.setSize(400,400);
        jf.setLayout(null);
        jf.setVisible(true);
        jf.setResizable(false);
        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    }

    public void actionPerformed(ActionEvent e)
    {
        String text=jt.getText();
        String words[]=text.split(" ");
        l1.setText("Words : "+words.length);
        l2.setText("Character : "+text.length());
    }
    public static void main(String [] args)
    {
        new demo();
    }
}






	Java JPasswordField :-------------------

The object of a JPasswordFeild class is text component specialized for password entry.
It allows the editing of a single line of text.
It inherits JTextField class.	


	JPassowrdField class declaration:

	public class JPasswordField extends JTextField


	Commonly used constructor :-

1) JPasswordField()			construct a new JPasswordField with a default document null starting text string and 0 column width
2) JPasswordField(int column)		construct a new entry JPasswordField with the specified number of columns
3) JPasswordField(String str)		construct a new JPasswordField initialized with the specified text
4) JPasswordField(String str,int column)	construct a new JPasswordField initialized with the specified text and columns




	JPasswordField Example:-

import javax.swing.*;
class demo
{
    public static void main(String [] args)
    {
        JFrame f=new JFrame("JPasswordField");
        JPasswordField pss=new JPasswordField();
        JLabel l=new JLabel("Passowrd");
        l.setBounds(20,100,80,30);
        pss.setBounds(100,100,100,30);
        f.add(l);
        f.add(pss);
        f.setLayout(null);
        f.setSize(300,300);
        f.setVisible(true);
        f.setResizable(false);
        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    }
}






	Java JCheckBox :-----------------

The JCheck class is used to create a checkbox. it is used to turn an option on(true) or off(false).
Clicking on a CheckBox change its state from on off or off to on .
It inherits JToggleButton class


	JCheckBox class Declaration :-

	public class JCheckBox extends JToggleButton implements Accessible

	

	Commonly used constructor :-

1) JCheckBox()			create an initially unselected check box button with no text no icon.
2) JChexkBox(String s)		create an initially unselected check box with text.
3) JCheckBox(String s,boolean b)	create a check box with text and specified whether or not it is initially selected.
4) JCheckBox(Action a)		create a check box where properties are taken from the action suplied.



	Commonly used Methods :-

1) AccessibleContext getAccessibleContext()		it is used to get the AccessibleContext associated with this JCheckBox
2) protected String paramString()			it return a string represented of this JCheckBox	




Example:--------


import javax.swing.*;
class demo
{
    public static void main(String [] args)
    {
        JFrame f=new JFrame("JCheckBox");
        JCheckBox jc=new JCheckBox("C++");
        jc.setBounds(100,100,50,50);
        JCheckBox jc1=new JCheckBox("Java",true);
        jc1.setBounds(100, 150 , 80, 50);
        f.add(jc);
        f.add(jc1);
        f.setSize(400,400);
        f.setLayout(null);
        f.setVisible(true);
        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    }
}





Example:----

import javax.swing.*;
import java.awt.event.*;
class demo implements ItemListener
{
    JFrame f;
    JCheckBox c1,c2;
    JLabel l;
    demo()
    {
        f=new JFrame("Check Box");
        c1=new JCheckBox("C++");
        c2=new JCheckBox("Java");
        l=new JLabel();
        l.setBounds(50,25,100,30);
        c1.setBounds(150,100,50,50);
        c2.setBounds(150,150,80,50);
        c1.addItemListener(this);
        c2.addItemListener(this);
        f.add(c1);
        f.add(c2);
        f.add(l);
        f.setVisible(true);
        f.setSize(400, 400);
        f.setLayout(null);
        f.setResizable(false);
        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    }

    public void itemStateChanged(ItemEvent e)
    {
        if(e.getSource()==c1)
        {
            if(e.getStateChange()==1)
            {
                l.setText("C++ CheckBox is Checked");
            }
            
        }
        else if(e.getSource()==c2)
        {
            if(e.getStateChange()==1)
            {
                l.setText("Java CheckBox is Checked");
            }
        }
    }
    public static void main(String [] args)
    {
        new demo();
    }
}








	Java JRadioButton :---------------

The JRadioButton class is used a radio button. it is used to chose one option from multiple options.It is widely used in exams systems or quiz.
 It should be added in ButtonGroup to select one radio button only.


	JRadioButton class Declaration :-
	
	public class JRadioButton extends JToggleButton implements Accessible


	Commonly used Constructor :---------------

1) JRadioButton()		create a unselected radio button with no text
2) JRadioButton(String s)	create an unselected radio button with specified text
3) JRadioButton(String s,boolean b)	create an selected radio button with the specified text and selected status.



	Commonly used Mthods:-----------------


1) void setText(String s)		it is used to set specified text on button
2) String getText()			it is used to return the text of the button
3) vois setEnable(boolean b)		it is used to return the text of the button
4) void selIcon(Icon b)		it is used to set the specified icon on the button
5) Icon getIcon()			it is used to set the ison of the button
6)void addActionListener(ActioListener a) it is used to add the action listener to this object


Example=>

import javax.swing.*;
class demo
{
    JFrame f;
    JRadioButton r1,r2;
    demo()
    {
        f=new JFrame("JRadioButton");
        r1=new JRadioButton("A) Male");
        r2=new JRadioButton("B) Female");
        r1.setBounds(75, 50, 100, 30);
        r2.setBounds(75,100,100,30);
        ButtonGroup b=new ButtonGroup();
        b.add(r1);
        b.add(r2);
        f.add(r1);
        f.add(r2);
        f.setSize(400,400);
        f.setLayout(null);
        f.setVisible(true);
        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    }
    public static void main(String [] args)
    {
        new demo();
    }
}





	Java JRadioButton Example with ActionListener :-------------


import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.*;
class demo implements ActionListener
{
    JFrame f;
    JRadioButton r1,r2;
    JButton but;
    demo()
    {
        f=new JFrame("JRadioButton");
        r1=new JRadioButton("A) Male");
        r2=new JRadioButton("B) Female");
        but=new JButton("Click");
        r1.setBounds(75, 50, 100, 30);
        r2.setBounds(75,100,100,30);
        but.setBounds(100, 150, 80, 30);
        but.addActionListener(this);
        ButtonGroup b=new ButtonGroup();
        b.add(r1);
        b.add(r2);
        f.add(r1);
        f.add(r2);
        f.add(but);
        f.setSize(400,400);
        f.setLayout(null);
        f.setVisible(true);
        f.setResizable(false);
        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    }

    public void actionPerformed(ActionEvent e)
    {
        if(r1.isSelected())
        {
            JOptionPane.showMessageDialog(null,"You are Male");
        }
        if(r2.isSelected())
        {
            JOptionPane.showMessageDialog(null,"You are Female");
        }
    }
    public static void main(String [] args)
    {
        new demo();
    }
}







	=> Java JComboBox

the object of Choice class is used to show popup menu of choices. Choices selected by user is shown on the top of a menu .
It inherits JComponent class.



	JComboBox class declaration :-

	public class JComboBox extends JComponent implements ItemSelected


	Commonly used Constructor :-

1) JComboBox()			create a JComboBox with a default data model
2) JComboBox(object[] item)		create a JComboBox that contains the elements in the specified array
3) JComboBox(Vector<?> items)	create a JComboBox that contains the elements in the specified Vector.



	Commonly used Method :-

1) void additem(Object anObject)		it is used to add item to the item list.
2) void removeitem(Object anObject)		it is used to delete an item to iten list
3) void setEditable(boolean b)			it is used to determine whether the JComboBox is editable
4) void addActionListener(ActionListener a)	it is used  to add the ActionListener
5) void addItemListener(item Listener)		it is used to add the ItemListener




Example=>

import javax.swing.*;
class demo
{
    JFrame f;
    demo()
    {
        String country[]={"India","Aus","U.S.A","England","Canada"};
        f=new JFrame("JComboBox");
        JComboBox cb=new JComboBox(country);
        cb.setBounds(50, 50, 90, 20);
        f.add(cb);
        f.setSize(400,400);
        f.setLayout(null);
        f.setVisible(true);
        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    }
    public static void main(String [] args)
    {
        new demo();
    }
}



	

	Java JComboBox Example with ActionListener :-


import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
class demo implements ActionListener
{
    JFrame f;
    JButton b;
    JLabel l;
    JComboBox cb;
    demo()
    {
        String country[]={"India","Australia","France","Canada","England"};
        f=new JFrame("Combo Box Example");
        b=new JButton("Show");
        l=new JLabel();
        cb=new JComboBox(country);
        cb.setBounds(50,100,90,20);
        b.setBounds(200, 100, 75, 20);
        b.addActionListener(this);
        f.add(cb);
        f.add(b);
        f.add(l);
        f.setSize(350,350);
        f.setVisible(true);
        f.setLayout(null);
        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    }

    public void actionPerformed(ActionEvent e)
    {
        String str="Programming Language Selected"+cb.getItemAt(cb.getSelectedIndex());
        l.setText(str);

    }
    public static void main(String [] args)
    {
        new demo();
    }
}







	JTable :------------------------------------
The JTable class is used to display data in tabular form. It is composed of rows and Columns

	JTable class declaration :-

Let's see the declaration for javax.swing.JTable class.

	Commonly used Constructors:-

JTable()					creates a table with empty cells
JTable(Object[][] rows, Object[] columns)		creates a table with the specified data.


	Java JTable Example:-

import javax.swing.*;
public class TableExample
{
	JFrame f;
	TableExample()
	{
		f=new JFrame();
		String data[][]={{"101","Amit","670000"},{"102","Jai","780000"},{"101","Sachin","700000"}};
		String column[]={"ID","Name","Salary"};
		JTable jt=new JTable(data,column);
		jt.setBounds(30,40,200,300);
		JScrollPane sp=new JScrollPane(jt);
		f.add(sp);
		f.setSize(300,400);
		f.setVisible(true);
	}
	public static void main(String [] args)
	{
		new TableExample();
	}
}





	Java Jtable Example with ListSelectionListener :-

import javax.swing.*;    
import javax.swing.event.*;  
public class TableExample {    
      public static void main(String[] a) {  
            JFrame f = new JFrame("Table Example");  
            String data[][]={ {"101","Amit","670000"},    
                                                                       {"102","Jai","780000"},    
                                                                       {"101","Sachin","700000"}};    
                            String column[]={"ID","NAME","SALARY"};         
                            final JTable jt=new JTable(data,column);    
            jt.setCellSelectionEnabled(true);  
            ListSelectionModel select= jt.getSelectionModel();  
            select.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);  
            select.addListSelectionListener(new ListSelectionListener() {  
              public void valueChanged(ListSelectionEvent e) {  
                String Data = null;  
                int[] row = jt.getSelectedRows();  
                int[] columns = jt.getSelectedColumns();  
                for (int i = 0; i < row.length; i++) {  
                  for (int j = 0; j < columns.length; j++) {  
                    Data = (String) jt.getValueAt(row[i], columns[j]);  
                  } }  
                System.out.println("Table element selected is: " + Data);    
              }       
            });  
            JScrollPane sp=new JScrollPane(jt);    
            f.add(sp);  
            f.setSize(300, 200);  
            f.setVisible(true);  
          }  
        } 

If you select an element in column NAME name of the element will be displayed on the console:
Table element selected is : Sachin







	Java JList :-------------------

the object of JList class represent a list of text items. The list of text items can be set up so that the user can choose either one item or multiple items. It inherites JComponent class.


JList class declaration :-
public class JList extends JComponent implements Scrollable, Accessible


Commonly used Constructors:

	Constructor			Description
	JList()				Creates a JList with an empty, read-only, model.
	JList(ary[] listData)			Creates a JList that displays the elements in the specified array.
	JList(ListModel<ary> dataModel)	Creates a JList that displays elements from the specified, non-null, model.




Commonly used Methods:

Methods						Description
Void addListSelectionListener(ListSelectionListener listener)	It is used to add a listener to the list, to be notified each time a change to the selection occurs.

int getSelectedIndex()				It is used to return the smallest selected cell index.
ListModel getModel()				It is used to return the data model that holds a list of items displayed by the JList component.

void setListData(Object[] listData)			It is used to create a read-only ListModel from an array of objects.



Java JList Example

import javax.swing.*;  
public class ListExample  
{  
         ListExample(){  
        JFrame f= new JFrame();  
        DefaultListModel<String> l1 = new DefaultListModel<>();  
          l1.addElement("Item1");  
          l1.addElement("Item2");  
          l1.addElement("Item3");  
          l1.addElement("Item4");  
          JList<String> list = new JList<>(l1);  
          list.setBounds(100,100, 75,75);  
          f.add(list);  
          f.setSize(400,400);  
          f.setLayout(null);  
          f.setVisible(true);  
     }  
     public static void main(String args[])  
    {  
               new ListExample();  
    }
}  



Java JList Example with ActionListener :-

import javax.swing.*;  
import java.awt.event.*;  
public class ListExample  
{  
     ListExample(){  
        JFrame f= new JFrame();  
        final JLabel label = new JLabel();          
        label.setSize(500,100);  
        JButton b=new JButton("Show");  
        b.setBounds(200,150,80,30);  
        final DefaultListModel<String> l1 = new DefaultListModel<>();  
          l1.addElement("C");  
          l1.addElement("C++");  
          l1.addElement("Java");  
          l1.addElement("PHP");  
          final JList<String> list1 = new JList<>(l1);  
          list1.setBounds(100,100, 75,75);  
          DefaultListModel<String> l2 = new DefaultListModel<>();  
          l2.addElement("Turbo C++");  
          l2.addElement("Struts");  
          l2.addElement("Spring");  
          l2.addElement("YII");  
          final JList<String> list2 = new JList<>(l2);  
          list2.setBounds(100,200, 75,75);  
          f.add(list1); f.add(list2); f.add(b); f.add(label);  
          f.setSize(450,450);  
          f.setLayout(null);  
          f.setVisible(true);  
          b.addActionListener(new ActionListener() {  
              public void actionPerformed(ActionEvent e) {   
                 String data = "";  
                 if (list1.getSelectedIndex() != -1) {                       
                    data = "Programming language Selected: " + list1.getSelectedValue();   
                    label.setText(data);  
                 }  
                 if(list2.getSelectedIndex() != -1){  
                    data += ", FrameWork Selected: ";  
                    for(Object frame :list2.getSelectedValues()){  
                       data += frame + " ";  
                    }  
                 }  
                 label.setText(data);  
              }  
           });   
     }  
public static void main(String args[])  
    {  
   new ListExample();  
    }
}  





	Java JOptionPane :------------------------------------

The JOptionPane class is used to provide standard dialog boxes such as message dialog box, confirm dialog box and input dialog box. These dialog boxes are used to display information or get input from the user. The JOptionPane class inherits JComponent class.


JOptionPane class declaration
public class JOptionPane extends JComponent implements Accessible


Common Constructors of JOptionpane class:-

Constructor				Description
JOptionPane()				It is used to create a JOptionPane with a test message.
JOptionPane(Object message)			It is used to create an instance of JOptionPane to display a message.
JOptionPane(Object message, int messageType)	It is used to create an instance of JOptionPane to display a message with specified 					message type and default options.


Common Methods of JOptionPane class

Methods						Description
JDialog createDialog(String title)			It is used to create and return a new parentless JDialog with the specified title.

static void showMessageDialog(Component parentComponent, Object message)	It is used to create an information-message dialog titled "Message".

static void showMessageDialog(Component parentComponent, Object message, String title, int messageType)	It is used to create a message dialog with given title and messageType.

static int showConfirmDialog(Component parentComponent, Object message)	It is used to create a dialog with the options Yes, No and Cancel; with the title, Select an Option.

static String showInputDialog(Component parentComponent, Object message)	It is used to show a question-message dialog requesting input from the user parented to parentComponent.

void setInputValue(Object newValue)	It is used to set the input value that was selected or input by the user.






Example=>
import javax.swing.*;
public class demo
{

	JFrame f;
	demo()
	{
		f=new JFrame("OptionPane");
		JoptionPane.showMessageDialog(f,"Hello, Welcome to Javatpoint");
	}
	public static void main(String [] args)
	{
		new demo();
	}
}



Java JOptionPane Example: showMessageDialog()

import javax.swing.*;  
public class OptionPaneExample {  
JFrame f;  
OptionPaneExample(){  
    f=new JFrame();  
    JOptionPane.showMessageDialog(f,"Hello, Welcome to Javatpoint.");  
}  
public static void main(String[] args) {  
    new OptionPaneExample();  
}





next ?? prev
Java JOptionPane
The JOptionPane class is used to provide standard dialog boxes such as message dialog box, confirm dialog box and input dialog box. These dialog boxes are used to display information or get input from the user. The JOptionPane class inherits JComponent class.

JOptionPane class declaration
public class JOptionPane extends JComponent implements Accessible  
Common Constructors of JOptionPane class
Constructor	Description
JOptionPane()	It is used to create a JOptionPane with a test message.
JOptionPane(Object message)	It is used to create an instance of JOptionPane to display a message.
JOptionPane(Object message, int messageType	It is used to create an instance of JOptionPane to display a message with specified message type and default options.
Common Methods of JOptionPane class
Methods	Description
JDialog createDialog(String title)	It is used to create and return a new parentless JDialog with the specified title.
static void showMessageDialog(Component parentComponent, Object message)	It is used to create an information-message dialog titled "Message".
static void showMessageDialog(Component parentComponent, Object message, String title, int messageType)	It is used to create a message dialog with given title and messageType.
static int showConfirmDialog(Component parentComponent, Object message)	It is used to create a dialog with the options Yes, No and Cancel; with the title, Select an Option.
static String showInputDialog(Component parentComponent, Object message)	It is used to show a question-message dialog requesting input from the user parented to parentComponent.
void setInputValue(Object newValue)	It is used to set the input value that was selected or input by the user.

 
Java JOptionPane Example: showMessageDialog()
import javax.swing.*;  
public class OptionPaneExample {  
JFrame f;  
OptionPaneExample(){  
    f=new JFrame();  
    JOptionPane.showMessageDialog(f,"Hello, Welcome to Javatpoint.");  
}  
public static void main(String[] args) {  
    new OptionPaneExample();  
}  
}  
Output:




Java Joptionpane 1

Java JOptionPane Example: showMessageDialog()
import javax.swing.*;  
public class OptionPaneExample {  
JFrame f;  
OptionPaneExample(){  
    f=new JFrame();  
    JOptionPane.showMessageDialog(f,"Successfully Updated.","Alert",JOptionPane.WARNING_MESSAGE);     
}  
public static void main(String[] args) {  
    new OptionPaneExample();  
}  
} 





Java JOptionPane Example: showInputDialog()
import javax.swing.*;  
public class OptionPaneExample {  
JFrame f;  
OptionPaneExample(){  
    f=new JFrame();   
    String name=JOptionPane.showInputDialog(f,"Enter Name");      
}  
public static void main(String[] args) {  
    new OptionPaneExample();  
}  
}






Java JOptionPane Example: showConfirmDialog()
import javax.swing.*;  
import java.awt.event.*;  
public class OptionPaneExample extends WindowAdapter{  
JFrame f;  
OptionPaneExample(){  
    f=new JFrame();   
    f.addWindowListener(this);  
    f.setSize(300, 300);  
    f.setLayout(null);  
    f.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);  
    f.setVisible(true);  
}  
public void windowClosing(WindowEvent e) {  
    int a=JOptionPane.showConfirmDialog(f,"Are you sure?");  
if(a==JOptionPane.YES_OPTION){  
    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);  
}  
}  
public static void main(String[] args) {  
    new  OptionPaneExample();  
}     
}







	Java JScrollBar :-------------------
The object of JScrollbar class is used to add horizontal and vertical scrollbar. It is an implementation of a scrollbar. It inherits JComponent class.

JScrollBar class declaration :-

	public class JScrollBar extends JComponent implements Adjustable, Accessible

Commonly used Constructors:-

Constructor					Description
JScrollBar()					Creates a vertical scrollbar with the initial values.
JScrollBar(int orientation)				Creates a scrollbar with the specified orientation and the initial values.
JScrollBar(int orientation, int value, int extent, int min, int max)	Creates a scrollbar with the specified orientation, value, extent, minimum, and maximum.




Java JScrollBar Example
import javax.swing.*;  
class ScrollBarExample  
{  
ScrollBarExample(){  
    JFrame f= new JFrame("Scrollbar Example");  
 JScrollBar s=new JScrollBar();  
s.setBounds(100,100, 50,100);  
f.add(s);  
f.setSize(400,400);  
f.setLayout(null);  
f.setVisible(true);  
}  
public static void main(String args[])  
{  
new ScrollBarExample();  
}}





Java JScrollBar Example with AdjustmentListener
import javax.swing.*;  
import java.awt.event.*;  
class ScrollBarExample  
{  
ScrollBarExample(){  
    JFrame f= new JFrame("Scrollbar Example");  
    final JLabel label = new JLabel();          
    label.setHorizontalAlignment(JLabel.CENTER);    
    label.setSize(400,100);  
    final JScrollBar s=new JScrollBar();  
    s.setBounds(100,100, 50,100);  
    f.add(s); f.add(label);  
    f.setSize(400,400);  
   f.setLayout(null);  
   f.setVisible(true);  
   s.addAdjustmentListener(new AdjustmentListener() {  
    public void adjustmentValueChanged(AdjustmentEvent e) {  
       label.setText("Vertical Scrollbar value is:"+ s.getValue());  
    }  
 });  
}  
public static void main(String args[])  
{  
   new ScrollBarExample();  
}} 










	Java JMenuBar, JMenu and JMenuItem :-------------------------------------------------

The JMenuBar class is used to display menubar on the window or frame. It may have several menus.

The object of JMenu class is a pull down menu component which is displayed from the menu bar. It inherits the JMenuItem class.

The object of JMenuItem class adds a simple labeled menu item. The items used in a menu must belong to the JMenuItem or any of its subclass.





JMenuBar class declaration
public class JMenuBar extends JComponent implements MenuElement, Accessible  

JMenu class declaration
public class JMenu extends JMenuItem implements MenuElement, Accessible  

JMenuItem class declaration
public class JMenuItem extends AbstractButton implements Accessible, MenuElement 







Java JMenuItem and JMenu Example
import javax.swing.*;  
class MenuExample  
{  
          JMenu menu, submenu;  
          JMenuItem i1, i2, i3, i4, i5;  
          MenuExample(){  
          JFrame f= new JFrame("Menu and MenuItem Example");  
          JMenuBar mb=new JMenuBar();  
          menu=new JMenu("Menu");  
          submenu=new JMenu("Sub Menu");  
          i1=new JMenuItem("Item 1");  
          i2=new JMenuItem("Item 2");  
          i3=new JMenuItem("Item 3");  
          i4=new JMenuItem("Item 4");  
          i5=new JMenuItem("Item 5");  
          menu.add(i1); menu.add(i2); menu.add(i3);  
          submenu.add(i4); submenu.add(i5);  
          menu.add(submenu);  
          mb.add(menu);  
          f.setJMenuBar(mb);  
          f.setSize(400,400);  
          f.setLayout(null);  
          f.setVisible(true);  
}  
public static void main(String args[])  
{  
new MenuExample();  
}}  




